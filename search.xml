<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Algorithm - Recurrence]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F01%2FAlgorithm-Recurrence%2F</url>
    <content type="text"><![CDATA[Recurrence Substutution method Concept 以經驗猜測一個邊界(bound)。 假設子問題符合此邊界，證明母問題也符合此邊界。 適用時機 題目比分重。 單向；單邊：只需要證明 \(O, \Omega\) 單向，不必證明 \(\Theta\) 。 題目要求。 經典範例 Ex \(T(n) = 2 T(floor(\frac n2))+n\)，問\(T(n) = O(？)\)，單向證明 (substution method) 猜：\(T(n) = (n \lg n)\) ＜想法＞已知\(g(n) = 2 g(\frac n2)+n = O(n\lg n)\) 欲證\(T(n) = O(n \lg n)\)，即證明\(\exists C, n_0&gt;0 \ni n \geq n_0, T(n) \leq C \cdot n\lg n\)；假設子問題 \(T(floor(n)) \leq C \cdot floor(\frac n2)\lg floor(\frac n 2)\) 成立；考慮(consider)：\(T(n) = 2\cdot T(floor(\frac n2))+n \leq 2 \cdot C \cdot floor(\frac n2)\lg floor(\frac n2)+n\)\(\Rightarrow T(n) = 2\cdot T(floor(\frac n2))+n \leq 2 \cdot C \cdot \frac n2\lg \frac n2+n\)\(\Rightarrow T(n) = 2\cdot T(floor(\frac n2))+n \leq C \cdot n(\lg n - \lg2)+n = C \cdot n\lg n + (1 - C)n\)取 \(C \geq 2, T(n) = 2\cdot T(floor(\frac n2))+n \leq C \cdot n \lg n\)\(\therefore T(n) = O(n\lg n)\) Ex (97成大資工) (10%) 解 \(T(n) = 2T(\lfloor \sqrt n \rfloor)+\lg n\), 用 O 表示。( 比分重、單邊、\(\lfloor\rfloor\) )考慮使用 substution method 而不使用疊代法。 \(\lg n \lg \lg n\) Recurrence tree 名詞解釋 \(T(n) = T(\frac n3)+T(\frac 23 n) + n\) \(r = \frac 13+\frac 23 = 1\)：子問題的 n 係數的相加。 \(T(n)\)：母問題。 \(T(\frac n3), T(\frac 23n)\)：子問題。 \(n\)：Cost，將子問題合併的代價。 適用時機 子問題個數大於二 子問題型態為\(T(\frac n a)\) 經典範例 tree_1 \(r &lt; 1\) Ex ( 94 成大資工 ) \(T(n) = T(\frac n2) + T(\frac n4) + T(\frac n8) + n\)，求 \(\Theta\) Sol \(r = \frac n 2 + \frac n 4 + \frac n 8 = \frac 7 8 &lt; 1\) 建立遞迴樹\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l\) (等比級數) 求取其邊界 (夾擊法)求上邊界：\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \leq n + \frac 78 n +\frac{49}{64}n + \ldots\) (有限等比級數小於無限等比級數)\(\Rightarrow \frac{n}{1 - \frac 7 8} = 8 n \Rightarrow T(n) = O(n)\)求下邊界：\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \geq n \Rightarrow T(n) = \Omega(n)\) \(\Rightarrow T(n) = \Theta(n)\) tree_1 \(r = 1\) Ex (100 政大)(90 ,91 台大) \(T(n) = T(\frac n3) + T(\frac 23) + n\) Sol \(r = \frac 13+\frac{2}{3} = 1\) 建立遞迴樹\(T(n) = n+n+n+\ldots+C_l\) 求取其邊界求上邊界：因為\((\frac23)^k*n= 1 \Rightarrow k = \log_{\frac32}n \Rightarrow 高度 = k + 1\) ，所以 \(T(n) = n+n+n+\ldots+C_l \leq n \cdot \log_{\frac32}n+1\)\(\Rightarrow T(n) = O(n\log n)\)求下邊界：\(T(n) = n+n+n+\ldots+C_l \geq n \cdot \log_3n + 1\)\(\Rightarrow T(n) = \Omega(n\log n)\) \(\Rightarrow T(n) = \Theta(n\lg n)\) \(r &gt; 1\) 無，因為子問題的數量比母問題大。 Master theorem 令 \(T(n) = aT(\frac{n}{b})+f(n), a \geq 1, b &gt; 1\) 。 若 \(\exists \epsilon &gt; 0 \ni f(n) = O(n^{\log_ba-\epsilon})\) ，則 \(T(n) = \Theta(n^{\log_ba})\)。 若 \(\exists \epsilon &gt; 0, 0 &lt; c &lt; 1 \ni f(n) = O(n^{\log_ba+\epsilon}) \;and\; af(\frac nb) &lt; cf(n)\)，則 \(T(n) = \Theta(f(n))\)。 ☆若 \(f(n) = \Theta(n^{\log_ba}\cdot \lg^kn), k \geq 0\)，則 \(T(n) = \Theta(n^{\log_ba}\cdot\lg^{k+1}n)\) (與 f(n) 相差 \(lg\) 的次方)。 經典例題 Ex ( 100 政大 ) \(T(n) = 7T(\frac n2) + n^2\) sol By master theorem \(\Rightarrow \exists \epsilon = \lg 7 - 2 \ni n^2 = O(n^{\log_27-\epsilon})\)，所以\(T(n) = \Theta(n^{\lg 7})\)。 Ex ( 99 交大 ) \(T(n) = 3T(\frac n4) + n\lg n\) sol By master theorem \(\Rightarrow n^{log_43} = n^{1-\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)\(\Rightarrow n\log n = \omega(n) = \omega(n^{1-\epsilon})\)，所以\(T(n) = \Theta(n\log n)\)。 Ex ( 98 交大 ) \(T(n) = 3T(\frac n2)+ n \lg n\) sol By master theorem \(\Rightarrow n^{log_23} = n^{1+\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)\(\Rightarrow n\log n = o(n^{1+\epsilon})\)，所以\(T(n) = \Theta(n^{\log_23})\)。 \(T(n) = 4T(\frac n2) + n\lg n\) sol By master theorem \(\Rightarrow n^{log_24} = n^2\)\(\Rightarrow n^{2} = \omega(n\log n)\)，所以\(T(n) = \Theta(n^2)\)。 ＜Note＞ ☆ 與 \(f(n)\) 比較，\(f(n)\) 多了\(\frac{1}{\lg n}\) $T(n) = 4 T(n2) + $ sol 不可使用 Master Theorem。 \(n^{\log_ba = n^2}, f(n) = \frac{n^2}{\lg n} \Rightarrow T(n) = n^2\lg \lg n\) ＜Note＞ ☆ 與 \(f(n)\) 比較，\(f(n)\) 多了\(\frac{1}{\lg^a n} , a &gt; 1\) 直接為 \(O(n^{\log_ab})\) 進階遞迴問題 Ackermann’s function \[ \left\{\begin{matrix} A(0, n) &amp; = &amp; n+1 &amp; (1)\\ A(m , 0) &amp; = &amp; A(m-1, 1) &amp; (2)\\ A(m , n) &amp; = &amp; A(m-1, A(m, n-1)) &amp; (3) \end{matrix}\right. \] 求取 \(A(1, n)\) 的通解。 \[ \begin{matrix} 令 \; a_n &amp;=&amp; A(1, n) &amp; \\ &amp; = &amp; A(0, A(1, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(0, a_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; a_{n-1} + 1 &amp; By \; (1) \\ \end{matrix} \] 且 \[ a_0 = A(1, 0) = A(0, 1) = 2 \] 所以， \[ \begin{matrix} a_n &amp; = &amp; a_{n-1} + 1 \\ &amp; = &amp; (a_{n-2} + 1) + 1 \\ &amp; = &amp; ((a_{n-3} + 1) + 1) + 1 \\ &amp; \ldots &amp; \\ &amp; = &amp; a_0 + \sum_{i = 1}^{n-1} + 1 \\ &amp; = &amp; 2 + n &amp; \forall n \geq 0 \end{matrix} \] 求取 \(A(2, n)\) 的通解。 \[ \begin{matrix} 令 \; b_n &amp;=&amp; A(2, n) &amp; \\ &amp; = &amp; A(1, A(2, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(1, b_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; a_{b_{n-1}} &amp; By \; 第一題結論 \\ &amp; = &amp; b_{n-1} + 2 \\ &amp; = &amp; (b_{n-2} + 2) + 2 \\ &amp; = &amp; ((b_{n-3}+2) + ) + 2 \\ &amp; \ldots &amp; \\ &amp; = &amp; b_0 + \sum_{i = 1}^{n-1}2 + 2 \\ &amp; = &amp; b_0 + 2n &amp; b_0 = A(2, 0) = A(1, 1) = a_1 = 3\\ &amp; = &amp; 2n + 3 &amp; \forall n \geq 0 \end{matrix} \] 求取 \(A(3, n)\) 的通解。 \[ \begin{matrix} 令 \; c_n &amp;=&amp; A(3, n) &amp; \\ &amp; = &amp; A(2, A(3, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(2, c_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; b_{c_{n-1}} &amp; By \; 第一題結論 \\ &amp; = &amp; 2c_{n-1} + 3 \end{matrix} \] 先求出 \(c_0 = A(3, 0) = A(2, 1) = b_1 = 5\) ，再來 \(c_n\) 特徵多項式為 \(\alpha - 2= 0 \Rightarrow \alpha = 2\)，所以令齊次解為 \(c_n^{(h)} = C_0\times2^n\)，接著 \(c_n\) 的特解為 \(c_n^{(p)} = C_1\times (1)\) 代回求 \(C_1\) \[ \begin{matrix} \Rightarrow C_1 = 2\times C_1 + 3 \\ \Rightarrow C_1 = -3 \\ \therefore c_n = c_n^{h} + c_n^{(p)} = C_0\times2^n - 3 \\ c_0 = 5 = C_0 - 3 \\ \Rightarrow C_0 = 8 \\ \therefore c_n = 2^{n+3} - 3, \forall n \geq 0 \end{matrix} \]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recurrence</tag>
        <tag>Ackermann</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Time Complexity]]></title>
    <url>%2Fwillywangkaa%2F2018%2F08%2F28%2FAlgorithm-Time-Complexity%2F</url>
    <content type="text"><![CDATA[Time complexity 重點 Asymptotic notation 考點著重 定義 特性 證明題、選擇題 Time complexity 的比較 定義法 極值法 ( limit )：以大資料的手法比較演算法的優劣。 對數法 ( log )：當該算法的等級差距大時方便判斷與解釋。 計算題要點 ( 離散數學 ) \(H _n = \Theta(\lg n)\) \(\log (n !) = \Theta (n \lg n)\) \(( \log_a n )^b = o (n ^k), k &gt; 0\) Asymptotic notation 當輸入資料變大時，程式執行的時間以何種趨勢成長。 符號定義 \(f(n) = O(g(n))\) \(\exists C, n_0 &gt; 0 , \ni f(n) \leq C \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic upper bound。 f(n) 的 Order 會小於 g(n) 的 Order。 $f(n) = (g(n)) $ \(\exists C , n_0 &gt; 0 \ni f(n) \geq C \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic lower bound。 f(n) 的 Order 會大於 g(n) 的 Order。 $f(n) = (g(n)) $ \(\exists C_1 , C_2, n_0 &gt; 0 \ni C_1 \times g(n) \leq f(n) \leq C_2 \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic tight bound。 f(n) 的 Order 會等於 g(n) 的 Order。 $f(n) = o (g(n)) $ 以比較 Order 的上面來看，是絕對小於的意義。 用極值法的方式方便解釋。 Ex：true or false \(n = o(2n)\)：false \(n = o(n^2)\)：true \(n = O(2n)\)：true $n = O(n^2) $：true \(f(n) = \omega(g(n))\) 以比較 Order 的上面來看，是絕對大於的意義。 用極值法的方式方便解釋。 \(2n = \omega(n)\)：false \(n^2 = \omega(n)\)：true ＜Note＞ ？若固定 \(g(n)\)，可以將所有函數作以下分類： Ex：\(g(n) = n^3\) 考古題 ( 99政大資料科學 ) Q 寫出 2 個在 \(O(n^3)\) 中但不在 \(o(n^3)\) 的函數。 A 題目亦等於在問舉出兩個函數在 \(\Theta(n^3)\) 的函數，所以 \(f(n) = n^3、2n^3\)。 考古題 ( 100 交大 ) Q NCTU：\(\Theta(n)\)、CS：\(\Omega(n)\) 下列何者正確？ （a） NCTU 總是比 CS 快。 （b） 當 n \(\geq\) 1000000000000 時 NCTU 比 CS 快。 （c） 兩者執行時間相同 （d） 稱 CS 的複雜度為 \(\Theta(n)\) （e） 以上皆非 A （e） 特性 \(f(n) = O (g(n)) \Rightarrow f(n)+g(n) = O(g(n))\) Ex (98 交大資工) \(P(n) = \sum_{i = 0}^{d} a_in^i\) 是 d 次多項式，下方表格何者正確？ 是否屬於右側集合 \(O(n^k)\) \(o(n^k)\) \(\Omega(n^k)\) \(\omega(n^k)\) \(\Theta(n^k)\) P(n) \(k&gt;d\) true true P(n) \(k &lt; d\) true true P(n) \(k = d\) true true true ＜Note＞ Ex (98 交大資工) - Q 請寫出此式 \(O(n^2) + \Theta(n^2)\) 最適合的等級。(理解： \(\exists f(n) \in O(n^2) , \exists g(n) \in \Theta(n^2) \quad f(n) + g(n) \in ？\)) A \(\Theta(n^2)\) Ex (100 中央) Prove or disprove：\(f(n) + g(n) = \Theta(\;max｛f(n), g(n)｝)\) Proof：(以定義證明) - \(\exists C_1 = 1, C_2 = 2, n_0 = 1\ni n \geq n_0, C_1(\;max｛f(n), g(n)｝) \leq f(n) + g(n) \leq C_2(\;max｛f(n), g(n)｝)\) \(f(n) = O(g(n)) 且 f(n) = \Omega (g(n)) \Leftrightarrow f(n) = \Theta(g(n))\) Ex (95 台大資工) (離散數學) Q \(\sum_{i = 0}^n i^5 = \Theta(n^a), a = ？\) A Prove：\(\sum_{i = 0}^n = O(n^6)\) Prove：\(\sum_{i = 0}^n = \Omega(n^6)\) 函數比較等級 ＜Note＞ L’Hôpital’s rule 的使用 若 \(\lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}\) 是不定型 (相除為 0 或 無限大)，則該函數等於 \(\lim_{n\rightarrow\infty}\frac{f&#39;(n)}{g&#39;(n)}\) 。 ＜Note＞ \((\ln x)&#39; = \frac{1}{x}\) ＜Note＞ log n 的底只要是常數其等級均相同。 Ex \(\ln n, \lg n, \log n, \log_{100}n\)等級均相等 定義法 適用時機 題目分數多。 函數的型態簡單帶值可算。 Ex (96 成大資工) True or false (10%) Q \(n^2 + n\lg n + \frac{n}{2} = O(n^8)\) A \(\exists C = 5, n_0 = 10\ni n\geq n_0, n^2 + n \lg n + \frac{n}{2} \leq c \times n^8\) Ex (91 交大資工) Prove the following is incorrect Q \(\frac{n^2}{\log n} = \Theta(n^2)\) A (矛盾證明法) \(\frac{n^2}{\log n} = \Theta(n^2) \Rightarrow \frac{n^2}{\log n} = O(n^2), \frac{n^2}{\log n} = \Omega(n^2)\) ，後者明顯錯誤所以從後者開始證明。 設\(\frac{n^2}{\log n} = \Omega(n^2)\)成立，則 \(\exists C, n_0 &gt; 0 \ni n &gt; n_0, \frac{n^2}{\log n} \geq C \times n^2\) \(\Rightarrow \frac{1}{\log n} \geq C (\rightarrow\leftarrow)\)，當 \(n\) 成長時\(\frac{1}{\log n}\) 會無限靠近 0 ，導致不存在 C &gt; 0 所以矛盾。 Ex (100 中央資工) Prove or disprove \(f(n) = \Theta(g(n)) \Rightarrow h(f(n)) = \Theta(h(g(n)))\)，其中 \(h(*)\) 為遞增函數。 false， 直接舉例 \(f(n) = 2n, g(n) = n \Rightarrow f(n) = \Theta(g(n))\) 而取 \(h(n) = 2^{n}\) 為遞增函數，但 \(h(f(n)) \ne O(h(g(n)))\) 極值法 適用時機 函數型態複雜，但可藉由微分使之容易分析。 證明 \(o, \omega\) 時可當作該集合之定義以分析。 使用方法 \(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = 0 \Leftrightarrow f(n) = o(g(n))\) \(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \infty \Leftrightarrow f(n) = \omega(g(n))\) $ L &gt; 0 ;is ;constant _{n} = L f(n) = (g(n))$ Ex \(f(n) = \log_34n, g(n) = \log_43n\)，問 \(f(n)\) 在 \(g(n)\) 的會在哪個等級集合 (\(O, \Omega, \Theta\)) 之中？ \(\lim_{n\rightarrow\infty}\frac{log_34n}{\log_43n} =_{微分} \lim_{n\rightarrow\infty}\frac{(\frac{\ln 4n}{\ln3})&#39;}{(\frac{\ln 3n}{\ln 4})&#39;}\) \(\Rightarrow lim_{n \rightarrow \infty} \frac{ \frac{4}{4n\ln3} }{\frac{3}{3n\ln4}} \Rightarrow \frac{\ln4}{\ln3}\) 為常數，所以 \(f(n) = \Theta ,\Omega , O (g(n))\)。 Ex ( 96 成大資工 ) (10%) True or false \(n^b = o(a^n)\), 其中 \(a &gt; 1, b \in \mathbb{R}\) true，\(\lim_{n\rightarrow \infty} \frac{n^b}{a^n} =_{兩邊取微分} \lim_{n\rightarrow \infty} \frac{b \times n^{b-1}}{\ln a\times a^n} = \ldots = \lim_{n\rightarrow\infty} \frac{b!}{(\ln a)^n\times a^n} = 0\) 所以正確。 Ex ( 98 台大電機 ) true or false 對任何正數 a, b 而言 \(n^b = o(a^n)\) 。 False，陷阱！因為題目只有說 a, b 為正數而非正整數，所以當 a 為分數時，此命題錯誤。 對數法 適用時機 題目分數少的計算題。 函數為指數函數型態。 函數為階乘型態。(\(\log n! = \Theta(n\log n)\)) 定義 \(\log(f(n)) = o, \omega(\log(g(n))) \Rightarrow f(n) = o, \omega (g(n))\) 而 \(\log(f(n)) = \Theta(\log(g(n)))\) 則無法判斷等級，因為等級過於相同，取對數後無法判斷，要使用別的方法。 Ex 比較 \(f(n) = 1.1^{0.01n}, g(n) = n^{100}\) 的等級。 \(\log(f) = 0.01n \times log 1.1, log(g) = 100 \times log n \Rightarrow \lim_{n\rightarrow\infty}\frac{\log(f)}{\log(g)} = \infty\)，所以 \(f(n) = \omega(g(n))\)。 Ex (98 交大) Prove：(log n)! 不是 Polyniminally bounded ( = O(\(n^k\)))。 ＜分析＞ 若 f(n) 是 Polyniminally bounded，則 \(\exists k \in R \ni f(n) = O(n^k)\)；\(\log f = O(\log n^k) = O(\log n)\) ，若為 Polyniminally bounded 則等級小於 log n。 \(\log((\log n)!) = \Theta(\log n (\log\log n))\) 其等級大於 log n 也就是 \(\log(\log n)! = \omega(\log n)\)，Q.E.D.。 複雜度計算 \(\Theta\) 集合的求取 Close form 的求取 Close form 最高次項即為其 Tight bound。 \(T(n) = 1 + ...+n = \frac{n(1+n)}{2} = \frac{n^2+n}{2} = \Theta(n^2)\) 並不是所有函數都有 close form。 使用 Upper bound 與 Lower bound 的夾擊 若 \(f(n) = O, \Omega (g(n))\) 同時成立，稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic tight bound。 Ex \(T(n) = \sum_{i=1}^n i^5 = \Theta(n^a)\)，求 a = ？ 先證明 \(T(n) = \sum_{i=1}^n i^5 = O(n^6)\)、再證明\(T(n) = \sum_{i=1}^n i^5 = \Omega(n^a)\) 即可。 調和級數( \(\mathbb{H}_n = 1 + \frac{1}{2} + \frac{1}{3} + ... +\frac{1}{n}= \Theta(\lg n)\) )必須使用夾擊法，因為調和級數沒有 Close form。 \(\because \mathbb{H}_n - 1 = \sum_{i = 1}^n \frac{1}{i} - 1 \leq \int_1^n \frac{1}{n} dx = (\lg n - \lg 1) = \lg n\) \(\therefore \mathbb{H}_n \leq \ln n + 1 \leq 2 \times \ln n \Rightarrow \exists C = 2, n_0 \geq 3 \ni n \geq n_0 , \mathbb{H}_n \leq C \times \lg n \Rightarrow \mathbb{H}_n = O(\lg n)\) \(\because \mathbb{H}_n = \sum_{i = 1}^n \frac{1}{n} \geq \int_1^n \frac{1}{n} dx = \ln n\) \(\therefore \mathbb{H}_n \geq \ln n \Rightarrow \exists C = 1, n_0 \geq 1 \ni n \geq n_0 , \mathbb{H}_n \geq C \times \lg n \Rightarrow \mathbb{H}_n = \Omega(\lg n)\) \(\Rightarrow \mathbb{H}_n = \Theta(\lg n)\) ＜Note＞ 收斂(Converge)的級數 \(T(n) = 1^a + \frac{1}{2^a} + \frac{1}{3^a} + \ldots = \sum_{i = 1}^n \frac{1}{i^a} = \frac{\pi^2}{6}, for\; some\; a = 2, 3 ...\) \(\Rightarrow T(n) = \Theta(1)\) 複變分析證明 \(\log n! = \Theta(n\lg n)\) 證明： Prove \(\log(n!) = O(n\lg n)\) \(\log n! = \log ( \Pi_{i = 1}^n i ) = \sum_{i = 1}^n \log i \leq \sum_{i = 1}^n \log n = n \log n\) \(\therefore \exists C = 1, n_0 = 1 \ni n\geq n_0, \log n \leq n \log n \Rightarrow \log n! = O(n\lg n)\) Prove \(\log(n!) = \Omega(n\lg n)\) ( 離散筆記本 P.118 ) \(\log n! = \log ( \Pi_{i = 1}^n i ) = \sum_{i = 1}^n \log i \geq \sum_{i = 1}^{ceil(\frac{n}{2})} \log ceil( \frac{n}{2}) \geq \frac{n}{2} \log \frac{n}{2} = \frac{n}{2} (\log n - \log 2)\approx \frac{1}{2}n\log n\) \(\therefore \exists C = \frac{1}{2}, n_0 = 1 \ni n\geq n_0, \log n \geq \frac{1}{2}n \log n \Rightarrow \log n! = \Omega(n\lg n)\) \(\therefore \log n! = \Theta(n\lg n)\) Ex (96 台大資工) \(T(n) = \sum_{k = 1}^n k^2(\log k)^3 = \Theta(n^d(\log n)^e)\)，d = ？、e = ？ ＜想法＞：拆開 \(1^2(\log 1)^3 + 2^2(\log 2)^3 + ... +n^2(\log n)^3 \Rightarrow_{\leq} 1^2(\log n)^3 + 2^2(\log n)^3 + ... +n^2(\log n)^3\) 提出 \((\log n)^3 \times \sum_{i = 1}^n i^2 = O(n^3(\log n)^3)\) 所以 d = 3, e = 3。 \((\log_an)^b = o(n^k), k &gt; 0\) Ex：\((\lg n)^{100} = o(n^{0.0000001})\) Ex (96 輔大資工) Prove \((\log n)^3 = O(n^\frac{1}{16})\) (函數型態複雜不適合使用定義證明，這裡採取極值法) \(\lim_{n\rightarrow\infty} \frac{(\log n)^3}{n^{\frac{1}{16}}} =_{同取微分} \lim_{n\rightarrow\infty} \frac{\frac{3}{n (\ln 10)^3}\cdot (\ln n)^2}{\frac{1}{16}\cdot n^{\frac{-15}{16}}} =_{整理} Constant\cdot \lim_{n\rightarrow\infty}\frac{(\ln n)^2}{n^{\frac{1}{16}}} =\ldots\) \(\Rightarrow_{趨近於, n \rightarrow \infty} 0\)\(\Rightarrow (\log n)^3 = o(n^\frac{1}{16}) \Rightarrow_{?} (\log n)^3 = O(n^\frac{1}{16})\) Ex 比較 \(n^{1 + \epsilon}\) 與 \(\frac{n^2}{\log n}\) 的等級，其中 \(0&lt;\epsilon &lt; 1\)。 ＜猜測＞：後者。 ＜分析＞：\(n^{1+\epsilon} = n^{2-\delta}, 0&lt;\delta&lt;1 \Rightarrow \frac{n^2}{n^\delta}\)$n = o(n^) $ \(\therefore n^{1 + \epsilon} = O(\frac{n^2}{\log n})\)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time Complexity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Synchronization 2]]></title>
    <url>%2Fwillywangkaa%2F2018%2F08%2F04%2FOperating-System-Process-Synchronization-2%2F</url>
    <content type="text"><![CDATA[Process Synchronization ( Process Communication, Inter Process Communication ) Race Condition Problem in Memory Communication thesolutionofracecondition Monitor thestructofmonitor monitor 是一個用來解決同步問題的高階「資料結構」，是一種 ADT ( Abstract data type )。 組成架構 共享變數宣告區 一組 local funtions or procedures 初始區 ( Initialization area ) 語法架構 12345678910111213141516type Monitor-Name = Monitorvar 共享變數宣告procedure entry fun1-Name begin BODY; end ...procedure entry fun2-Name begin BODY; end begin 初始區end Pros Monitor 本身已保證互斥( mutual exclusive )，即「任和時間點，最多只允許 1 個 Process 在 Monitor 內進行活動 ( active )」：在任何時間點，最多只允許 1 個 Process 呼叫 ( calling ) Monitor 的某一個 function or procedure 執行，不可有多個 processes 同時呼叫 Monitor 的 funciton 執行。 上述的互斥性質，是將「共享變數區的共享變數」設成只能以 Monitor 的 local function 存取，而不能直接從 Process 直接存取，而 Monitor 保障互斥，所以也會不會造成「Race condition」，完全無需再在意額外的演算法以防止 Race condition，只需專心解決同步問題即可( 在這一點比起 semaphore 好用很多，因為 semaphore 並不會保證 mutex 存取變數還須要演算法以輔助之 )。 Ex. 當我們在解決同步問題時，Semaphore 比起 Monitor 容易使用？ False。 Condition ( 資料型別 ) Condition 型別是用在 Monitor 中，提供給開發者解決同步問題之用。 Operatior：令 \(x\) 為一 Condition type 變數。 wait ( x.wait )：因為某些同步條件而被卡住時，執行此運作的該 Process 會 Blocked，並且置入 Monitor 內該資料變數的所屬之等待佇列( Waiting Queue：預設為 FIFO ) signal ( x.signal )：如果先前有 Processes 卡在該變數 ( x ) 的「Waiting queue」中，則此運作會自此「Waiting queue」移走一個 Process 並且恢復 ( Resume ) 其執行，否則無任何作用。 解決 Dining-philosophers Problem 先定義所需的 Monitor ADT。type Dining-ph = Monitorvar state：[0…4] of ｛ think, hungry, eating ｝。 self：[0…4] of condition 12345procedure entry pickup(i:0...4) state[i] = hungry test(i); if(state[i] != eating) then self[i].wait // 繼續餓著，將該 Process blocked 1234567procedure test(k:0...4) if(state[(k+4)%5]!= eating &amp;&amp; // 左邊哲學家沒吃飯 state[k] == hungry &amp;&amp; // 由於 putdown 會要讓左右邊的哲學家是否要吃飯，所以必須存在 state[(k+1)%5] != eating // 右邊哲學家沒吃飯 ) then state[k] = eating // 改為正在吃飯 self[k].signal // *將自己喚醒 ＜Note＞： state[...]!= eating 為何是測試「是否正在吃飯而不是測試是否飢餓」？因為能呼叫到目前的函式代表該 Process 是正在進行的 ( Active )。 1234procedure entry putdown(i:0...4) state[i] = thinking test((i+4)%5) // 給左右邊哲學家機會使用 test((i+1)%5) 123init() for(i = 0; i &lt; 4; i++) state[i] = thinking 使用方式 共享變數宣告： dp：Dining-ph 12345678// P_i repeat // hungry dp.pickup(i); // active in monitor // eating dp.putdowm(i); // active in monitor // thinking until false Conditional Monitor Condition 變數所屬的 Waiting queue 一般皆是 FIFO queue ( 甚至 Monitor 的 entry queue 也是 FIFO )，可是有時候我們會需要「Priority queue」優先移除高優先權的 Process ，恢復執行或讓他進入 Monitor 內進行活動，此時我們就會需要 Conditional monitor。 Operatior：令 \(x\) 為一 Condition type 變數。 wait ( x.wait(c) )：c 為此 Process 的 Priority number。 解決互斥問題之應用 互斥資源配置問題 Process ID 越小者優先權越高可以優先取得資源。 定義 Monitortype ResourceAllocator = Monitorvar busy：boolean // 代表資源已經配置與否var x：condition // 用以將 Process blocked 想法 \(\left\{\begin{matrix} 非優先權需求 \Rightarrow 寫入\; Monitor \; 的函式定義中處理。 \\ 優先權需求 \Rightarrow 只須告知閱卷人你的\; Monitor \; 是以 \;Priority \; queue\; 實現的。 \end{matrix}\right.\) \(此題之分析\left\{\begin{matrix} 非優先權需求 \Rightarrow 互斥資源配置。\\ 優先權需求 \Rightarrow Process \;ID \;之優先權。 \end{matrix}\right.\) 12345procedure entry Apply(pid:int) if(Busy) then x.wait(pid) else Busy = true 123procedure entry Release() Busy = false x.signal 12init() Busy = false 使用方式 共享變數 RA：ResourceAllocator Pi ( i 代表 ProcessID ) 123456// P_i ... RA.Apply(i) // 使用資源 RA.Release() ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 共享檔案問題 有一個「檔案」可以被多個 Processes 所使用，每一個 Process 有唯一的優先權值( Unique priority number )，存取檔案時必須要： 1. 所有正在存取此檔案的 Process 的優先權值加總必須 \(&lt; n\)。 2. 優先權值小的優先權越高。 定義 Monitortype FileAccess = Monitorvar sum：int\(x\)：condition 123procedure entry Access(i:priorityNum) while((sum+i) &gt;= h) do x.wait(i) // !! sum += i 123procedure entry Leave(i:priorityNum) sum -= i x.signal() 12init() sum = 0 使用方式 共享變數 FA：FileAccess Pi ( i：process priority number ) 程式 123456// P_i ... FA.Access(i) // 使用檔案 FA.Leave(i) ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 印表機使用權問題 (P.6-72) 有三部 Printer 被 processes 使用且規定 process ID 越小優先權越高。 定義 Monitortype Allocator = Monitorvar p：[0…2] of booleanx：condition 12345678910111213int Acquire(i:processID) if(p[0] &amp;&amp; p[1] &amp;&amp; p[2]) x.wait(i) if(!p[0]) tmp = 1 else if(!p[1]) tmp = 1 else tmp = 2 p[tmp] = true return tmp 123void Release(y:printerNum) p[y] = false x.signal() 123init() for(i = 0; i &lt; 2; i++) p[i] = false 使用方式 共享變數 RA：Allocator Pi (i = Process ID) 1234567// P_i ... pno: printer number pno = PA.Acquire(i) // 使用編號 pno 的印表機 PA.Release(pno) ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 使用 Monitor 定義 Semaphore？ 定義 Monitor type semaphore = Monitorvar value：int // 號誌值\(x\)：condition 123procedure entry wait() value-- if(value &lt; 0) then x.wait() 123procedure entry signal() value++ x.signal() 12init() value = 1 Monitor 的種類 ( 3種 ) 探討 假設 Process Q 目前因為先前有執行了 x.wait ，所以卡在 x condition 變數之 Waiting queue 中，接著，目前的 Process P 在 Monitor 中進行活動，當 P 執行了 x.signal 後，P 會將 Q 從 Waiting queue 中恢復 ( Resume ) 執行，此時代表 P 與 Q 同時在 Monitor 中進行活動( Active )，但是如此一來會違反 Mutual exclusive，因此我們要抉擇 讓 P 或 Q 其中一個能夠在 Monitor 中活動。 thetypeofmonitor Type 1 - Hoare Monitor ( 效果最好 ) P waits Q until Q completed function or Q is blocked again. Pros 保證 Q 一定可以被恢復執行 ( Resume execution )。 在不會退出 Monitor 的情況下可以恢復比較多的 Processes ，但是是效果其實與 Type3 的相去不遠。 Type 2 ( 效果最差 ) Q waits P until P completed function or P is blocked. Cons 不保證 Q 一定可以被恢復執行，因為允許 P 繼續往下執行的過程中，P 有可能改變可能讓 Q 可以恢復行為的同步條件值，使得 Q 仍被卡住。 Type 3 P leaves monitor ( 將 P 重新插在 Monitor entry queue 的第一個 ) and let Q resume execution 直到 Q finished or Q is blocked again, then P reenter Monitor. Consurrent C / Consurrent PASCAL 所採用。 Pros 保證 Q 一定可以被立刻恢復執行( Resume execution )。 Cons 效果不若 Type1 Monitor，因為在 P 一進一出的期間，頂多只能恢復一個 Q，然而 Type1 可以一次恢復多個 Q。 目前的分類 ( 2種 ) Signal-and-wait Type1 Hoare Monitor Type3 Monitor Signal-and-continue Type2 Monitor 實作 Monitor 使用 Semaphore 。 架構 保證「互斥」：最多只能有一個 Process 在 Monitor 中進行活動。 「Hoare」的設計手法。 Condition 變數 \(x\) ：x.wait()、x.signal。 共享變數 mutex：semaphore = 1 ( 用以保障函式使用的「互斥控制」) next：semaphore = 0 ( 若 P 執行 x.signal，則用來 block P ) next_count：int = 0 ( 統計 P 的個數 ) x_sem：semaphore = 0 ( 當 Q 執行 x.wait() ，則用以 block Q ) x_count：int = 0 ( 統計 Q 的個數 ) 控制碼 - 確保互斥：在 Monitor 的每個函式的「body」之前及後加入一些額外的控制碼。 123456789procedure entry _monitorfunction() wait(mutex) // body if(next_count &gt; 0) // 若 P 存在，必先讓 P 恢復執行 signal(next) else // 若沒有 P 在等待，才讓下一個 Q 進入執行 signal(mutex) 控制碼 - 「\(x\).wait()」： 12345678// x.wait x_count++ // Q 的個數加一 if(next_count &gt; 0) // 將要 blocked 前的準備動作(與上述程式碼相同) signal(next) else signal(mutex) wait(x_sem) // Q 將自己 block x_count-- // 當 Q resume 後，將 x_count 減一 控制碼 - 「\(x\).signal()」： 123456// x.signal if(x_count &gt; 0) // 先前若有 Q blocked 才有作用 next_count++ signal(x_sem) // resume Q wait(next) next_count-- 問題與討論 證明 Monitor 與 Semaphore 解決同步問題的能力是一樣的( idemtical; equivalent )。 由於 Monitor 與 semaphore 可以「相互實作」，所以兩者解決「同步問題」的能力是相同的。 當開發者在解決同步問題時，Monitor 的使用會比起 Semaphore 容易，因為 Monitor 本身已經保證「互斥」，所以 condition variable 不會有「race condition」的問題，所以只要專心解決「同步問題」即可，但是當開發者要使用 Semaphore 解決同步問題時還需要關心「Race condition」與「同步條件」的滿足。 Message Passing Direct ( symmtric ) communication Indirect communication 收、送雙方須相互指名對方 ID，才能建立通訊鏈結。 雙方透過「Shared mailbox」才能建立通訊鏈結。 通訊鏈結是專屬於溝通的雙方，不得與其他 Processes 共享。下圖(一) 可以多 Processes 一起共享。下圖(二) 溝通雙方最多只能一條通訊鏈結(禁止多條通訊鏈結)。下圖(三) 溝通雙方可以同時存在多條通訊鏈結，每一條皆須有「Shared mailbox」。下圖(四) thetypeofmessagepassing 直接通訊 ( Direct Communication ) Symmetric 雙方須「互相指名」對方的 Process ID ，才能建立通訊鏈結 ( Communication link )，OS 提供 send()、receive() 的 System call。 1234// P_1 ... sent(P_2_ID, message) ... 1234// P_2 ... receive(P_1_ID, message) ... Asummetric 只有「送出的 Process」需要指名「收受的 Process 之 ID」，但收受方無須指名送方，即任何 Process 皆可以收下這則訊息。 1234// P_1 ... send(P_2_ID, message) ... 1234// P_2 ... receive(id, message) ... 當 P_2 收到訊息後，會將「送出訊息的 Process」之 ID 存在id變數之中。 間接通訊 ( Indirect Communication ) 收、送雙方是透過「Shared mailbox」，才能建立通訊鏈結。 1234// P_1 ... send(A, message) ... 1234// P_2 ... receive(A, message) ... 用 Message Passing 解決 Producer-comsumer Problem Producer 123456// Producer while(condition != false) &#123; produce an item in next_tp; send(Consumer, next_tp); ... &#125; Comsumer 123456// Consumer while(condition != false) &#123; receive(Producer, next_tp); Consumer the item in next_tp ... &#125; 「同步」意義之呈現 Link capacity 假設「收受的 Process」是以：若未收到訊息則暫停執行，直到收到訊息後才往下執行；而對於「傳送的 Process」看待 Link capacity 時，其實針對每條傳輸鏈結裡的「Message queue」( 用以保存「除了正在傳輸中的訊息以外之其他 送方 訊息」)之容量。 linkcapacity ★ Zero capacity 送方直到收方收到訊息後才能繼續往下執行，此時雙方的同步模式也稱為「Rendezvous」( 法文：約會一次；偶遇 ) 12345// P_1 ... send(P_2_ID, message) receive(P_2_ID, "Acknowledge") ... 12345// P_2 ... receiver(P_1_ID, message) sned(P_1_ID, "Acknowledge") ... Bounded capacity 當 Queue 滿了之後，送方會被迫暫停執行。 Unbounded capacity 送方無須被迫暫停執行。 4 條指令之組合來表現不同之「同步模式」 Blocking send 送出訊息後直到收方收到訊息後才繼續往下執行。(Like zero capacity) Nonblocking send 送出訊息後無須收方確認收到訊息即可繼續往下執行。(Like unbounded capacity) Blocking receive 一定要收到訊息才能繼續往下執行。 Nonblocking receive 不一定要確認訊息的正確性亦能繼續向下執行。 問題與討論 Ex1.「Rendezvous」模式 1234// P_1 ... Blocking_send(P_2_ID, message) ... 1234// P_2 ... Blocking_receive(P_1_ID, message) ... Ex2. 假設收方的程式如下，則代表著甚麼含意： 12345678910... Nonblocking_receive(A, message) if(message == null) &#123; Blocking_receive(B, message) Blocking_receive(A, message) &#125; else &#123; Blocking_receive(B, message) &#125;... 選項： 從 A 或 B 收到訊息後，即可往下。 一定要從 A 與 B 收到訊息後且要先 A 後 B，才可以繼續往下執行。 同上，但 A、B 順序無所謂。 Ans： (3) Exception handling 在「Rendezvous」模式之下，若收或送任一方的 Process 以死亡( terminate )，但另一方不知情時，則另一方會永久停滯 ( Starvation、Deadlock )：作業系統會以「Exception」的方式刪除另一個 Process。 1234// P_1 ... Blocking_send(P_2_ID, message) ... 1234// P_2 ... Blocking_receive(P_1_ID, message) ... 在直接通訊 ( Direct symmtric communication )下，若「未通報其他 Process 自己的 ID」且 「New Process 也不知道他人 Process 的 ID」，則無法溝通。 訊息的傳輸過程之中，有可能會丟失訊息( Lost message ) ，作業系統負責偵測訊息是否已丟失，若丟失訊息時，作業系統會通知「送方」重送訊息，偵測丟失訊息的方法類似於「網路概論」中談到的封包丟失偵測有關 ( Time-out 法則 )。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Synchronization 1]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Process-Synchronization%2F</url>
    <content type="text"><![CDATA[Process Synchronization ( Process Communication, Inter Process Communication ) Synchronization Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。 Process Communication Shared memory 1530175318032 Process 透過對共享變數 ( Shared variables ) 之存 ( Write )、取 ( Read )，達到構通 ( Infomation exchange ) 的目的。 分析 適用於大量資料( Data, Message )傳輸的狀況。 因為不須 Kernel 的介入干涉，因此傳輸速度較快。 不適用在分散式系統( distributed system )。 Kernel 不須提供額外的支援( 最多就只供應共享的記憶體空間 Shared memory space )，而所有的控制都交付給 Programmer 自行負擔，必須撰寫額外的控制碼防止 Race condition 發生。 Message passing Process 雙方要溝通必須要遵循以下步驟 建立 Communication link。 訊息可雙向傳輸。 傳輸完畢，釋放 Communication link。 分析 適用於少量資料( Data, Message )傳輸的狀況。 因為須要 Kernel 的介入干涉，因此傳輸速度較慢。 適用在分散式系統( Distributed system )。 Kernel 必須提供額外的支援( 如：System call of send/receive, Management of communication link, Detection of message lost, 例外狀況的處理 )，而所有的通訊控制都交付給作業系統。 Race Condition Problem in Memory Communication 在利用共享記憶體作為通訊橋梁時，若未對共享變數存取提供任何互斥存取控制之同步( Synchronization )機制，會因為 Processes 之間的交錯執行而導致前後順序不同，進而造成共享變數的最終結果有所不同，這種資料不一致( Data inconsistency )的情型，稱為 Race condition。 \(Ex .\) C 為共享變數且初值為 5。 兩個 Processes \(P_i, P_j\)，分別程式碼如下。 1234//P_i...C = C + 1;... 1234//P_j...C = C - 1;... \(P_i, P_j\) 個執行一次則 C 的最終值可能是 5 或 4 或 6。 正常結束( No race condition ) ：5 123// processing flowc = c + 1 // P_ic = c - 1 // P_j 123//processing flowc = c - 1 // P_jc = c + 1 // P_i Race condition：4 12345678910111213// assembly processing flow// P_iload c; // c == 5// P_jload c; // c == 5// P_iprocess c = c + 1; // c == 6// P_jprocess c = c - 1; // c == 4// P_irestore to c; // c == 6// P_jrestore to c; // c == 4 Race condition：6 12345678910111213// assembly processing flow// P_iload c; // c == 5// P_jload c; // c == 5// P_iprocess c = c + 1; // c == 6// P_jprocess c = c - 1; // c == 4// P_jrestore to c; // c == 4// P_irestore to c; // c == 6 \(Ex 1.\) x、y 是共享變數，初值各別為 5, 7 ，有兩個 process \(P_i, P_j\) 分別程式碼如下。 1234//P_i...x = x + y;... 1234//P_j...y = x * y;... \(P_i, P_j\) 各作一次，求 (x, y) 可能的值？ (12, 84) 123// processing flowx = x + y;y = x * y; (40, 35) 123// processing flowy = x * y;x = x + y; ★ (12, 35) 1234567891011// assembly processing flow// P_1load x, y; // x = 5, y = 7// P_2load x, y; // x = 5, y = 7// P_1process x = x + y;restore to x;// P_2process y = x * y;restore to y; \(Ex 2.\) x 是共享變數初值等於零 ， i 為區域變數，另外有兩個 process \(P_i, P_j\) 分別程式碼如下。 12345//P_i...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... 12345//P_j...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... \(P_i, P_j\) 各作一次，求 x 可能的值( 可能的最小值、可能的最大值 )？ 先拆解 for loop 1234// P_ix = x + 1;x = x + 1;x = x + 1; 1234// P_jx = x + 1;x = x + 1;x = x + 1; 分析若為最小值的狀況：3。 123456789101112131415161718192021222324252627282930313233// assembly processing flow// P_iload x; // x = 0// P_jload x; // x = 0// P_ix = x + 1;restore x; // x = 1// P_jx = x + 1;restore x; // x = 1// P_iload x; // x = 1// P_jload x; // x = 1// P_ix = x + 1;restore x; // x = 2// P_jx = x + 1;restore x; // x = 2// P_iload x; // x = 2// P_jload x; // x = 2// P_ix = x + 1;restore x; // x = 3// P_jx = x + 1;restore x; // x = 3 正常結束：6 所以 x 的值會介於在 3 ～ 6 之間，都是有可能會出現的狀況。 \(Ex 3.\) x 是共享變數初值等於零 ， i 為區域變數，另外有兩個 process \(P_i, P_j\) 分別程式碼如下。 12345//P_i...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... 12345//P_j...for( int i = 1; i &lt;= 3; i++ ) x = x - 1;... \(P_i, P_j\) 各作一次，求 x 可能的值( 可能的最小值、可能的最大值 )？ 先拆解 for loop 1234// P_ix = x + 1;x = x + 1;x = x + 1; 1234// P_jx = x - 1;x = x - 1;x = x - 1; 分析若為最小值的狀況：-3。 123456789101112131415161718192021222324252627282930313233// assembly processing flow// P_iload x; // x = 0// P_jload x; // x = 0// P_ix = x + 1;restore x; // x = 1// P_jx = x - 1;restore x; // x = -1// P_iload x; // x = -1// P_jload x; // x = -1// P_ix = x + 1;restore x; // x = 0// P_jx = x - 1;restore x; // x = -2// P_iload x; // x = -2// P_jload x; // x = -2// P_ix = x + 1;restore x; // x = -1// P_jx = x + 1;restore x; // x = -3 最大值的狀況：3。 解決 Race Condition Disable inrerrput ( 針對CPU ) Process 在對共享變數存取之前，先 Disable interrupt，等到完成共享變數的存取後，才 Enable interrupt，如此一來可以保證 Process 在存取共享變數的期間 CPU 不會被搶走( Preempted )，所以這種存取的方法稱為「Atomically executed (不可分割之執行)」，所以可以防止 Race condition。 \(Ex.\) 123456//P_i...disable interruptC = C + 1;enable interrupt... 123456//P_j...disable interruptC = C - 1;enable interrupt... Pros Simple, easy to implementation 適用於 Uniprocessor system。(單一CPU) Cons 不適合用在 Multiprocessors system 中。因為只 Disable 一顆 CPU 的 Interrupt 功能無法防止 race condition ( 其他的 CPUs 上執行之 Processes 仍可以存取該共享變數 )；但若 Disable 所有 CPU 的 Interrupt 功能，雖然可以防止 Race condition，但是會導致 Multiprocessor 的效能低落( low performance，因為無法「平行執行」 )變得和 Single-processor 的環境差不多。 風險很高：因為 Disable interrupt 指應為特權指令(風險高，可能阻擋 Kernel 的插斷)，所以必須信任使用者程式在 Disable interrupt 後，在短時間內會再 Enable interrupt ，不然 CPU 從此再也不會回到 Kernel 管理的狀態 ( 高風險!! )。 ＜Note＞通常「 Disable interrupt 解決方法」不會下放給 User process，通常只存在於作業系統 Kernel 的實踐之中。( 只有作業系統開發者可以使用 ) 1530176275538 Critical section design( 針對共享資料製作臨界區塊 ) 針對「共享變數」的存取進行管制，當 P_i 取得共享變數存取管制，在該 Process 尚未完成之期間，任何其餘 Processes 即便已取得 CPU 的使用權之下，仍無法存取共享變數。 1530176581925 Critical section Process 中對於共享變數進行存取的敘述集合。 Remainder section Process 中除了 C. S. 之外的區間統稱為 Remainder section。 1234567891011// Processrepeat entery section critical section exit section remainder section until falseS Critical section 的主要設計，是設計每個 Critical section 的前後 Programmer 需增加的控制碼( Entery section、Exit section )。 12345678910//P_i...// Enter section...C = C + 1;...// Exit section// Remainder section... 12345678910//P_j...// Enter section...C = C - 1;...// Exit section// Remainder section... Critical Section ( Spinlock, Busy-wiating ) VS. Disable interrupt Critical Section (Pros) 適用於多處理器系統( Multiprocessor system )。 Critical Section (Cons) 設計較為複雜。 較不適合用在單處理器系統( Uniprocessor system )。 Busy waiting ( Spinlock ) 技巧 透過使用迴圈相關敘述達到讓 Process 暫時等待該共享變數。 Cons 在 Spinlock 等待中的 Porcess 會與其他 Processes 競爭 CPU ，將得到的 CPU time 用在於空轉( spinlock )中，因此若 Process 要等待很長的時間才能離開迴圈，則這種技巧非常浪費 CPU time。 Pros 若 Process 在迴圈等待的時間短( 小於「Context switching time」 )，則 Spinlock 非常有用。 1531041864596 ( 恐龍課本 )謬誤：因為 Critical Section 設計當中，「Entery section」中經常使用 Busy-waiting ( spinlock ) 技巧，而課本將 Busy-waiting ( Spinlock ) 與 Critical Section 視為相同，進而與 Disable interrupt 比較( 應是 Busy waiting 與 Non-busy waiting 來比較 )。 Non-busy waiting 技巧 當 Process 因為同步事件( Synchronization event )被長時間卡住，則可以使用 Block system call 將該 Process 送入 Blocked state，所以不會與其他 Process 競爭 CPU ，直到該事件觸動了，才會喚醒(wake up system call) 該 Process 移至 Ready state。 Pros 等待中的 Process 不會與其他 Process 不會浪費 CPU time。 Cons 需額外付出「Context switching time」。 Critical Section Design 關鍵性質 Mutual exclution：在任何時間點最多只允許一個 Process 進入它的 C.S. ，不可以有多個 Processes 分別進入各自的 C.S.。 *Progress：不想進入 C.S. 的 Process ( 在 R.S. 中活動的 Process )，不可阻礙( 不參與「 進入C.S.」的決策 )其他 Processes 進入 C.S.。「安排欲進入 C.S 的 Process」之決策，要在有限的時間中完成 ( Non-deadlock：不可以無窮等待，使得全部之 Process 皆無法進入 C.S. )。—全部 Process 都無法進入 Bounded waiting：當有 Process 提出「進入 C.S.」之申請，等待核准的時間是有限的( 防止該 Process 出現 Starvation 的情形 )。—單一 Process 一直無法進入若有 n 個 Process 欲進入 C.S. 則每個 Process 最多等待 n-1 次後即可進入 C.S.。 著重於 高階( 位於函式庫中 ) Monitor 同步問題之解決 中階( 通常於 System call ) Semaphore 同步問題之解決 基礎建設( 作業系統核心製作 ) Software solutions、Hardware instrustions support C.S. 設計的正確與否 Disable interrupt 也在基礎建設 Software Solutions 兩個 Processes 之 critical section design 有兩個 Process \(P_i, P_j\)。 Algorithm 1 ( Fall )：權力層面 共享變數：Turn：int，值恰為 i 或是 j 值。 視為一種權力的象徵，當 turn 值為 i 時 \(P_i\) 始得 進入 C.S. 的權力，且只能讓 \(P_i\) 下一個進入 C.S. ，反之亦然。 1234567// P_iRepeat while ( turn != i ); // enter C.S. turn = j; // leave R.S.Until False 1234567// P_jRepeat while ( turn != j ); //enter C.S. turn = i; //leave R.S.Until False ＜分析＞： Mutual exclution ( OK ) ：因為 turn 值不會同時為 i 且為 j ，只會為 i 或 j 之其中一個值，所以只有 \(P_i\) 或 \(P_j\) 一個可進入 C.S. 而不會兩個同時進入。 Progress ( FALL ) ：假設目前 \(P_i\) 在 R.S. ( 且 \(P_i\) 不想進入 C.S. )，而目前的 turn = i 且 \(P_j\) 欲進入 C.S，但是因為 \(P_i\) 仍在 R.S. 無法交付 turn ，所以被 \(P_i\) 阻礙進入。 Bounded waiting ( OK ) ：證明 \(P_i\) 無法連續兩次進入 C.S 之中。假設目前 turn = i，且\(P_i\) 已先早於 \(P_j\) 進入 C.S. 使 \(P_j\) 開始等待，若 \(P_i\) 離開後又想立刻想再次進入，但因為 \(P_i\) 離開時會將 turn = j，使得 \(P_i\) 無法再度比 \(P_j\) 早進入 C.S.，這一次 \(P_j\) 必定先進入之 ，所以 \(P_j\) 最多等一次後即可進入。 Algorithm 2 ( Fall )：意願層面 共享變數：flag[ i … j ] of Boolean。( 初值皆為 False ) \(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\) 1234567// P_iRepeat flag[i] = true; // 表達意願 while (flag[j]); // enter C.S. flag[i] = false; // leaveUntil false 1234567// P_jRepeat flag[j] = true; // 表達意願 while (flag[i]); // enter C.S. flag[i] = false; // leaveUntil false ＜Note＞ Progress ( 造成死結 -&gt; Fall ) Mutual exclusion ( OK ) Bounded waiting ( OK ) 12345flag[i] = true; // P_i 表達意願flag[j] = true; // P_j表達意願 while (flag[j]); // P_i can't enter while (flag[j]); // P_j can't enter... // Progress fall ( Deadlock ) Algorithm 3 - Peterson’s Algorithm ( OK )：權力、意願層面 共享變數：flag[ i … j ] of Boolean。( 初值皆為 False ) \(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\) 共享變數：Turn：int，值恰為 i 或是 j 值。 12345678910// P_iRepeat flag[i] = true; // 表達意願 turn = j; // * enter ( 權力先給對方 ) while ( flag[j] &amp;&amp; turn == j ); // enter// turn = i; // enter C.S.// turn = j; // enter ( fall ) flag[i] = false; // leaveUntil false 12345678910// P_jRepeat flag[j] = true; // 表達意願 turn = i; // *enter while ( flag[i] &amp;&amp; turn == i ); // enter// turn = i; // enter C.S.// turn = j; // enter ( fall ) flag[j] = false; // leaveUntil false Mutual exclusion (OK)：若 \(P_i, P_j\) 皆欲進入 C.S. 代表 flag[i] 與 flag[j] 皆為 True，當雙方皆作到while測試的時候，代表雙方已分別執行過 turn = i 以及 turn = j 的設定，差異點在於可能會交錯執行，但是 turn 必為兩值之其中一者，所以只有P_i, P_j 一個可以進入 C.S。 Progress (OK)： 假設 turn 值目前為 i ，且 P_i 不想進入 C.S.，帶表 flag[i] = false 若此時 P_j 欲進入 C.S. ，則 P_j 必可通過 while 的關卡進入 C.S. ，所以P_i 不會阻礙 P_j 進入 C.S.。 若 P_i, P_j 皆欲進入 C.S 則在有限的時間內必可決定出 turn 值為 i 或為 j 使得 P_i, P_j 可以進入，兩者不會永遠互相等待造成死結。 Bound waiting (OK)：假設 turn 為 i ， P_i 已早於 P_j 進入 C.S. 而 P_j 等待進入中，所以 flag[i] = flag[j] = true，若 P_i 離開 C.S. 後，又想再進入 C.S. ，則 P_i 必定會將 flag[i]=false turn = j ，使得 P_i 無法再度先早於 P_j 進入 C.S. ，一定是 P_j 進入 C.S. ，所以 P_j 至多等待一次後即可進入 C.S.。 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？可以正確執行，只是 flag 互相對調而已。 12345678// P_iRepeat flag[j] = true; // 表達意願 turn = j; // * enter ( 權力先給對方 ) while ( flag[i] &amp;&amp; turn == j ); // enter C.S. flag[j] = false; // leaveUntil false 12345678// P_jRepeat flag[i] = true; // 表達意願 turn = i; // *enter while ( flag[j] &amp;&amp; turn == i ); // enter C.S. flag[i] = false; // leaveUntil false 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？可以正確執行，只是 turn 互相對調而已。 12345678// P_iRepeat flag[i] = true; // 表達意願 turn = i; // * enter ( 權力先給對方 ) while ( flag[j] &amp;&amp; turn == i ); // enter C.S. flag[i] = false; // leaveUntil false 12345678// P_jRepeat flag[j] = true; // 表達意願 turn = j; // *enter while ( flag[i] &amp;&amp; turn == j ); // enter C.S. flag[j] = false; // leaveUntil false 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？可以正確執行，只是 turn 與 flag 皆互相對調而已。 12345678// P_iRepeat flag[j] = true; // 表達意願 turn = i; // * enter ( 權力先給對方 ) while ( flag[i] &amp;&amp; turn == i ); // enter C.S. flag[j] = false; // leaveUntil false 12345678// P_jRepeat flag[i] = true; // 表達意願 turn = j; // *enter while ( flag[j] &amp;&amp; turn == j ); // enter C.S. flag[i] = false; // leaveUntil false N 個 Process 之 Critical Section design Bakery’s Algorithm ( 麵包店號碼牌演算法 ) 核心觀念： 客人要先取得號碼牌才可以入店內。 店內一次只能有一個客人進入。 「號碼牌最小的客人」或「號碼牌相同最小之 ID 最小的客人」，得以優先入內。 共享變數 choosing: [0 … n-1] fo boolean：初值皆為 false。\(choose[i] = \left\{\begin{matrix}True \quad P_i \; 正在取得號碼牌中，但尚未取得\\ False \quad P_i \; 已取得號碼牌(init) \end{matrix}\right.\) number: [0 … n-1] of int：初值為 0。\(number[i] = \left\{\begin{matrix}0 \quad 代表 \; P_i \;無意願進入\\ &gt;0 \quad P_i \; 有意願進入 \end{matrix}\right.\) MAX(i … j)：從 i … j 挑最大值。 (a, b) &lt; (c, d)：代表1. a &lt; cor 2. a==c and b &lt; d P_i 之程式碼 12345678910111213Repeat choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; C.S. Number[i] = 0 // P_i 已無意願 R.S.util false Ex1. 為何號碼牌( number[i] )會有兩個以上相同的問題？ 因為在 number[i] = Max(number[0], ... , number[n-1]) + 1 的執行階段時，有可能會被其他 Process 搶斷。 12345678910111213// number[max] = 0// P_i// Processiing " choosing[i] = true; ".Load max number[max]; // number[max] = 0Process max++;// P_j preempting// Processiing " choosing[j] = true; ".Load max number[max]; // number[max] = 0Process max++;// P_iStore to number[i]; // number[i] = 1// P_jStore to number[i]; // number[i] = 1 Ex2. 證明 Critical section 關鍵性值。 Mutual exclusion (OK) ：Case1. 假設號碼牌值皆不同且大於零，則具有最小號碼牌值之 Process 可以優先進入 Critical section，因為最小值必唯一，所以除了該 Process 可以進入其餘等待。Case2. 有多個 Processes 有相同的最小號碼牌，以 Process ID 最小者優先進入 Critical section，因為 Process ID 必唯一最小值也必定唯一，所以除了該 Process 可以進入其餘等待。唯一性確保，互斥確保。 Process (OK)：1. ( 不想進入但不會控制其他人 )假設 P_j 不想進入 C.S. 代表 number[j] 為 0 ，若此時 P_i 欲進入 C.S. 則 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; 不會被 P_j 阻擋住。2. ( 不會造成 deadlock ) 若 P_0 ~ P_n-1 n 個 Processes 皆欲進入 C.S. 會在有限時間內必決定有一個 Process (號碼牌最小加上 ProcessID 最小)可以順利結束 for loop 進入 C.S. Bounded waiting (OK)：假設 P_0~P_n-1 processes 皆欲進入 C.S. 令 P_i 具有最大的號碼牌等於 K ( nuber[i] = K ) 因此，其他 n-1 Process：P_j ( j!=i )，必定先早於 P_i 進入 C.S.，若 P_j 離開 C.S 後，又立刻欲進入 C.S，則 P_j 的再取得號碼牌必定大於 K，所以 P_j 不會再早於 P_i 進入 C.S. 進而可以知道 P_i 最多等待 n-1 次即可進入 C.S.。 Ex3. 123456789101112Repeat choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; ~~while (choosing[j]) do no-op;~~ // 移除這行程式碼是否還正確？請解釋。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; C.S. Number[i] = 0; R.S.util false 不正確，違反「Mutual exclusion」 令目前 number[0 … n-1] 所有的值皆為 0 ，今有兩 Process \(P_i, P_j \quad where \; i \neq j\) 欲進入 C.S. ，並且假設 Process ID 為 \(P_i &lt; P_j\) 小結論 此行程式碼存在的目的，是為了讓所有可能會同一時間拿到號碼牌的 Processes 能公平的取得該號碼牌，不會有的早拿到或是晚拿到該「同一號碼」之號碼牌。 Hardware (CPU) Intructions Support 程式開發者可以使用硬體預先定義之指立於設計 Critical Section。 「test_and_set(bool *lock)」機器指令 功能：回傳 Lock 參數值並將 Lock 參數設為 True，且 CPU 保證此指令是不可中斷地執行( Atomically executed )。 12345bool test_and_set(bool *lock) &#123; bool return_value = *lock; *lock = true; return return_value;&#125; Algorithm 1 ( Fall ) 共享變數： Lock：bool = False( Initial value ) \(P_i\) 之程式碼： 123456do &#123; while (test_and_set(&amp;Lock)); // do nothing /* critical section */ Lock = false; /* remainder section */&#125; while (condition == true); 分析 Mutual exclusion：OK Progress：OK Bounded waiting：Fall假設 \(P_i\) 以早於 \(P_j\) 進入 C.S. ，所以 \(P_j\) 進行等待，當 \(P_i\) 離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 \(P_i\) 有可能可以再次早於 \(P_j\) 執行 test_and_set 進入 C.S.，所以 \(P_j\) 有可能會面臨「Starvation」。 ★★Algorithm 2 ( Pass ) - FIFO 共享變數 Lock：bool = False ( Initial value ) Waiting：[0 … n-1] of bool 初值皆為 False\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\) \(P_i\) 之程式碼： 12345678910111213141516171819202122232425262728區域變數：key:bool; j :int;do &#123; waiting[i] = true; key = true; // 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); // **表明 P_i 不用繼續等待，可以進入 C.S.。 waiting[i] = false; /* critical section */ // 找出下一個欲進入 C.S. 之 P_j Process j = (i + 1) % n; // j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S. while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; // 無 Process 欲進入 C.S. else waiting[j] = false; // 讓 P_j 進入 C.S. /* remainder section */ &#125; while (condition == true); 證明 Critical section 關鍵性值存在： Mutual exclusion：OK\(P_i\) 可進入 C.S. 之條件有兩種可能：Case1：Key 為 False，代表 P_i 是第一個執行 test_and_set 的 Process ，如此才能將 Key 賦予 False ，唯一性。Case2：Waiting[i] = False，因為一開始會先執行 waiting[i] = true; 代表 P_i 在離開 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 前不會將 Waiting[i] 賦予 False ，只有在 C.S. 的 Process 欲離開 C.S. 後才能將其他 Processes 其中一個 Process 的 Waiting 賦予 False 值，但是能在 C.S. 之中執行的 Process 唯一，所以也只會讓一個 Process 的 waiting 賦予 False 值，唯一性( Mutex 成立 )。 Progress：OK(1) 若 P_i 不想進入 C.S. 其 Waiting[i] 為 False ，且 P_i 不會與其他 Process 競爭執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); ，另外，從 C.S. 離開之 Process 不會改變 Waiting[i]，所以 P_i 不會參與進入 C.S 之決策。(2) 若 n 個 Process 皆想進入 C.S. ，則在有限的時間內( 無死結 )必定會決定出第一個執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 者。之後，該選中 Process 從 C.S. 離開後，也會在有限的時間內，讓下一個欲進入 C.S. 的 Process 進入 C.S 。 Bounded waiting：OKn 個 Process 皆欲進入 C.S. ，表示 Waiting[0] ~ Waiting[n-1] 皆為 true。令 P_i 是第一個執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 者，率先進入 C.S.，當 P_i 離開 C.S. 後會將 \(P_{(i+1) \mod n}\) 的 Waiting 賦予 False 值，使 \(P_{(i+1) \mod n}\) 進入 C.S.，依此類推 Process 會以 \(＜P_i, P_{(i+1) \mod n}, \ldots, P_{(i-1) \mod n}＞\) 的序列 ( FIFO ) 進入 C.S.，所以沒有「Starvation」。 「compare_and_swap(int *value, int expected, int new_value) 」指令 功能：將 value 與 new_value 兩值互換，且 CPU 保證為不可分割之執行( Atomically executed )。 實現作法 ( 硬體寫死，無法使用高階程式語言實現 )： 123456int compare_and_swap(int *value, int expected, int new_value) &#123; int temp = *value; if (*value == expected) *value = new_value; return temp;&#125; Algorithm 1 (Fall) 共享變數 Lock：bool = False ( Initial value ) \(P_i\) 之程式碼： 12345678區域變數: key:bool;do &#123; while (compare_and_swap(&amp;lock, 0, 1) != 0) ; /* do nothing */ /* critical section */ lock = 0; /* remainder section */&#125; while (condition == true); 分析 Mutual exclusion：OK Progress：OK Bounded waiting：Fall假設 \(P_i\) 以早於 \(P_j\) 進入 C.S. ，所以 \(P_j\) 進行等待，當 \(P_i\) 離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 \(P_i\) 有可能可以再次早於 \(P_j\) 執行 compare_and_swap 進入 C.S.，所以 \(P_j\) 有可能會面臨「Starvation」。 ★★Algorithm 2 ( Pass ) - FIFO 共享變數 Lock：bool = False ( Initial value ) Waiting：[0 … n-1] of bool 初值皆為 False\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\) \(P_i\) 之程式碼： 12345678910111213141516171819202122232425262728區域變數：key:bool; j :int;do &#123; waiting[i] = true; key = true; // 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。 while (waiting[i] &amp;&amp; key) key = compare_and_swap(&amp;Lock); // **表明 P_i 不用繼續等待，可以進入 C.S.。 waiting[i] = false; /* critical section */ // 找出下一個欲進入 C.S. 之 P_j Process j = (i + 1) % n; // j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S. while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; // 無 Process 欲進入 C.S. else waiting[j] = false; // 讓 P_j 進入 C.S. /* remainder section */ &#125; while (condition == true); 問題探討 Ex1 12345678910111213141516171819202122do &#123; waiting[i] = true; key = true; while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); ~~waiting[i] = false;~~ // 若此行刪除將導致什麼後果？ /* critical section */ j = (i + 1) % n; while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; else waiting[j] = false; /* remainder section */ &#125; while (condition == true); 違反 Progress 性質 ( 造成死結 )。 Semaphore ( 號誌 ) 令 S 為 Semaphore type 變數，架構在 Integer type。針對 S ，提供兩個「Atomic 運算元」wait(S) ( 或 P(S) ) 與 signal(S) ( 或 V(S) )。( 因為是「Atomic 運算元」，所以不會有 Race condition。 ) wait(S) 12while(S &lt;= 0) ;S = S - 1; signal(S) 1S = S + 1 主要功能：「設計 C.S. 」與「解決同步問題」 使用範例 共享變數mutex：semaphore = 1 (Initial value) 程式結構 123456repeat wait(mutex); C.S. signal(mutex); R.S.until False ＜Note＞：semaphore 的初值，有某些意意。\(\left\{\begin{matrix}1 \Rightarrow 互斥控制之用途。\\ 0 \Rightarrow 強迫等待之用途。 \end{matrix}\right.\) 解決簡單的同步問題 ( synchronization problem ) Synchronization Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。 \(Ex.\) \(A;\) 必須要在 \(B;\) 之前執行。 1234// P_i...A;... 1234// P_j...B;... 宣告共享變數 \(s\)：semaphore = 0。 12345// P_i...A;signal(s);... 12345// P_j...wait(s);B;... \(Ex.\) 執行順序為 \(A、C、B\)。 12345// P_i...A;signal(s_1);... 12345// P_j...wait(s_2);B;... 123456// P_k...wait(s_1);C;signal(s_2);... 宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0 1234// P_i...A;... 1234// P_j...B;... 1234// P_k...C;... \(Ex.\) 一直重複執行依照 「\(A、B、C\) 」的順序。 123456// P_iwhile(condition == true) &#123; ... A; ...&#125; 123456// P_jwhile(condition == true) &#123; ... B; ...&#125; 123456// P_kwhile(condition == true) &#123; ... C; ...&#125; 宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0、s_3：semaphore：semaphore = 0。 12345678// P_iwhile(condition == true) &#123; ... A; signal(s_1); wait(s_3); // 注意! ...&#125; 12345678// P_jwhile(condition == true) &#123; ... wait(s_1); B; signal(s_2); ...&#125; 12345678// P_kwhile(condition == true) &#123; ... wait(s_2); C; signal(s_3); ...&#125; 當我們令 s_1：semaphore = 0、s_2：semaphore = 0、s_3：semaphore = 1。 12345678// P_iwhile(condition == true) &#123; ... wait(s_3); // 注意! A; signal(s_1); ...&#125; 12345678// P_jwhile(condition == true) &#123; ... wait(s_1); B; signal(s_2); ...&#125; 12345678// P_kwhile(condition == true) &#123; ... wait(s_2); C; signal(s_3); ...&#125; \(Ex.\) \(C\) 為共享變數且初值為 3，追蹤下列程式判斷可能的結果值。 1234// P_i ... C = C * 2; ... 1234// P_j ... C = C + 1; ... 可能的結果值為6、4、8、7。 s：semaphore = 1 123456// P_i ... wait(s); C = C * 2; signal(s); ... 123456// P_j ... wait(s); C = C + 1; signal(s); ... 可能的結果值為8、7。 s：semaphore = 0 12345// P_i ... C = C * 2; signal(s); ... 12345// P_j ... wait(s); C = C + 1; ... 結果值為7。 \(Ex.\) 求 \(A、B、C\) 可能的執行順序。 s_1：semaphore = 1、s_2：semaphore = 0。 123456// P_i...wait(s_1);A;signal(s_2);... 123456// P_j...wait(s_2);B;signal(s_1);... 123456// P_k...wait(s_1);C;signal(s_1);... 可能的執行順序為A-&gt;B-&gt;C 或 C-&gt;A-&gt;B。 Semaphore 誤用 違反「互斥」 s：semaphore = 1 12345// P_isignal(s); // C.S.wait(s);// R.S. ☆形成死結 s：semaphore = 1 12345// P_iwait(s); // C.S.wait(s);// R.S. ☆ s_1：semaphore = 1、s_2：semaphore = 1。 123456// P_iwait(s_1); wait(s_2); ...signal(s_1); signal(s_2); 123456// P_jwait(s_2); wait(s_1); ...signal(s_2); signal(s_1); 可能會造成「死結」。 12345678910// flow code// P_i wait(s_1); // pass// P_j wait(s_2); // pass// P_i wait(s_2); // block// P_j wait(s_1); // block// Deadlock 重要的同步問題 ( Synchronization Problem ) 解決要點 以 Semaphore 變數實作同步處理條件。 以 Semaphore 實作互斥控制防止「Race condition」。 先同步、再互斥。 Producer Consumer Problem ( 生產者消費者問題 ) producercomsumerproblem Producer：這種 Processes 專門產生資料，以供其他 Processes 使用。 Consumer：這種 Processes 專門處理資料給使用者。 Shared memory 狀態下討論。 ☆Bounded Buffer Producer-Consumer ( 有限緩衝區 ) 當緩衝區滿的時候，生產者必須等待。 當緩衝區空的時候，消費者必須等待。 Algorithm1 共享變數 \(Buffer：[0 \ldots n-1] \; of \; items\) \(in, out：int = 0\) Producer Process 123456789// producerwhile(condition == true) &#123; ... create a new item "t"; while((in+1)%n == out) ; Buffer[in] = t; in = (in + 1) % n; ...&#125; Consumer Process 12345678910// consumerwhile(condition == true) &#123; ... while(in == out) ; assign Buffer[out] to "I"; out = (out + 1) % n; ... // using "I" item ...&#125; Algorithm2(fall) circulerqueue 若使用「Algorithm1」的算法，在上圖所表示的狀態中，算法會判斷為 Buffer 已滿 ((in + 1) % n == out)，無法再加入，所以導致最多只能用 n-1 個 Buffer。 共享變數 \(Buffer：[0 \ldots n-1] \; of \; items\) \(in, out：int = 0\) Count：int = 0 Producer Process 12345678910// producerwhile(condition == true) &#123; ... creat a new item "t"; while(count == n) ; buffer[in] = t; in = (in + 1) % n; count++; ...&#125; Consumer Process 1234567891011// consumerwhile(condition == true) &#123; ... while(count == 0) ; assign buffer[out] value to "I"; out = (out + 1) % n; count--; ... // using tiem "I" ...&#125; 用 Semaphore 解決 Algorithm2 共享變數 empty：semaphore = n代表緩衝區內的「空閒容量」，若為 0 則代表緩衝區已滿。 full：semaphore = 0代表緩衝區中「已使用容量」，若為 0 則代表緩衝區目前為空。 mutex：semaphore = 1對緩衝區、in、out 與 Count 做互斥控制，防止「Race condition」。 Producer Process 123456789101112// producerwhile(condition == true) &#123; ... create a new item "t"; wait(empty); // 確認當前「空格數」是否足夠使用。 wait(mutex); buffer[in] = t; in = (in + 1) % n; count++; signal(mutex); signal(full); // 將「滿格數」添上一筆。&#125; Consumer Process 1234567891011// consumerwhile(condition == true) &#123; ... wait(full); // 確認當前「滿格數」是否足夠使用。 wait(mutex); assign buffer[out] to "I"; out = (out + 1) % n; count--; signal(mutex); signal(empty); // 將「空格數」添上一筆。&#125; Unbunded Buffer Producer-Consumer ( 無限緩衝區 ) 當緩衝區空的時候，消費者必須等待。 不予討論 Reader Writer Problem readerwiterproblem ☆問題重點 Reader、Writer 須對該資料進行互斥處理。 Writer、Writer 須對該資料進行互斥處理。 First reader writer problem firstreaderwiterproblem 對於 Reader 有利，而對於 Writer 不利所以可能導致 Writer 「Starvation」。 共享變數 wrt：semaphore = 1提供 Read/Write 與 Write/Write 的互斥控制，這種控制將會不利於 Writer 的寫入。 readcnt：int = 0紀錄目前的 Reader 個數。\(\left\{\begin{matrix}多一位 \; Reader \Rightarrow readcnt = readcnt + 1。\\少一位 \; Reader \Rightarrow readcnt = readcnt -1。 \end{matrix}\right. \Rightarrow 需使用互斥控制。\) mutex：semaphore = 1 對 readcnt 作「互斥控制」，防止 Race condition。 Reader 程式 12345678910// Reader wait(mutex); readcnt++; if(readcnt == 1) wait(wrt); signal(mutex); // Reading wait(mutex); readcnt--; if(readcnt == 0) signal(wrt); // 目前沒有 Reader 要使用此檔案了。 signal(mutex); Writer 1234// Writer wait(wrt); // Writing signal(wrt); 當 if(readcnt == 1) 符合條件代表目前是第一個想要使用此檔案的 Reader。 需要執行 wait(wrt); 以檢查目前是否有其他的 Writer 正在使用此檔案。1. 若有，則不繼續執行。2. 若無，則通過且將 Writer 阻擋住。 EX：根據上方程式，假設目前 \(W_1\) 已在寫入之中。 若 \(R_1\) 接上面之後開始執行，則 \(R_1\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(wrt);，readcnt = 1。 若 \(R_2\) 接上面之後開始執行，則 \(R_2\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(mutex);，readcnt = 1。 若 \(R_3\) 接上面之後開始執行，則 \(R_3\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(mutex);，readcnt = 1。 Second reader writer problem secondreaderwriterproblem 對於 Writer 有利，而對於 Reader 不利所以可能導致 Reader 「Starvation」。 只要 Writer 離開，發現尚有 Writers 也在等待佇列，則優先讓 Writer 對資料進行寫入，所以可能會導致 Reader Starvation。 共享變數 readcnt：int = 0紀錄目前 Readers 正在讀取的個數。 wrtcnt：int = 0紀錄目前還有多少 Writer 在等待寫入資料。 x：semaphore = 1對 readcnt 作互斥控制，防止 race condition。 y：semaphore = 1對 wrtcnt 作互斥控制，防止 race condition。 z：semaphore = 1因為要對 Writer 有利，所以使用 mutex 作為 Reader 要對資料進行讀取時的障礙，不會急於對資料讀取。(讓 rsem 的效果更明顯) rsem：semaphore = 1作為不利 Reader 之控制。 wsem：semaphore = 1提供 Read/Write 與 Write/Write 的互斥控制。 Reader 程式 1234567891011121314// Readerwait(z); wait(rsem); wait(x); readcnt++; if(readcnt == 1) wait(wsem); signal(x); signal(rsem);signal(z);// Readingwait(x); readcnt--; if(readcnt == 0) signal(wsem);signal(x); Writer 程式 123456789101112// Writerwait(y); wrtcnt++; if(wrtcnt == 1) wait(rsem); // 目前第一個 Writer，會迫使 Reader 多一層等待signal(y);wait(wsem); // 開始等待寫入 // Writingwait(y); wrtcnt--; if(wrtcnt == 0) signal(rsem); // 最後一個 Writer，將擋住 Reader 的閘門解除。 signal(wsem); // Writer 離開時，交付讀寫權。signal(y); The sleeping Barber Problem ( 理髮師睡覺問題 ) 一個理髮師，一張美髮座椅( 理髮師一次服務一個客人 )，與 n 個等待座位。 客人 若等待座位坐滿，就不會進入理髮廳。 若尚未坐滿： 進入理髮廳等待。 通知 / 喚醒理髮師。 若理髮師正在忙碌，客人進行睡覺( waiting )，直到理髮師喚醒客人剪髮，剪完後離開。 理髮師 若目前無客人，睡覺( waiting )直到有客人喚醒理髮師。 若目前理髮師醒著且目前有客人正在等待，會去喚醒客人理髮，重複動作直到沒有客人為止最後睡覺(wait)。 共享變數： customer：semaphore = 0用來處理客人與理髮師的同步問題。有客人才被喚醒工作，若無則繼續睡覺。 barber：semaphore = 0用來處理客人與理髮師的同步問題。若理髮師忙碌等待並睡覺，反之進行理髮。 waiting：int = 0目前座在等待區的人數。\(\left\{\begin{matrix}客人入店 \; \Rightarrow waiting++ \\理髮師開始處理下一為客人 \Rightarrow waiting-- \end{matrix}\right.\) mutex：semaphore = 1對 waiting 變數做互斥處理，以免 Race condition。 Barber 程式 12345678910// barberwhile(conditon == false) &#123; wait(customer); // 目前沒有客人，Barber 睡覺去。 wait(mutex); waiting--; signal(barber); // 叫醒客人。 signal(mutex); // processing cutting hair // signal(barber); // worng code&#125; Costomer 程式 12345678910// customer: 注意! customer 並沒有需要 loop 持剪髮的需求。wait(mutex); if(waiting &lt; n) &#123; waiting++; signal(customer); // 叫醒/通知 Barber。signal(mutex); wait(barber); &#125; else &#123;signal(mutex); &#125; secondreaderwriterproblem_2 The Dining-philosophers Problem (哲學家用餐問題) dining_philosophersproblem 倆倆之間有一隻筷子，哲學家若感到飢餓，必須要能夠同時取得左右兩根筷子才能用餐。用完餐後放下左右兩根筷子，進行思考模式。 ＜Note＞ 中餐，奇數或是偶數位哲學家皆可以，因為左右邊都可以是一根筷子。 西餐，一定為偶數個哲學家，因為為吃飯需要一副刀叉。 thedinningphilosopherproblem2 共享變數 chopstick[0…4] of semaphore = {1 … 1}對 5 根筷子進行互斥控制。 i (i：0…4) 哲學家：\(Process \; P_i\) Philosopher 程式 (fall) 12345678910// philosopherwhile(condition==false) &#123; // need processing... wait(chopstick[i]); wait(chopstick[(i+1)%5]); // processing signal(chopstick[i]); signal(chopstick[(i+1)%5]); // thinking&#125; 在上述程式碼中，若每位哲學家都依序先取得左筷，之後每位哲學家在取得右筷時，會直接形成「Circular waiting」，所以這程式很有可能會造成「Deadlock」。 thedinningpholosopherproblem3 解法一 最多只允許 4 位哲學家上桌用餐。 根據產生死結的定理：m = 5、\(Max_i = 2 \; where \; 1 \leq i \leq 5\)。 \(1 \leq Max_i \leq m\)，OK。 \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+ 5 \Rightarrow n &lt; 5\)。 保證 「Deadlock free」。 可以利用一個號誌來實現這個做法 s：semaphore = 4。 123456789101112// philosopherwhile(condition==false) &#123; // need processing... wait(s); wait(chopstick[i]); wait(chopstick[(i+1)%5]); // processing signal(chopstick[i]); signal(chopstick[(i+1)%5]); signal(s); // thinking&#125; 解法二 增加限制「除非哲學家可以同時取得左右邊兩隻筷子，才允許取得筷子，否則不得持有該筷子」。 要解決「Hold and wait」的問題。 解法三 增加一個限制「相鄰的哲學家取筷的順序必須不同」。 創造「Asymmtric」，則必不可能形成迴路，亦不能造成「Circular waiting」。 Ex. \(\left\{\begin{matrix} 偶數號 \quad 先取左再取右。\\ 奇數號 \quad 先取右再取左。\end{matrix}\right.\) 這種做法亦等同於在西餐時，規定每個人必須先取刀再取叉一致。 Semaphore 種類 分類一 - 區分號誌值域 Binary semaphore (二元) semaphore 的值指介於 0 或 1。 不可為負。 無法紀錄有多少個 Process 正在 wait semaphore。 1234567S:Binary semaphore = 1;wait(S): while(s&lt;=0); s--;signal(S):s++; 1234// usagewait(s);//C.S.signal(s); Counting semaphore (計數) semaphore 值域在整數之上(可為負) 可以利用負值知道目前有多少 Process 正在等待 semaphore，ex. s = -n。 使用 Binary semaphore 實現 Counting semaphore。 共享變數 C：int代表 Counting semaphore 號誌值。 S1：binary semaphore = 1。對 C 作互斥控制，防止 race condition。 S2：Binary semaphore = 0。當 C &lt; 0 的時候，讓 process 暫停。 程式 123456789101112131415wait(C): wait(S1); C--; if(C &lt; 0) signal(S1); wait(S2); else signal(S1);signal(C): wait(S1); c++; if(c&lt;=0) signal(S2); signal(S1); 12345C: counting semaphore = 1;wait(c);// C.S.signal(c); 分類二 - 是否 Busy-waiting Spinlock 令 S 為 semaphore 變數。 123456wait(s): while(s&lt;=0); s--;signal(s): s++; Pros and Cons：與 busy waiting 優缺一致。 Non-Busy-waiting semaphore 1234567891011121314151617181920struct semaphore &#123; int value; Queue q;&#125;s:semaphorewait(s): s.value--; if(s.value &lt; 0) &#123; add process P into s.q; block(P); &#125;signal(s): s.value++; if(s.value &lt;= 0) &#123; remove a process P from s.q; wakeup(P); &#125; ＜Note＞這種實現的方法也算是 counting semaphore。 實現 Counting semaphore 要如何保證 semaphore 避免 Race condition，也要確保 wait 與 signal 等指令是不可分割的。 Non-busy waiting semaphore Spinlock semaphore Disable interrupt ☆ Alogorithm1 ☆ Alogorithm3 C.S. Design：Software sol.、Hardware sol. Alogorithm2 Alogorithm4 Alogrithm1 123456789101112131415161718192021222324252627// alogoithm1struct semaphore &#123; int value; Queue q;&#125;s:semaphorewait(s): // disable interrupt s.value--; if(s.value &lt; 0) &#123; add process P into s.q; // enable interrupt block(P); &#125; else &#123; // enable interrupt &#125;signal(s): // disable interrupt s.value++; if(s.value &lt;= 0) &#123; remove a process P from s.q; wakeup(P); &#125; // enable interrupt Algorithm2 將「Algorithm1」中的disable interrupt換成是entry section。 將「Algorithm1」中的enable interrupt換成是exit section。 12345678910111213141516171819202122232425// algorithm2struct &#123; int value; Queue u;&#125; semaphore;wait(s): // entry section s.value--; if(s.value &lt; 0) &#123; add process P into s.q; // exit section block(); &#125; else &#123; // exit section &#125; signal(s): // entry section s.value++; if(s.value &lt;= 0) &#123; remove process P from s.q; wakeup(P); &#125; // exit section Hardware solution 使用test_and_set()實踐「entry section」與「exit section」。 1234567// entry section// global waiting: boolean[] = false// global lock: boolean = false waiting[i] = true; while(test_and_set(lock) &amp;&amp; waiting[i]) ; waiting[i] = false; 1234567891011// exit section tmp = (i + 1) % n; while(tmp != i) &#123; tmp = (tmp + 1) % n; &#125; if(tmp == i) &#123; lock = false; &#125; else &#123; waiting[tmp] = false; &#125; software solution 使用「Bakery’s solution」。 1234567891011// entery section// global chooseing: boolean[] = false// global number:int[] = false choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; 12// exit section number[i] = 0; Algorithm3 123456789101112131415161718192021// algorithm3struct &#123; int value;&#125; semaphore;semaphore s;wait(s): // disable interrupt s.value--; while(s.value &lt;= 0) &#123; // enable interrupt sleep(random); // disable interrupt &#125; // enable interruptsignal(s): // disable interrupt s.value++; // enable interrupt Alogorithm4 123456789101112131415161718192021// algorithm4struct &#123; int value;&#125; semaphore;semaphore s;wait(s): // entery section s.value--; while(s.value &lt;= 0) &#123; // exit section sleep(random); // entery section &#125; // exit sectionsignal(s): // entery section s.value++; // exit section Hardware solution 使用test_and_set()實踐「entry section」與「exit section」。 1234567// entry section// global waiting: boolean[] = false// global lock: boolean = false waiting[i] = true; while(test_and_set(lock) &amp;&amp; waiting[i]) ; waiting[i] = false; 1234567891011// exit section tmp = (i + 1) % n; while(tmp != i) &#123; tmp = (tmp + 1) % n; &#125; if(tmp == i) &#123; lock = false; &#125; else &#123; waiting[tmp] = false; &#125; software solution 使用「Bakery’s solution」。 1234567891011// entery section// global chooseing: boolean[] = false// global number:int[] = false choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; 12// exit section number[i] = 0; 無法完全避免的 Busy-waiting 定義 製作 semaphore Busy waiting \(\Rightarrow\) Non-busy waiting 在實踐「Entry section」時，就必須使用「Busy-waiting」。 semaphore Busy waiting \(\Rightarrow\) Non-busy waiting 若使用「Disable interrupt」，風險實在太高，不適合用在多處理器( Multiprocessor )之上。 小結論：在 semaphore 之下的 busy waiting 是短暫的，不避太在意會浪費效能。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Management and Thread Management]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Process-Management-and-Thread-Management%2F</url>
    <content type="text"><![CDATA[Process 定義：A program in execution. Process 建立後，主要組成有：\(^{[1]}\)Process NO.(ID), \(^{[2]}\)Process state, \(^{[3]}\)Process menory space：Code section, Data section。 Programming Counter (PC)：下一條指令的位址。 Stack Cpu registers value 是 OS 分配資源(CPU, I/O - Devce, Memory)的基本單位。 與Program (程式) 的差異 Process Program 執行中的程式 只是一個在硬碟的檔案 “執行中”的單位 “被動的”單位 Procress Control Block 定義：作業系統為了管裡所有的 process ，會在 kernel memory 中，替每個 process 各自準備一個 block 紀錄 process 之所有相關的資訊。 內容： Process No. (ID)：是唯一( unique )的。 Process state：有 「ready」、「running」、「wait」…。 Programming Counter ( PC ) CPU registers：有accmulatorm, psw, stack top… CPU schedualing infomation：優先權值、process arrival time (FIFO)。 Memory management infomation：隨作業系統記憶體管理方式不同記錄不同的資訊。如：Base/limit register, page table 或 segememt table。 Accounting infomation：Pocess 已使用了多少 CPU time ，那些資源還剩多少資源、還剩 CPU time 可用，系統管理員依據此資訊用以調校效能。 I/O status infomation：Process 已發出多少 I/O-request，完成狀態如何，目前占用哪些 I/O 資源。 \(Ex29.\) (Ref P.4-75)：以下哪些項目是不包含在正常的 PCB 當中？ Process number CPU register I/O device queue：為作業系統管理，不屬於每個 process。 \(Ex34.\) (Ref P.4-78)：以下哪些項目是不包含在正常的 PCB 當中？ Process state The bitmap of this process：用於磁碟可用空間的管理方法。 Register State trasition diagram (S.T.D.) 用於描述 Process 的 Lifecycle。 五個狀態 狀態 New (Create)：Process 被建立，已分得 PCB 空間，尚未載入 memory( 尚未取得 memory 資源 )。 Ready：Process 已在 memory 中，且在 ready queue 內，具有資格爭奪 CPU。 Running：Process 取得 CPU 並執行中。 Wait( Blocked )：Process 在 waitting queue 中，等待 I/O completed 或 事件發生。( 不會爭奪CPU ) Exit( Terminate, Zombie, abort )：Process 完成工作正常結束或異常終止，此時可能其 PCB 尚未回收，因為要等其父親 (paraent-process)得到孩子(child-process)的成果之後，才會回收 PCB space。( 其他資源如memory, cpu, I/O-Device 等已回收 ) 轉換 Admited：當記憶體空間足夠時，可由 long-term scheduler依優先權決定此工作載入與否。( in Batch system, not in Time sharing, not in Interactive system ) Dispatch：由 short-term scheduler 決定，讓高優先權的process 取得 CPU。 Interrupt (Time-out)：執行中的 process 會因為某些事件發生而被迫放棄CPU，回到 ready queue。例如：Time-out, interrupt 發生，高優先權的 process 到達而被插隊。 Exit：Process 完成工作或異常終止。 1526880431737 *七個狀態 狀態 Block/Suspend：Process 被 swapout 到磁碟中暫存。(Blocked/Sleep in Disk) Ready/Suspend：事件完成或 I/O-completed。(Ready in Disk) 轉換 Admit (實線)：記憶體足夠時。 Admit (虛線)：記憶體不足時。 Block-Suspend ( Swap-out )：當 memory 空間不足且有其他高優先權 process 需要更多 memory space 時，會由 medium-term scheduler 決定將 blocked process swap-out 至磁碟以空出 memory space。 Block-Ready ( Swap-in )：這是一個不好的設計，但仍可以支持主要是因為若所有的「Blocked-suspend state」process 優先權皆高於「Ready-suspend state」process，且作業系統相信後者會比較早進入等待狀態時。 Ready-Suspend( Swap-out )：支持此行為( trainsition )的理由：\(^{[1]}\) 所有 blocked process 皆 swap-out 後 memory 仍不足時。\(^{[2]}\) 所有 blocked state process 之優先權皆高於 ready state process 時。 Ready-Active ( Swap-in )：當 memory 有空時，medium-term scheduler 可將process swap-in memory 之中(Ready)準備被執行。 Running-Suspend( Swap-out )：這是一個不好的設計，但仍可以支持主要是因為若有一個高優先權process 從 「Blocked/suspend」變為「Ready/suspend」時，則作業系統可以強迫低優先權的process放掉 CPU 及 memory，供高優先權的 process 使用。 1526883114200 UNIX STD 1526885420905 Scheduler I/O-bound &amp; CPU-bound 1526887552589 I/O-bound Job 定義：此類型的工作大都是需要大量的 I/O operation( Resourse )但對於 CPU time( Computation )需求很少，所以其工作效能會受限於 I/O-device 之速度。 例如：資料庫管理、財報列印…。 CPU-bound Job 定義：此類型的工作大都是需要大量的 CPU time( Computation ) 但對於 I/O operation( Resourse )需求很少，所以其工作效能會受限於 CPU 之速度。 氣象預估的大氣模型、科學模擬…。 Long-term schduler 定義：又稱為 Job schduler，目的是為了從 Job-queue 中挑選一些工作載入到記憶體中。 特點： 執行頻率最低。 可以調控 Multiprogramming degree。 可以調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 由 Batch system 採用，但是 Real-time system 及 Time-sharing system 皆不會採用。 Short-term schduler 定義：又叫做CPU schduler 或 process schduler，目的是從「Ready queue」中挑出一個高優先權的 process，分派 CPU 給予執行。 特點： 執行頻率最高。 無法調控 Multiprogramming degree。 無法調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 所有的 system 皆採用。 ★Midium-term scheduler 定義：為 Time-sharing system 所採用。( 不為 Real-time system 所採用，因為該系統不支援 Swap-out - 虛擬記憶體 ) 目的：當記憶體空間不足時，且又有其他高優先權的 process 需要記憶體時，此 scheduler 會挑選一些process ( 例：Blocked process、低優先權 procss ) 將其 swap-out 到磁碟中保存，以空出記憶體空間，翁其他 process 使用，將來等到有足夠的記憶體空間被釋放時，此 sechduler可再將 Swap-outed process Swap-in 至記憶體等待執行( Ready for execution )。 特點： 執行頻率居中。 可以調控 Multiprogramming degree。 可以調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 為 Time sharing system 採用，但 real-time system 與 batch system 不採用。 Context switching 當 CPU 要從 running process 切給另一個 process 使用之前，kernel 執行 context-switching 包含： 保存 running process 之目前狀態的資訊( PCB )。如：PC、stack、CPU register…。 要載入( Restore )另一個 Process 之狀態資訊( PCB )。 Context switching 是一額外負擔，其時間長短大都取決於硬體的因素。如：暫存器之數量、記憶體存取速度。 如何降低 Context switching 的負擔？ 方法一：若暫存器很多，則可以 讓每個 process 皆有私有的( private )「Register set」，則作業系統只要切換指標指向另一個 process 的「Register set」即可完成 context swiching，而不用記憶體的存取( store and restore )。 此種方法速度最快。 方法二：使用「Multithreading」機制。 方法三：讓 system process 以及user process各自有自己的 register set，如此一來兩者之間的切換只要改變指向register set 的 pointer 即可。 Dispatcher分派器 &amp; Dispatch Latency 分派延遲 定義：Dispatcher 為一模組用來將 CPU 控制權授予「經由 CPU scheduler」所選出之 process (user process)。 主要工作 Context switching ( 費時最久 ) Change mode from kernel mode to user mode Jump to the execution entry of that selected process 在做上述這些工作的時間的總和就稱為「Dispatch Latency」。 Dispatch Latency 越小越好。 Process control operations 也就是 process 的建立、終止、暫停、回復執行、設定、修改、讀取 process atteributes …，而這些都應是作業系統提供的服務(system call)。 Process 可以建立自己的 child process，目的是要 child process 工作。 Child process 的工作可分為兩類： 與 parent 相同的工作。(word編輯器) 特定工作 。(與 parent 不同) Parent 與 child 之互動關係 Concurrent execution Parent waits for child until child terminated Child process 的資源取得 方法一：作業系統供應 方法二：Parente供應 Parent 若終止，則 child process 會： 方法一 - Cascading termination：一併終止。 方法二：存活資源向\(^{[1]}\)作業系統取得，或向\(^{[2]}\)祖先 process 取得。 UNIX system call 1527077415190 fork()：用以建立 child process ，而 fork() 之回傳結果如下： 失敗，因為資源不足無法建立 process ，回傳 -1 給作業系統，在傳給 parent process。 成功，作業系統會回傳 \(^{[1]}\) 0，給 child process。 \(^{[2]}\) 大於 0 的正整數，給 parent process，且此值為 child process ID (PID)。 wait()：用以暫停 process 的執行直到某個事件發生。例如：parent 等到 child 直到 child 終止。 exit()：用以終止 process 的執行且回收期資源 ( 不包含PCB )，通常 \(^{[1]}\) exit(0) 表示正常終止。 \(^{[2]}\) exit(-1) 表示異常終止。 execlp() 或 exec() 或 execve()：用以載入特定的 Binary code( 可執行檔 ) 執行。 例：execlp(“目錄名稱”, “檔名”, 個數) getpid()：用以取得 process 的 ID。 1527077382823 ＜Note＞： 呼叫 fork() 後作業系統會配置 child process memory space，此空間與 parent 是佔用不同的記憶體空間，且 child 的資料區塊及程式碼區塊內容均來自 parent 的一份副本。 若 child 所做的工作與 parent 相同( 平行處理 )，則只要使用 fork() 便可達到此目的。 若 child 要做特定的工作(與 parent 不同)，則 child 必須執行 execlp() 以載入特定工作的執行檔。 1527077442901 程式實際操作 \(Ex1.\) 建立 child process 執行 ls 命定檔且 parent 等到 child 完成之後 parent 才輸出「child complete」。 Creating a separate process using the UNIX fork() system call. 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); //fork a child process if (pid &lt; 0) &#123; // error occurred fprintf(stderr, "Fork Failed\n"); return 1; //exit(-1); &#125; else if (pid == 0) &#123; // child process execlp("/bin/ls","ls",NULL); // 程式區塊指標轉換，下方不做，見上圖。 &#125; else &#123; // parent process wait(NULL); // parent will wait for the child to complete printf("Child Complete\n"); &#125; return 0;&#125; \(Ex2.\) (Ref p. 4-52) Identify the values of pid at lines A, B, C, and D. ( Assume that the actual pids of the parent and child are 2600 and 2603, respectively. ) 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid, pid1; pid = fork(); // fork a child process if (pid &lt; 0) &#123; // error occurred fprintf(stderr, "Fork Failed\n"); return 1; &#125; else if (pid == 0) &#123; // child process pid1 = getpid(); printf("A: Child: pid = %d\n",pid); // A -&gt; 0 printf("B: Child: pid1 = %d\n",pid1); // B -&gt; 2603 &#125; else &#123; // parent process pid1 = getpid(); // child process ID printf("C: Parent: pid = %d\n",pid); // C -&gt; 2603 printf("D: Parent: pid1 = %d\n",pid1); // D -&gt; 2600 wait(NULL); &#125; return 0;&#125; \(Ex3.\) (Ref p. 4-53) 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int value = 5; // global varibleint main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process value += 15; return 0; &#125; else if (pid &gt; 0) &#123; // parent process wait(NULL); printf("PARENT: value = %d\n",value); // LINE A value -&gt; 5 return 0; &#125; return 0;&#125; ★\(Ex4.\) 程序的並行 求輸出結果？ ( Tip: 父與子是並行的。 ) 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process printf("A\n"); &#125; else if (pid &gt; 0) &#123; // parent process printf("B\n"); &#125; return 0;&#125; Ans： 12AB OR 12BA 都有可能。 求輸出結果？ ( Tip: 父與子是並行的。 ) 考慮： 1527080836257 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process printf("A\n"); &#125; else if (pid &gt; 0) &#123; // parent process printf("B\n"); wait(NULL); &#125; printf("C\n"); return 0;&#125; Ans： 1234ACBC OR 1234ABCC OR 1234BACC ★\(Ex5.\) 共享變數 假設 Count 是 parent 與 child process 的共享變數，且初值為 5。 123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process count++; printf("%d\n", count); &#125; else if (pid &gt; 0) &#123; // parent process wait(); count--; printf("%d\n", count); &#125;&#125; Ans： 1265 ＜Note＞：共享變數可用以下方式達成。 檔案共享。 UNIX 的 pipe。 共享記憶體區間。( Windows / Linux ) 假設 Count 是 parent 與 child process 的共享變數，且初值為 5。 考慮： 1527081997770 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt; using namespace std;int main(int argc, char **argv) &#123; int* count; count = (int*) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0); if (count == MAP_FAILED) &#123; cout &lt;&lt; "mmap failed..." &lt;&lt; strerror(errno) &lt;&lt; endl; return -1; &#125; *count = 5; pid_t pid; pid = fork(); if (pid == 0) &#123; (*count)++; &#125; else if (pid &gt; 0) &#123; (*count)--; &#125; cout &lt;&lt; (*count) &lt;&lt; endl; return 0;&#125; Ans： 1255 OR 1245 OR 1265 OR ( 當指令不是 atomic 時 ) 1266 OR ( 當指令不是 atomic 時 ) 1244 ★OR ( 當指令不是 atomic 時 ) 1246 ★OR ( 當指令不是 atomic 時 ) 1264 \(Ex6.\) 有幾個 process 被建立了？ including main() (Ref p. 4-54, Text book p. 150) 1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; /* fork a child process */ fork(); /* fork another child process */ fork(); /* and fork another */ fork(); return 0;&#125; Ans：8 個。 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; if(fork() == 0) &#123; // child process fork(); fork(); &#125; fork(); return 0;&#125; Ans：10 個。 1531135436305 ★ 12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; fork(); if(fork()&gt;0) &#123; // parent process fork(); &#125; else if(fork()==0) &#123; // child process fork(); fork(); &#125; return 0;&#125; Ans： 14 個。(30個) 1531136821130 1531137337724 ★★ 1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; for(int i = 0; i &lt; 3; i++) &#123; if(fork()==0) &#123; fork(); fork(); fork(); &#125; &#125;&#125; Ans：729 個。 1531138419381 1531139238689 \(i == 2\), 會再多新生 \(8 \times 81 = 648\) 加上原本的 81 個等於 729 個 Processes。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; for(int i = 0; i &lt; 3; i++) &#123; if(fork()==0) &#123; fork(); &#125; else if (fork()&gt;0) &#123; if(fork()==0) &#123; fork(); &#125; &#125; &#125;&#125; Ans：216 個。(1728 個) 1531139971022 \(i == 1\)，上面六個 Processes 會再各自生成 5 個行程，所以會再多生產 \(5 \times 6 = 30\) 個 Processes ，加上原本的 Processes 等於 36 個。\(i == 2\)，36 個 Processes 會再各自生成 5 個行程，所以會再多生產 \(5 \times 36 = 180\) 個 Processes ，加上原本的 Processes 等於 216 個。 printf(&quot;%d\n;&quot;, a);共做幾次？ 印出0幾次？ 印出1幾次？ 印出2幾次？ 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int a = 2; fork(); a--; printf("%d\n", a); if(fork()==0) &#123; a--; printf("%d\n", a); fork(); &#125; else &#123; a++; fork(); printf("%d\n", a); &#125;&#125; Ans： 1234567811002222 1531141578065 12345678910111213141516171819202122\\ 錯誤答案110022222222222222222 CPU 排程 評估 CPU scheduking 效能之五個準則(criteria) CPU utilization - CPU 利用度(率) \(\frac{CPU \; Process \; execution \; time}{CPU \; total \; time}\) \(CPU \; total \; time = process \; execution \; time + comtext \; switch \; time + idle \; time \dots\) $Ex. $ Process 平均花 5 ms 在 execution 上，花 1 ms 在 comtext switching，則 \(CPU \; utilization = \frac{5}{5+1}\) Throughput - 產能 單位時間完成的工作數目。 1527426695265 ★ Waiting time - 等待時間 Process 在 Ready Queue 中等待獲得 CPU 之等待時間的加總。 \(Ex.\)上圖的等待時間為 \((8-2)+(19-15) = 10\)。 ★ Turnaruond time - 完成時間 自 process 進入(到達) 到工作完成的這段時間差值。 $Ex. $上圖的等待時間為 \(26-2 = 24\)。 Response time - 回應時間 自使用者 (user process) 輸入命令(或資料)給系統後，到系統產生第一個回應的時間差。(Time-shaeing system, user-interactive application 特別重視。) 由上述可知，CPU utilization、throughput 愈高愈好；waiting time、turnaround time、response time 愈低愈好。 排班法則 Starvation Process 因為長期無法取得完工所需之各項資源，導致遲遲無法完工，形成「Indefinite blocking - 未知期停滯」現象。 容易發生在不公平對待的環境之中，若又有「Preemptive - 可搶奪機制」，則更容易發生。 解決方案：使用「Aging」技術。隨著 process 待在 system 內的時間逐漸增加，我們也逐步調高此process 的優先權，經過一段有限的時間後，此 process 會有最高優先權，故可取得需要的資源(resourses)完工。 ＜Note＞：soft real-time system 不採用 「Aging」。 Non-preemptive 與 premptive 法則 觀點一 Non-premptive 法則 除非執行中的 process 自願放掉 CPU，其他的 process 才有機會取得 CPU，否則就只能 wait ，不可逕自搶奪 CPU。 \(Ex.\) 自願放棄使用 CPU 的情況：完成工作、wait for I/O-completed after issue I/O-request …。 Pros Comtext switching 次數較少 ( 時間節省 )。 Process 之完工時間點較可以預期 ( preditable )。 比較不會有「Race condition problem - 資源競爭問題」。 Cons 排班效能較差，因為可能會有 「Convoy effect」。 不適合用在 Time-sharing system 與 Real-time system。 Preemptive 法則 執中的 Provess 有可能被迫放棄 CPU ，回到 Ready queue ，再將 CPU 指派給別的 Process 使用。 \(Ex.\) Time-out ( 用在分時系統 )、interrupt …。 Pros 排班效益較佳，平均 waiting / turnaround time 較小。 適用於 Real time system 與 Time sharing system。 Cons 完工時間較不可預期。 Context switching 次數較多，負擔重。 須注意 Race condition 的發生。 ★觀點二 從 CPU 排班決策(啟動)的時機點區分。 Running \(\rightarrow\) Block Ex. Wait for I/O-completed (自願) Running \(\rightarrow\) Ready Ex. Time out (被迫) Wait \(\rightarrow\) Ready Ex. I/O-completed (高優先權的 Process 開始需要 CPU，作業系統啟動排班器，低優先權的 process 被迫放棄 CPU ) Running \(\rightarrow\) Exit (terminate) Ex. Task completed (自願) 所以若排班決策之啟動點只包含 Running \(\rightarrow\) Block 與 Running \(\rightarrow\) Exit (terminate) 未包含 Running \(\rightarrow\) Ready 或 Wait \(\rightarrow\) Ready 則為 Non-preemptive，否則為 Preempt。 ＜Note＞：凡是 \(\ldots \rightarrow\) Ready 皆列入 Preemptive 元素，所以 Ready/suspend \(\rightarrow_{Swap\; in}\) Ready、New \(\rightarrow\) Ready … 也列入。 預估 Process Next CPU Burst Time 公式 \[ \tau_{n+1} = \alpha \cdot t_n + (1-\alpha) \cdot \tau_n \] \(\tau_{n+1}\)：下次預估值。 \(t_n\)：本次實際值。 \(\tau_n\)：本次預估值。 \(\alpha\)：加權值。(\(0 \leq \alpha \leq 1\)) \(Ex.\) 當\(\alpha = 0.5\) 1527475744485 ＜Note＞：\(\alpha\) 的值用於條整與歷史紀錄的相依性高低。 FIFO 到達時間最小的 process 取得 CPU，也就是說先來先做。 1527427440948 到達時間皆為 0。 到達順序為：P1、P2、P3。 Gantt chart。 FIFO Avg. waitting time \[ \frac{(0-0)+(24-1)+(27-0)}{3}=17 \] Avg. turnaround time \[ \frac{(24-0)+(27-0)+(30-0)}{3}=27 \] 分析 易於製作。 排班效能最差，即 Avg. waiting time &amp; Avg. turnaround time 最長 (其他準則不看)。 可能有「Convoy effect - 護衛效應」，許多 processes 均等待一個需要很長 CPU time 之 process 完成工作，才能取得 CPU，導致 Avg. waiting time 太長。 非常公平。 沒有 starvation 現象。 Non-premptive，不可搶奪、插隊。 SJF ( Shortest Job First ) 具有最小 CPU time 的 process，優先取得 CPU。 1527472805224 到達時間皆為 0。 Gantt chart。 1527472898945 Avg. waiting time \[ \frac{(0-0+(3-0)+(9-0)+(16-0)}{4}=7 \] 分析 排班效益最佳( Optimal ) 即 Avg. waiting/turnaround time 最小。Proof： 由上圖可知Waiting time for long job：\(0 \rightarrow CPU \; execution \; time_{short \; job}\)Waiting time for short job：\(CPU \; execution \; time_{long \; job} \rightarrow 0\)Avg. waiting ime：\(\frac{(CPU \; execution \; time_{short \; job}-0)+(0-0)}{2} &lt; \frac{(0-0)+(CPU \; execution \; time_{long \; job}-0)}{2}\) 以這種方式 Short job 所減少的等待時間必定大於等於 Long job 所增加的等待時間，所以會使平均等待時間變小，最後可歸納到必為最佳的排班法則。 不公平，偏好 short job。 可能會 Starvation (for long job)。 又可以分為： Non-preemptive ( SJF ) Preemptive ( SRTF or SRJF ) 較不適合用在 shortest-trem scheduler，因為 short-term schduler 執行頻率太高，所以很難在極短時間內預估出精確每個process 的 CPU burst time 又要挑出最小值，不易真正呈現出 SJF 之行為；但比較適合 long-term schduler。 SRTF ( Shorest Remaining-time Job First ) 又稱為 SRJF 或 SRTN ( Shorest Remaining-time Job Next )，即為「Preemptive - SJF」，將剩餘 CPU burst time 最小的 Process 取得 CPU，若「新到達的 process」 的 CPU burst time 目前執行中 process 剩下的 CPU time ，則新到達的 Process 可以插隊( Preemption )目前執行中的 Process。 SRTF Avg. waiting time for *SRTF \[ \frac{ ((0-0)+(10-1)) + (1-1) + (17-2) + (5-3) }{ 4 } = 6.5 \] SJF \[ \frac{ (0-0)+(8-1)+(12-3)+(17-2) }{4} = 7.75 \] FIFO FIFO \[ \frac{ (0-0) + (8-1) + (12-2) + (21 -3) }{4} = 8.75 \] 分析 與 SJF 相比 SRTF 的平均 waiting / turnaround time 會比較小，但是付出較大的 Context switching 負擔。 不公平，偏好 Short remaining time job。 可能會有 Starvation。 屬於 Preemptive。 Priority Method 具有最高優先權的 Process 取得 CPU ，若多個 Process 權值相同，則以 FIFO 為準。 1527479225080 到達時間皆為 0。 Non-preemptive priority method 且 Priority number 愈小優先權愈大。 Avg. waiting time 1527479387651 \[ \frac{ (6-0)+(1-0)+(16-0)+(18-0)+(1-0) }{5}=8.2 \] \(Ex2.\) Process Arrvial time Priority Burst time P1 0 5 5 P2 2 2 3 P3 5 4 8 P4 10 3 4 P5 13 1 6 Preemptive priority method。 Priority number 愈小優先權愈大。 Avg. waiting time 1527486332570 \[ \frac{ ((0-0)+(23-2)) + (2-2) + ((5-5)+(20-10)) + ((10-10)+(19-13)) + (13-13) }{5} = \frac{37}{5} \] 分析 不公平。 可能會有 Starvation ，但可以用「Aging」解決。 分為 Non-preemptive 與 Preemptive。 是一個具有參數化的方法，給予高低不同的優先權值，可展現出不同的排班行為。 Priority 的定義 行為 Arrival time 愈小，優先權愈大。 FIFO CPU time 愈小，優先權愈大。 SJF 剩餘時間愈小，優先權愈大。 SRTF ★Round Robin 為 Time sharing system 所採用，作業系統會規定一個 CPU time Quantum (Slice) ，當 Process 取得 CPU 執行後，若未能在此 Quantum 完成工作，則「Timer」會發出一個「Time-out interrupt」通知作業系統強迫回收 CPU 並將此 Process 送回「Ready queue」中等待下一輪再取得 CPU 執行，每一輪之中，是採以 FIFO 的排班法則規劃。 Process CPU time P1 8 P2 4 P3 9 P4 5 到達時間為 0。 順序為：P1～P4。 Quamtum = 4。 Avg. waiting time。 1527829801602 \[ \frac{((0-0)+(16-4))+((4-0))+((8-0)+(20-12)+(25-24))+((12-0)+(24-16))}{4} = \frac{53}{4} \] Process *Arrival time CPU time P1 0 20 P2 2 5 P3 7 3 P4 13 8 Quamtum = 4。 Avg. waiting time。 1527831109693 \[ \frac{((0-0)+(8-4)+(16-12))+((4-2)+(15-8))+((12-7))+((18-13))}{4} = \frac{27}{4} \] Processs ★Arrival time ★★行程行為 P1 0 5 CPU + 6 I/O + 4 CPU P2 3 15 CPU P3 8 3 CPU + 10 I/O + 9 CPU P4 14 8 CPU Quantum = 5 (Ref p.4-111)。 1528097302440 Turnaround time。 P1 = 22 - 0。 P2 = 32 - 3。 P3 = 44 - 8。 P4 = 40 - 14。 Avg. waiting time。 \[ \frac{((0-0)+(18-11))+((5-3)+(13-10)+(27-18))+((10-8)+(32-23)+(40-37))+((22-14)+(37-27))}{4} = \frac{113}{4} \] ＜Note＞：有爭議的題目。 Process Arrival time CPu time P1 0 10 P2 4 9 P3 8 6 Quantum = 4。 1527833536050 不知道為 P2 還是 P1 先進入 Waiting queue。 分析 Time sharing system 採用此方法。 也為一種可參數化 (ex. Quantum)的法則。 公平。 沒有 starvation。 ★Preemptive。 Round robin 排班效益取決於 Time quantum 大小決定。 \(Ex1. \; Quantum = \infty\) 則 RR 會變成 FIFO，也可以說排班的效能很差。\(Ex2. \; Quantum \rightarrow 0\) 則 Context switching 太頻繁，CPU utilization 會變得非常差 (\(\approx 0\))。$Ex3. $ 根據經驗法則，若 Quantum 能讓 80% 的工作量在該時間完成，效能最佳。 ＜Note＞： RR 雖然是公平，但可支持差異化 ( 優先權差異 ) 的實現，請問該如何達成？Ans： 方法一 針對高優先權的 Process 在 Ready queue 中置入多個 PCB pointer 指向此 Process ，使得每一輪當中可以多次取的 CPU 的機會。 方法二 針對高優先權 Process 給予較大的 Quantum。 Multilevel Queues 將原本單一一條 Ready queue 變成多條 Ready queue ，且高低優先權不同。 Queue 之間也有以排班的方式管理，通常採取「Preemptive priority」管理。 每個 Queue 可以有自己的排班法則。 Process 一旦被置入於某個 Queue 中，就不可(不允許)在不同 Ready queue 之間移動。 1527835326994 $Ex. $ I/O - Bound 與 CPU - Bound Job 各自要置入哪種等級的 Queue 比較好？ Ans：I/O - Bound Job \(\Rightarrow\) 高優先 Queue ( 使用 CPU 不多 )；CPU - Bound Job \(\Rightarrow\) 低優先 Queue ( 會使用大量 CPU ) 分析 可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則—Critera ) 的項目眾多，有助於排班設計及效能調校之彈性 ( flexibility )。 不公平。 *有 Starcation。 Preemptive。 Multilevel Feedback Queues 與 Multilevel queue 相似，差別在於「允許」Process 在不同 Queue 之間移動。( 可以採取類似「Aging」的技術或是可以搭配「降級」的方式來避免「Starvation」 ) 分析 可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則—Critera ) 的項目眾多，有助於排班設計及效能調校之彈性 ( flexibility )。 不公平。 可解決 Starcation。 Preemptive。 結論 哪些是 Non-preemptive。 FIFO SJF Non-preemptive priority 哪些是 Preemptive。 SRJF RR Preemptive priority Multilevel (Feedback) queue 哪些沒有 Starvation。 FIFO RR Multilevel feedback queue 那些包含於( \(\subset\) )關係是錯的？ FIFO \(\subset\) Priority SJF \(\subset\) Priority FIFO \(\subset\) RR SJF \(\subset\) RR RR \(\subset\) MFQs (補充) CPU utilization 計算 Modern 版 假設採 RR 排班，令 Time quantum 為 Q、Context switching time 為 S，Process 平均執行每隔 T 時間會發出 I/O-request，求下列狀況的 CPU utilization。 0 &lt; S &lt; T &lt;&lt; Q 所以 \(\frac{T}{T+S}\) 0 &lt; S &lt; Q &lt;&lt; T 所以 \(\frac{Q}{Q+S}\) 0 &lt; S = Q &lt;&lt; T 由上圖可知 \(\frac{Q}{Q+S} = \frac{Q}{Q+Q} = 50 \%\) Q 趨近於 0。 \(\frac{Q}{Q+S} \approx \frac{0}{0+S} = 0\)，CPU utilization 趨近於 0。 恐龍版 ( Ref p. 4-86 Ex.50 ) 10 個 I/O-Bound tasks、1 個 CPU-Bound task，I/O-Bound task 執行每隔 1ms 發出 I/O-request ，每個 I/O 運作花 10 ms ( 此例子有 CPU-Bound task 所以不會因此 Idle )。Context switching time: 0.1 ms，所有process 永遠不會結束，求 CPU utilization ，採 RR 法則。 Quantum = 1ms。針對 I/O-Bound task，在 Time-out 的同時也發出了 I/O-request，接著花 0.1 ms 在 Context switching，所以一個 I/O-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。針對 CPU-Bound task，會將所有 CPU time 用完後 Time-out ，接著花 0.1 ms 在 Context switching，所以一個 CPU-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 1 }{10 \times 1.1 + 1 \times 1.1} = \frac{1}{1.1} \approx 91\%\) Quantum = 10 ms。針對 I/O-Bound task，CPU time 用不完，隔 1 ms 後直接發出 I/O-request ，並也花 0.1 ms 在 Comtext switching 上，所以一個 I/O-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。針對 CPU-Bound task ， 會將所有的 CPU-time 用完後 Time-out 接著花 0.1 ms 在 Context switching ，所以一個 CPU-Bound task 共花了 \(10 + 0.1 = 10.1\) (ms)。\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 10 }{10 \times 1.1 + 1 \times 10.1} = \frac{20}{21.1} \approx 94\%\) 特殊系統之排班設計考量 Multiprocessor system ASMP (Master-Slave 架構)：因為都是以 Master-processor 來排班，類似於過去單顆 CPU，所以沒有特殊的排班設計。 SMP：主要有兩個排班的機制。 方法一： 每個CPU 共享同一個 Ready queue ，當一個 CPU 完程某 Process 後，就去存取 Ready queue。設計重點： 必須提供上述 Ready queue 的互斥存取之機制，若未提供，則可能發生 Process 重複執行，或有 Process 被忽略的錯誤。例：CPU 去取 Process 之工作如下：第一步，取得(read) Queue Front 端 Process 之 PCB pointer；第二步，從 Queue 中刪除此 Process pointer 。 不須考慮附載平衡 (load balance)，因為每個 CPU 在工作都做完時會再繼續從 Ready queue 中挑選工作，不會讓自己閒置(idle)。 方法二：每個 CPU 都有自己的 Ready queue ，每個 CPU 只會檢查自己的 Ready queue ，不會去檢查其他 CPU 的 Ready queue ，有工作就執行，無工作就閒置 (idle)。設計重點： 不須有互斥存取的考量。 需考慮附載平衡 ( Load balanceing )，避免 CPU 之勞務不均 (有人忙、有人閒)。通常使用 2 種機制來調整 CPU 的附載 ( loading )： Push migration ( 移轉 ) — 像是領班、工頭 Pull migration — 好同事 Process affinity 在 multiprocesors system 中，當 Process 已決定某 CPU 上執行，則在他執行過程之中，盡量不要將之移轉到其他 CPUs 上執行，除非有其必要。( 如：Processor bad、Load balancing… )避免 CPU 之 Cache、暫存器的內容要複製且又要刪除該工作，而影響效能。 有兩種 Affinity： Hard-affinity：該 Process 不可移轉。 Soft-affinity：盡可能不移轉。( 若有需要，仍可移轉。) Real-time system 排班設計考量 Hard read-time system 1528098291707 排班設計考量 確認這些工作是否可排程 ( schedulable )？也就是 CPU 可否負荷？判斷公式：若 \(\sum_{i = 1}^n \frac{C_i}{P_i} \leq 1\) 則為可排程，反之為不可排程。其中：\(n\) 表示 Real-time event (Process)之數目、 $C_i$1表示 \(Event_i\) (Process)之所需 CPU time、P_i 表示 \(Event_i\) (Process)之發生週期( Period time )。例：有下列四個 Real-time event ，其 CPU burst time 分別是：20 ms、50 ms、30 ms、X ms。其 period time 分別是 80ms、100ms、300ms、1ms。則在可排程的要求情況下，X 不可超過多少？Ans：\(\frac{20}{80}+\frac{50}{100}+\frac{30}{300}+\frac{X}{1000} \leq 1 \Rightarrow \frac{X}{1000} \leq 0.15 \Rightarrow X \leq 150\) (ms)。 再考慮是否可以滿足各工作的 Dead line。有兩個排班則： Rate-monotonic scheduling EDF ( Eaeliest Deadline First ) 如何排程，以滿足各工作的 deadline？ Rate-monotonic 採取靜態的優先權值且可插隊( Preemptive )。 Period time 愈小，優先權值愈高。 $Ex1. $ Process Period time CPU time P1 50 20 P2 100 35 是否可排程化？ \(\frac{20}{50}+\frac{35}{100}=0.4+0.35=0.75 \leq 1 \Rightarrow\) OK 若規定 P2 優先權高，且為 preemptive，是否滿足 deadline？ 甘特圖 Ratemonotonic P1 未能滿足 deadline，P2 滿足 deadline。 採用 Rate-monotinic 是否滿足 deadline？ Period time 愈小，優先權愈高，所以 P1 的優先權高。 甘特圖 1528099381692 P1 滿足 deadline，P2 滿足 deadline。 $Ex2. $ Process Period time CPU time P1 50 25 P2 80 35 採用 Rate-monotinic 是否滿足 deadline？ Period time 愈小，優先權愈高，所以 P1 的優先權高。 甘特圖 1528099949133 分析： 並不保證可以滿足 deadline。 在靜態的優先權值要求下，是最佳的狀況( optimal )。(若該手法無法滿足 deadline，其他針對靜態優先權值的排班也無法滿足。) Earliest deadline First (EDF) 採用動態優先權值，且為可插隊。 規定 deadline 愈早，優先權愈高。 \(Ex 1.\) Process Period time CPU time P1 50 25 P2 80 35 以 Rate-monotinic 是否不牴觸 Deadline？ P1 的 Period time：50 &lt; P2 的 Period time：80，P1的優先權大於 P2 的優先權。 1528701363468 以 EDF 是否滿足 Deadline？ ﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：80，P1的優先權大於 P2 的優先權。 ﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：80，P2的優先權大於 P1 的優先權。 ﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。 ﹙4﹚ P1 的 Deadline：150 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。 ﹙5﹚ P1 的 Deadline：200 &lt; P2 的 Deadline：240，P1的優先權大於 P2 的優先權。 ﹙6﹚ P1 的 Deadline：250 &lt; P2 的 Deadline：240，P2的優先權大於 P1 的優先權。 ﹙7﹚ P1 的 Deadline：300 &lt; P2 的 Deadline：320，P1的優先權大於 P2 的優先權。 ﹙8﹚ P1 的 Deadline：350 &lt; P2 的 Deadline：400，P1的優先權大於 P2 的優先權。 ﹙8﹚ P1 的 Deadline：400 = P2 的 Deadline：400，P1的優先權等於 P2 的優先權。 1528704009904 \(Ex 2.\) Process Period time CPU time P1 50 25 P2 75 30 以 Rate-monotinic 是否滿足 Deadline？ P1 的 Period time：50 &lt; P2 的 Period time：75，P1的優先權大於 P2 的優先權。 1528704266407 以 EDF 是否滿足 Deadline？ ﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：75，P1的優先權大於 P2 的優先權。 ﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：75，P2的優先權大於 P1 的優先權。 ﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：150，P1的優先權大於 P2 的優先權。 ﹙4﹚ P1 的 Deadline：150 = P2 的 Deadline：150，P1的優先權等於 P2 的優先權。 1528705571205 分析 在可排程的情況之下必 EDF 保證最佳 (optimal)。(任何工作皆不違反 deadline) 理論上，CPU utilization 可達 100%，但實際上不可能達 100% ，因為還要再加上 Context switching、interrupt handling 等額外付擔。 Soft real-time system 就 CPU scheduling design必須要具備： 支援 preemptive-priority 法則。 不支援「Aging」技術。 盡可能降低 kernel dispatch latency time，可得 read-time process 可以即早工作。 降低 lermel latency 的困難處： 大部分的作業桶接不允許 kernel 整在執行 system call 或其他 system processes 時被 user process 任意的插隊 (preemption)，目的是要確保 kernel data structures 的正確性(就是避免有 race condition)，但是這種做法對於 soft real-time system 極為不利。 假設目前 kernel 正在執行一個「long-time」system call ( I/O-operation ) 而此時有一個 soft real-time process 到達(或是 fork())，但是他必須到 kernel 完成此 long-time system call 後才能取得 CPU。(Dispatch latency 太長)。要解決此問題原則是：必須插隊 kernal 且要保障 kernel data structure之正確性。 方法一 - Preemptive point 在 system call code 中加入一些「preemptive point」( 在此時點將 kernel 插隊是安全的 )，將來system call 執行時若遇到 preemptive point，system call 會先暫停 kernel 會檢查此時是否有 real-time process 到達。若有，方才的 kernel system call 會暫停執行， CPU 分派給 real-time process 使用；若無，方才的 kernel system call 繼續執行直到遇見下一個 preemptive point。 Cons：system call 中可以加入的 preemption point 數目不夠多(插入點有限)，Dispatch latency 仍然很長。 方法二 - kernel 可隨時被 real-time process 插隊 需要具備有對於 kernel 的共享 data structure/resource 提供嚴謹的「互斥存取」( synchronization機制 )，以確保資料之正確性。 Cons：使用互斥存取可能造成「優先權反轉 ( Priority inversion )」問題。 Priority inversion - 優先權反轉 高優先權的 process 所需要的共享 data/resourses 恰巧被一些低優先全 process 所把持，無法存取 (因為互斥存取控制)，造成高優先權等待低優先權 process 之情況，再加上低優先權 process 往往無法很快的取得 CPU ，已完成對共享 data/resources 之使用進而釋放資源，所以高優先權 process 被迫要等一段很久的時間。 解決方法：讓低優先權 process 暫時繼承高優先權的權值，使得低優先權 process 可以很快的 取得 CPU 完成共享 data/resource 之使用並釋放資源，同時也立刻恢復其原本的低權值。 Real-time system 之 dipatch latency 的架構 由兩個 phases 組成： Conflict phase Preempts kernel 低優先權釋放高優先權之 data/resource Disoatch phase Context switching Change mode to user mode Jump 1528637800281 Thread management Thread：又稱之為「Lightweight proces」，為作業系統分配 CPU time 之基本單位 (It’s a basic unit of CPU utilization)。( Process 是分配資源如：I/O, memory，的最基本單位 ) Thread 建立後，其私有的內容 ( 紀錄於TCB - thread control block 之中 ) 組成有： Programming counter CPU registers value Stack Thread ID, state … 此外，同一個 process 內之不同 threads 彼此共享此 process 的： Code section Data section Other OS resources (Open files, I/O resources, siginal, …) Code section 與 Data section 合稱為 Memory address space。 Tradition process (Single-thread model) 1528638942439 Multithreading mode 1528639073333 Pros Responsiveness：當 process 內執行中的 thread 被 blocked，則 CPU 可以交給此 process 內其他可執行的 threads 執行，故整個 process 不會被 blocked，仍持續執行，所以若將 multithreading 用在 user-interactive application，可增加對使用者之回應程度。 Resource sharing：因為 process 內之多條 threads 共享此 process code section，所以在同一個 memory space 上可有多個工作同時執行。 Economy：因為同一個 process 內之不同 threads 彼此共享此 process 的 memory 及其他作業系統的資源，所以 thread 之私有成份量少，故 thread 之 creation、context switching 更快、Thread 的管理成本更少。 Scalability (Utilization of multiprocessors Architecture)：可以做到同一個 Process 內之不同 threads 可在不同 CPUs 上平行執行，所以可以增加對 multiprocessors system 之效益(平行程度)提升。 Process VS. Thread Thread Process Light weight Process Heavy weight process Multithreading model Single-threaded model 是作業系統分配資源( Resource )的最基本單位。 是作業系統分配 CPU time 的最基本單位。 不同的 Processes 不會有共享的 Memory 以及其他資源，除非在 shared memory 的情形下。 同一個 process 內之 threads 彼此共享此 process 之 memory 與其他資源。 若 process 內的 single thread 被 blocked，則整個 process 也被 blocked。 只要 process 內尚有可執行的 threads 就不會被 blocked。 process 之 creation、context switching 慢，管理成本高。 process 之 creation、context switching 快，管理成本低。 對於 multiprocessors 架構之效益發揮較差。 對於 multiprocessors 架構之效益發揮較加。 Process 較無 race condition 問題。( 除非是採用「Shared memory」溝通 ) 因為同一個 Process 內之 Thread 彼此共享此 Process data section，所以必須對共享的資料提供互斥存取的機制，防止 Race condition。 適合使用 Multithread 開發的程式。 一個時間點有多個工作要同時執行。如：Client-server model。 不適合使用 Multithread 開發的程式。( 以傳統 process 開發即可 ) 一個時間點最多只有一個工作可執行。如：命令解譯器 ( UNIX 的 Shell )。 User thread and Kernel thread Thread management 的工作 (如：thread creation、thread destory、thread suspend、thread wakeup、thread scheduling、thread context switching) 由誰負責。 User-level Thread Thread management 是由在 User mode 之 thread library 提供的 APIs 以讓 user process 呼叫使用、管理。Kernel 完全不知道( be unknowed with ) user level threads 的存在。(只知道有 process 的 single thread)所以 thread management 不須 kernel 介入干預。 Pros Thread creation、context switching …等管理成本低，速度快。 Cons 當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。) 因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 $Ex. $ 舉凡 Thread liberary 皆是 user threads。 如：POSIX 的 pthread library ( 是只在UNIX、Linux系統上的規格 )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。 Kernel-level thread Thread managemet 完全由 Kernel 負責，kernel 知道每一條 thread 之存在並進行為護理。 ★不需要 Kernel 的任何協助。( With no support from kernel. ) Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 \(Ex .\) 大部分作業系統都支援。 Windows (2000、NT) UNIX、Linux … Solaris [ Modern例題 ]：CPU time 依照分配對象數平均分配 thread，\(P_a\) 有三條 threads ，\(P_b\) 有兩條 threads，則 \(P_a, P_b\) 各分到多少趴的 CPU time。 若全部的執行序皆為 User thread。Kernel 只知道有兩個 Process ，所以分配 CPU time 給\(P_a, P_b\) 各 50%。 若全部的執行序皆為 Kernel thread。Kernel 知道有 5 條執行序要來分配 CPU time，所以 \(P_a\) 分到 60 %，\(P_b\) 分到 40 %。 Multithreading model User thread to Kernel thread Many to one ( User thread ) 1528718261665 1528718722383 This model maps many user threads to one kernel thread. Thread management is done in User space. 與 User thread 一致，不同解釋法。 Pros Thread creation、context switching …等管理成本低，速度快。 Cons 當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。) 因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 $Ex. $ 舉凡 Thread liberary 皆是 user threads。 如：POSIX 的 pthread library ( 是只在UNIX、Linux系統上的規格 )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。 One to one ( Kernel thread ) 1528718998029 1528719859725 This model maps each user threads to a kernel thread. 與 kernal thread 不盡相同。 Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 *Process 每建立一條 User-thread，作業系統就必須配合產生一條 Kernel-thread 與 User-thread 搭配，所以若 User-thread 數產生眾多，則會讓作業系統負擔太大，耗資源大。 \(Ex .\) 大部分作業系統都支援。 Windows (2000、NT) UNIX、Linux … Solaris OS/2 Many to many ( Kernel thread ) 1528719979394 1528720444327 1530181565681 This model maps many user threads to a small or equal number of kernel thread. Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 負擔不和 one-to-one model 大。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 製作、設計較為複雜。 \(Ex .\) Solaris 2 以上 ( Two-level modeling ) 1530181715559 1530182120849 Multithreading issues fork() issue 1530178012484 Child1：適用在「子程序」工作與「父程序」相同時。 Child2：適用於「子程序」與「父程序」不同時，也就是說「子程序」出生後立即呼叫「execl」system call。 Signal delivery issue 1530178614262 Signal 1530178832898 It’s used in UNIX to notify the process that a particular event has occurred. 當 process 收到 siginal 通知後，他必須處理 ( 可交 process 自行處理或交付給 default signal handler kernel 處理 ) Synchronous signal Divide-by-zero Illegal memory access Asynchronous signal 「ctrl - c」 by administrator Time-out by timer Signal Delivery Issue Case 1 ( Ex. Synchronous signal ) Signalisssue Case 2 ( Ex.「Ctrl-break」) 1530179630741 Case 3 1530179857612 Case 4 ( Set a default signal handler. Ex. Solaris ) 1530180057880 Thread pool 在 client-server model 中，當 server 收到 client 的 request 後，server 才建立 thread 以服務此一請求，然而 thread creation 仍需耗用一些時間，所以對 client 的回應不能非常即時，以「Thread pool」解決。Process ( server ) 事先建立一些 threads 置於「thread pool」中，當收到 client 的 request 後，就從「thread pool 」中指派一條可使用的 thread 以服務此請求，不須重新建立 thread ，回應較為即時，當此 thread 完成工作之後，再回到 thread pool 中待命，如果 thread pool 中沒有可用的 thread 則 client 的 request 需要等待。 Cons 萬一 process 事先在 thread pool 中產出過多 threads，對作業系統負擔較大，所以作業系統通常會限制 thread pool 的大小。 Thread 程式追蹤 pthread library 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;int sum; /* this data is shared by the thread(s) */void *runner(void *param); /* threads call this function */int main(int argc, char *argv[]) &#123; pthread_t tid; /* the thread identifier */ pthread_attr_t attr; /* set of thread attributes */ if (argc != 2) &#123; fprintf(stderr,"usage: a.out &lt;integer value&gt;\n"); return -1; &#125; if (atoi(argv[1]) &lt; 0) &#123; fprintf(stderr,"%d must be &gt;= 0\n",atoi(argv[1])); return -1; &#125; /* get the default attributes */ pthread_attr_init(&amp;attr);/* create the thread. 根據 attr 屬性值建立一條 thread，ID 記錄在 tid 中，執行 runner() 副程式*/ pthread_create(&amp;tid, &amp;attr, runner, argv[1]);/* wait for the thread to exit */ pthread_join(tid, NULL); printf("sum = %d\n",sum); // 輸出應為 15&#125;/* The thread will begin control in this function */void *runner(void *param) &#123; //若為 static 變數就為全域共享變數。 int i, upper = atoi(param); sum = 0; for (i = 1; i &lt;= upper; i++) sum += i; /*Thread 終止*/ pthread_exit(0);&#125; 12345678910111213141516171819202122232425#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;types.h&gt;int value = 0;void *runner(void *param); /* the thread */int main(int argc, char *argv[]) &#123; pid_t pid; pthread_t tid; pthread_attr_t attr; pid = fork(); if (pid == 0) &#123; /* child process */ pthread_attr_init(&amp;attr); pthread_create(&amp;tid,&amp;attr,runner,NULL); pthread_join(tid,NULL); printf("CHILD: value = %d",value); /* LINE C -&gt; 5 */ &#125; else if (pid &gt; 0) &#123; /* parent process */ wait(NULL); printf("PARENT: value = %d",value); /* LINE P -&gt; 0 */ &#125;&#125;void *runner(void *param) &#123; value = 5; pthread exit(0);&#125; 問題 Which following is shared by thread ? Static local variable 共享 Program text/executable binary (code section) 共享 Registers value of CPU 私有 Heap memory (code + data scetion memory space) 共享 Programming counter 私有 Stack memory 私有 Open files 共享 I/O-resourses 共享 Local variables 私有 Global variables 共享 參考 Operating Systems: Internals and Design Principles]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Deadlock]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Deadlock%2F</url>
    <content type="text"><![CDATA[Deadlock 系統中存在一組 processes，彼此形成 循環等待 的情況，造成這些 processes 皆無法往下執行，並降低產量 ( throughput ) 的現象。 1530163891325 死結成立的四個必要條件 ( 所以有一個不成立，則死結必不發生，但是若四個條件全部成立時，死結不一定會發生。 )If there are 4 conditions are true, then the deadlock will/can arise. \(\rightarrow\) false/true. Mutual exclusion：對於 Resource 而言，具有此性質的 resource ，在任何時間點最多只允許一個 process 持有/使用，不可多個 processes 同時持有/使用。$Ex. $ 大多數的資源皆具有此性質。如：CPU, memory, disk, printer…$Counter ; Ex. $ Read-only file 不具此性質。 Hold and wait：Process 持有部分的資源，且又在等待其他 processes 所持有的資源。 No preemption：Process 不可以任意剝奪其他 processes 所持有的資源，必須等待對方釋放資源才有機會取得資源。＜Note＞：若可 Preemption 則必無 Deadlock 頂多只有 Starvation。 Circular waiting：系統中存在一組 Processes 形成循環等待之情況。 1530163425234 ＜Note＞1. (恐龍版本)Circular waiting 代表 Hold and wait。2. (其他版本)Circular waiting 代表 Mutual exclusion、Hold and wait、No preemption。3. 為何 Single-process 必不會造成 Deadlock ？ 因為 Circular waiting 不存在，所以 Deadlock 不發生。 交通十字路口 Deadlock 路口：資源 車子：Process deadlock 與 Starvation 比較。 相同之處為都是 資源分配管理機制設計不恰當所導致。 Deadlock Starvation 一組 Processes 形成 Circular waiting ，造成這些 Process 皆無法往下執行。 Process 因為長期無法取得完工所需的各式資源，造成遲遲無法完工。 不可能有機會完工。 有完工的機會，但是機會渺茫、Indefinited block。 會連帶造成 Throughput 低落。 與 Throughput 高低無關聯。(其中 SJF、SRTF 效能示好的。) 一定會在 Non-preemption 的環境下。 容易發生在 Preemption 的環境。 解決方案：Prevention、Avoidance、Detection and recovery。 使用「Aging」技術解決。 Resource allcation graph ( R. A. G. ) 資源分配圖 令 \(G= ＜V, E＞\) 為一有向圖，代表 R.A.G.，其中： Vertex ( 頂點 ) Process 1530164365297 Resource 1530164408843 其中「。」數目代表該項資源的數目。 Edge ( 邊 )： Allocation edge 1530164614789 Request edge 1530164672585 $Ex. $ 1530166364004 結論 No cycle \(\rightarrow\) No deadlock。 Cycle 不一定有 deadlock。 1530166810415 此圖雖然有 Cycle，但因為 P3 必可以完工且會釋出一個 R2 Resource，再配置給 P2 使用，所以無死結。 1530166364004 因為 P4 必可以完工且會釋出 R3 Resource，再配置給 P3 使用，所以無死結。 除非每一類型的資源皆為 single-instance ( 單一數量 )，則有 Cycle 必有死結。 解決 Deadlock Prevention、Avoidance Pros 保證系統為 deadlock free。( 不可能進入「Deadlock state」) Cons 對資源的使用與限制與取得限制多，所以 Resource utilization 偏低，連帶 throughput 偏低。 不可能造成 Starvation。 Detection and Recovery Pros Resource utilization 相對較高， throuput 也較高。 Cons System 可能進入 deadlock state。 Detection and recovery 的成本很高。 Deadlock prevention 破除四個必要條件之其中一個，則死結必不發生。 針對「Mutual exclution」 因為 Resource 本來就有的性質，以致無法解決「Mutual exclution」帶來的問題。 針對「Hold and wait」 方法一：作業系統可以決定除非該 Process 可以一次取得全部所需資源，才允許持有資源，否則不得持有任何資源。 方法二：Process 可先持有部分資源，但當該 Process 要申請其他資源時，必須先釋出所持有的資源，才可以提出申請。 針對「No preemptive」 將該法則改為可強奪( Premptive )，並以優先權作為搶奪基準。( 但可能會造成 Starvation ) Process 持有的資源 欲申請的資源 P1 R1 R3 ( 可以申請 ) P2 R5 R3 ( 必須先釋出 R5 ) P3 R1、R5 R3 (必須先釋出 R5 ) *針對「Circular waiting」 「Resource ordering」：作業系統賦予每一類型資源一個唯一的 Resource ID，再規定 Process 必須按照 Resource ID asending (遞增) 的方式對資源提出申請。 證明「Resource ordering」：假設在這樣的規定下，系統仍存在一組 Processes 形成 Circular waiting 如下圖，依規定，我們可以推導出資源 ID 大小關係如：\(r_0 &lt; r_1 &lt; r_2 \ldots &lt; r_n \quad , r_i \; is \; unique.\)，但又 \(r_0 &lt; r_n &lt; r_0\) ，矛盾，所以 Circular waiting 必不存在。 1530168967415 Deadlock aviodance 當某個 process 提出某些資源申請時，則作業系統必須執行「Banker’s algorithm」以確認倘若分配給 Process 其申請資源後，系統未來是否處於「Safe state」；若為「Saft state」，則核准申請，否則為「Unsafe state」系統會否決該資源申請，Process 必須等一段時間後再重新申請資源，系統會再確認當時的狀態是否安全。 1528970642055 Deadlock 是 Unsafe 集合的 Subset。 Banker’s Algorithm 資料結構 n：Process 個數。 m：Resource 種類數。 \(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\) 提出的各式資源申請量。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Max：n \times m \; matrix \Rightarrow\) 各 Process 完工所需之各式資源最大數量。 \(Need：n \times m matrix = Max - Allocation \Rightarrow\) 各 Process 還需各式資源才能完工。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 1528971381784 演算步驟 確認 \(Request_i \leq Need_i\)若成立進入第二步，否則因為申請不合理導致終止 \(P_i\)。 確認 \(Request_i \leq Available\)若成立進入第三步，否則 \(P_i\) 一直等待直到資源可以使用時。 ( 演算結果 ) \(Allocation_i = Allocation_i + Request_i \quad Need_i = Need_i - Request_i \quad Available = Available - Request_i\) 依照第三步的演算值執行「Safety Algorithm」，若回傳「Saft state」則可以核准該申請，但若回傳「Unsafe state」則核駁該次申請。\(P_i\) 必須等待一段時間再重新提出申請。 Safty algorithm 資料結構 n：Process 個數。 m：Resource 種類數。 \(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\) 提出的各式資源申請量。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Max：n \times m \; matrix \Rightarrow\) 各 Process 完工所需之各式資源最大數量。 \(Need：n \times m matrix = Max - Allocation \Rightarrow\) 各 Process 還需各式資源才能完工。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 \(Work：[1\ldots m] \; of \; int \Rightarrow\) 代表系統目前可用的資源累積數量。 \(Finish：[1\ldots n] \; of \; int\) \(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\False \quad 尚未完工 \end{matrix}\) 演算步驟 設定初值$Work = Availabe Finish[i] ; i, 1 i n ; 設定為 ; false $ 試找一個 \(P_i\) 滿足：\(Finish[i] 為 False\)\(Need_i \leq Work\)若可以找到進入第三步，否則進入第四步。 設定\(Finish[i] = True \quad Work = Work + Allocation_i\)，接著進入第二步。 確認 \(Finish\) 陣列，若全部皆為 True 回傳「Safe state」，否則回傳「Unsafe state」。 Safe sequence / Safe stete 至少可以找出大於一組 「Safe sequence」稱為 Safe state 否則稱為 Unsafe state ，代表作業系統未來依此 Processes 順序可分配各 Process 所需的資源使得大家皆可以順利完工。 實際演練一 5 個 Processes：\(P_0, \ldots, P_4\) 3 種類型的 Resource：\(A, B, C\) 起始資源量：\((A, B, C) = (10, 5, 7)\)求取 \(Need[]\) 與\(Available[]\)\(P_1\) 提出 \((A, B, C) = (1, 0, 2)\) 之資源申請，請問是否予以核准或是核駁，請說明。 1531184487179 1531184825933 Banker’s algorithm \(Request_1 = (1, 0, 2)\) 確認 $ Request_1 (1, 0, 2) Need_1(1, 2, 2)$，OK ( goto step2 )。 確認 $ Request_1 (1, 0, 2) Available(3, 3, 2)$，OK ( goto step3 )。 Safty algorithm。 Safty algorithm Initial value：\(Work = Available = ＜2, 3, 0＞\) 因為可以找到一個 Process \(P_1\) 供應 Resource 並使之得以完成該工作。滿足：\(Finish[1] = False\quad Need_1 \leq Work\)，OK ( goto step3 )。 設定 \(Finish[1] = True \quad Work = Work + Allocation_i\)，goto step2。…在 Step2 不斷重複的尋找是否有 \(P_i\) 尚未完工且目前資源可以予以完工… 最後確認 \(Finish[]\) 全皆為 \(True\) 後回傳「Safe state」。 列出其 Safe sequence \(＜P_1, P_3, P_4, P_0, P_2＞\) 實際演練二 5 個 Processes：\(P_0, \ldots, P_4\) 3 種類型的 Resource：\(A, B, C\) 起始資源量：\((A, B, C) = (10, 5, 7)\)求取 \(Need[]\) 與\(Available[]\)\(P_4\) 提出 \((A, B, C) = (3, 3, 0)\) 之資源申請，請問是否予以核准或是核駁，請說明。 1531184487179 1531184825933 Banker’s algorithm 確認 $ Request_4 (3, 3, 0) Need_4(4, 3, 1)$，OK ( goto step2 )。 確認 $ Request_1 (3, 3, 0) Available(3, 3, 2)$，OK ( goto step3 )。 Safty algorithm。 Safty algorithm Initial value：\(Work = Available = ＜0, 0, 2＞\) 因為不能找到一個 Process \(P_i\) 供應 Resource 並使之得以完成該工作 Fall ( goto step4 )。 最後確認 \(Finish[]\) 非全皆為 \(True\) 後回傳「Not safe state」。 Banker’s algorithm 的 Time complexity 令 n：process 數目、m：resource 種類數。 Step1 需要 \(O(m)\)。(檢查 request 是否大於 need) Step2 需要 \(O(m)\)。(檢查目前剩下資源是否充足可以給予 request) Step3 需要 \(O(m)\)。(若可以給予，將原本的 need、allocation、available) Safty algorithm 的 time complexity。 Safty algorithm 初值設定、每次工作需要 \(O(m)\)、將所有 processes 確認一遍需要 \(O(n)\)。 最多檢查 \(n + (n-1) + (n-2) + \ldots + 1 = \frac{(n+1) \cdot n}{2}\) 個 process 每次檢查 \(Need_i \leq work\) 需要 \(O(m)\) ，加總起來為 $O(n^2 m) $。 使用 $ O(n) $ 確認所有 processes 都做完檢查。 Single-instance resource algorithm 可以化簡較為簡易的 avoidance 檢查方法。 利用 RAG，加上「Claim edge」使用。 1530172024919 clam edge (虛線)：代表 \(P_i\) 未來會對 \(R_j\) 提出申請。(即為 Max/Need 的意義) 演算法 ( 當 \(P_i\) 提出 \(R_j\) 申請 ) 檢查原本有無該宣告邊之存在，若有進入第二步，否則終止 \(P_i\)。 確認 \(R_j\) 是否可供使用，若可以進入第三步，否則 \(P_i\) 等待該資源 ( 由 Claim edge 轉為 Request edge )。 ( 演算結果 ) 暫時將宣告邊改為配置邊( Allocation edge )，進入第四步。 確認途中是否有 Cycle 存在，若無則為「Safe state (核准)」，若有 cycle 為「Unsafe ( 核駁 )」。 \(Ex .\) 1530172534581 若\(P_1\) 對 \(R_2\) 提出申請是否核准？因為沒有 Cycle 存在，所以 Safe 核准申請。 1530172797528 若為 \(P_2\) 對 \(R_2\) 提出申請是否核准？因為有 cycle 存在，所以核駁申請。 1530172966437 ＜Note＞：Deadlock 位於 Unsafe state 的集合之中，也就是說若目前的狀態是 unsafe state 有可能會導致死結，但也有可能不會導致死結。 *＜Theorem＞ Deadlock free 1530173438706 系統若有 n 個 processes、m 個 resources intsance ( 單一種類 )，且滿足下列條件： \(1 \leq Max_i \leq m\) ，單一 Process 不得要求超過該種類資源的上限。 \(\sum_{i = 1}^n Max_i &lt; n + m \Rightarrow \sum_{i = 1}^n Max_i - n &lt; m\) ，假設目前所有的 processes 都剩下一個資源未取得，而剩下的資源小於 m 代表的意思就是 $ m - (_{i = 1}^n Max_i - n ) 1$，代表我們還有至少一個以上的資源可以使某些 processes 可以先結束，接著回收的資源就可以再分配給其他 processes。 則系統是不可能會有死結的 ( Deadlock free )。 \(Ex1 .\) 有 6 部印表機現在正被 Process 使用，每個 process 最多需要 2 部印表機才可以完工，則系統最多允許 幾個 process 執行以確保 Peadlock free ？ m = 6, \(Max_i = 2\)。(1) \(1\leq Max_i \leq m \Rightarrow 1\leq 2 \leq 6\)，OK。(2) \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+6 \Rightarrow n &lt; 6 \Rightarrow\) 最多 5 個 Processes。 $Ex2 . 有 10 部印表機現在正被 Process 使用，每個 process 最多需要 3 部印表機才可以完工，則系統最多允許 幾個 process 執行以確保 Peadlock free ？ \(Max_i = 3, m = 10\)。\(3n &lt; n+10, 2n &lt; 10 \Rightarrow n &lt; 5 \Rightarrow\) \(最多 4 個 \; Processes。\) Proof假設資源全部配置出去即為 \(\sum_{i = 1}^n Allcation_i = m​\)，又 \(\sum_{i = 1}^n Need_i = \sum_{i = 1}^n Max_i - \sum_{i = 1}^n Allocation_i \Rightarrow \sum_{i = 1}^n (Max_i) - m \Rightarrow \sum_{i = 1}^n Max_i = \sum_{i = 1}^n Need_i + m​\)。因為依照定理第二點 \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow \sum_{i = 1}^n Need_i + m &lt; n+m​\)，所以 \(\sum_{i = 1}^n Need_i &lt; n​\)，此式代表至少有大於等於 1 個process 之 Need_i 為 0 代表 Process_i 可以完工，且 P_i 至少會釋出超過 1 個 Resource (因為按照定理第一點可以知道每個 process 只少會占用大於 1 個資源 Max_i 大於等於 1)，使得剩下的 processes 中又會有大於等於 1 個 processes 可以取得資源並完工。 Deadlock detection and recovery 如果放任 Resources 無限制的使用，雖然 Utilization 高，但是系統有可能進入死結而不自知，所以需要有一個死結偵測的演算法以及解決 ( Recovery ) 死結的方法。 Detection ＜Note＞ Avoidance ( Banker’s algorithm ) 含有未來的資訊 (Max, Need)。 Detection 只有目前的資訊 ( Current infomation )。 資料結構 n：Process 個數。 m：Resource 種類數。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 \(Work：[1\ldots m] \; of \; int \Rightarrow\) 代表系統目前可用的資源累積數量。 \(Finish：[1\ldots n] \; of \; int\) \(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\ False \quad 尚未完工 \end{matrix}\) *\(Request：n \times m \; matrix \Rightarrow\) 各 Process 目前對各式資源提出的申請量。 演算法 初值設定\(Work = Available\)，因為目前沒資源的 process 不會導致 deadlock，因為不會有 hold and wait 的問題所以\(Finish[i] = \{\begin{matrix}True \quad if \; Allocation_i = 0 \\ False \quad if \; Allocation_i \neq 0 \end{matrix}\) 試找一個 \(P_i\) 滿足\(Finish[i] = False \; AND \; Request_i \leq Work\)若找到進入第三步，否則進入第四步。 設定 \(Finish[i] = True \quad Work = Work + Allocation_i\)，回到第二步。 確認 \(Finish\) 陣列，若全部皆為 true，而我們可以得知目前沒有死結的可能。否則我們可以得知目前有死結的存在，而且 \(Finish[i] = false\) 的 Process 會陷入該死結之中。 Time complexity \(O(n^2 \cdot m)\)：死結偵測一次的時間需求很高，還要再乘上偵測的頻率，所以總體的成本很可觀。 實際演練一 1531188159444 \(Work = Available (0, 0, 0)\) 可以找到 \(P_0\) 予以 Resource 後可完工且 \(Finish[0] = False\)，\(Request_0 \leq Work\) 前往第三步。 設 \(Finish[0] = True\) ，\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\) 前往第二步。 可以找到 \(P_2\) 予以 Resource 後可完工且 \(Finish[2] = False\)，\(Request_2 \leq Work\) 前往第三步。 設 \(Finish[2] = True\) ，\(Work = Work + (3, 0, 3) = (3, 1, 3)\) 前往第二步。 在不斷的 (2) \(\Leftrightarrow\) (3) 之下，可以再找到 \(P_1, P_3, P_4\) 可以完工進入第四步。 最後確認 \(Finish[]\) 全皆為 \(True\) 後得知目前「Deadlock free」。 實際演練二 1531188115016 \(Work = Available = (0, 0, 0)\) 可以找到 \(P_0\) 予以 Resource 後可完工且 \(Finish[0] = False\)，\(Request_0 \leq Work\) 前往第三步。 設 \(Finish[0] = True\) ，\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\) 前往第二步。 找不到 \(P_i\) 可以利用目前資源完工，進入第四步。 最後確認 \(Finish[]\) 非全皆為 \(True\) 後得知目前有「Deadlock」，而在死結內的程序有 \(P_1, P_2, P_3, P_4\)。 Single instance resource algorithm 令 \(G = ＜V, E＞\) 有向圖代表「Wait-for Graph」，其中1. Vertex：只有 Process 而已，無 Resource 頂點。2. Edge：Wait-for edge。 1530174622303 從 RAG 簡化而成，即為： 1530174725109 1530174756704 較為 Detection 演算法簡單 使用「Wait-for graph」：在「Wait-for graph」中，若有 cycle 存在則目前有死結存在，否則目前無死結存在。 1529287297237 此「Wait-for Graph」有 Cycle，所以有死結存在。 1529287327536 Recovery Kill processes in the deadlock Kill 「all」 processes in the deadlock：先前的工作成果全部作廢，成本太高。 Kill process one by one，刪除一個 process 之後再使用偵測死結演算法，若死結仍存在，再多刪除一個 process。( 因為這種做法需要：O(loop 刪除次數$ $偵測成本 )，時間成本太高不值得 ) Resource preemption (資源剝奪) 選擇受害 Process。 剝奪該 Process 的資源。 回復該受害 Process 當初未被剝奪資源的狀態。(太困難，成本太高也可能會有 Starvation 的問題)]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Deadlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 3]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept-3%2F</url>
    <content type="text"><![CDATA[System Call It’s a programming interface to the services provides by the OS. 定義：幫助執行中的 user process 與 kernel 之間溝通，當 user peocess 需要OS提供某種服務時，會先以 Trap 通知 OS (由 User mode 轉為 Kernel mode) 並傳入System call ID (no.) 及所需參數，接著 OS 執行對應的 System call，完成後將服務結果回傳至 User process。 1526605131439 種類 (Ref P.3-8 ~ 3-9) Process Control：建立、終止、暫停、恢復執行 process，設定/讀取 process attribute。 File Management：建立、讀、寫、開啟、關閉、刪除檔案。 Device Management：讀、寫 Device。 Information of Maintenance：取得系統日期、時間，取得process屬性。 Communications：process之間的通訊，且只針對Massage Passing方式提供服務。 Protection：硬體資源的保護，檔案讀取控制。 System call 的參數(Parameter) 傳遞方式 暫存器( Register )：保存參數於暫存器之中傳遞給作業系統。Pros：簡單、存取速度快( 無記憶體存取 )。Cons：不適用於存取大量參數的情況。 記憶體( Memory )：以一個區塊( Block, Table )儲存這些參數並將此區塊的起始位址存於一個暫存器之中傳遞給作業系統。Pros：適用於大量參數。Cons：存取速度較慢，且操作較為麻煩。 系統堆疊( Stack )：將參數 Push 堆疊之中，作業系統再從堆疊 Pop 取得參數。Pros：也適用大量參數的傳遞，操作也很簡單。Cons：目前無( 可用暫存器或是記憶體實現堆疊 )。 \(Ex. 20\) (Ref P.3-36) 作業系統的架構( Structure ) 分類 Simple More complex than simple Layered approach Microkernel Module Hybrid Simple 無雙重模式( Duel-mode ) 單工 無模組化( Module )的設計 例如：MS-DOS More complex than simple Limited by hard functionality.( 因為當時硬體技術不夠成熟，作業系統受到硬體很大的限制 ) The original UNIX had limited structuring. 例如：UNIX UNIX 包含兩個分開的部分 System Programs Kernel Beyond simple but not fully layered. 1526608163203 Layered approach 1526609224214 定義： 採取 Top-down 的方式切割系統功能/元件以降低複雜度。 元件/模組之間呼叫關係分層，即：上層可以呼叫下層的功能，但下層不得呼叫上層的功能。 使用由 Button-up 的測試、除錯( 防止下層可以呼叫上層 )。 層次( Layer )的劃分沒有明確的規定。 Pros 降低複雜度。 有助於分工。 測試、除錯、維護容易。 Cons 很難精準的劃分層次。例如：\(A \rightarrow_{call} B \rightarrow_{call} C\) 但又因為某些原因必須要設計 \(C \rightarrow_{call} A\)，最後變成 \(A, B, C\) 都在同一層次；解決：將 \(C\) 再拆開分成不同層次(難)。 若層次太多，可能會導致作業系統的效能變差。 ＊Microkernel - 微核心 由卡內基-美隆大學( CMU )率先提出。 代表產品：Mach OS 定義：將 Kernel 中一些不必要的服務移至 User mode 提供服務，以 System program 方式存在，如次一來可以得到一個比較小的 Kernel 。 一般而言，微核心提供下列三個最必要的服務： Process control Memory Management (不包含Virtual memory) Process communications (只提供 massage passing 的服務) 1526610608669 Pros Easier to extend a microkernal. ( 因為服務是在User mode，服務的新增或刪除可以不會改到 Kernel 的架構，相對來說更簡單 ) Easer to port the OS to new archutectures.( 作業系統移植到新的服務平台-cpu不用改太多 ) More reliable. ( 若有一個服務失效時，對 Kernel 的傷害較小 ) More secure. Cons 效能差，因為存在大量的 User mode 與 Kernel mode 的訊息傳遞。 ＜Note＞：相對於微核心的相反\(\rightarrow\)Monolitic kernel。定義：所有的系統服務皆須在 Kernel 執行。( 商用如：Windows \(\Leftrightarrow\) 使用者無法輕易的更改功能 )Pros and Cons 皆與微核心相反。 Module - 模組化 Many OS implement loadable kernel modules. () Use object-oriented approach. Each core component is separate. Each talks to the others over known interface. Each is loadable as needed within the kernel. ( 需要該服務的時候再載入到記憶體執行，不需要時就從記憶體移除 ) Similar to “Layers” but with more flexible.( 效能更好 ) 例如：Linux, Solaris … Pros 因為與 Kernel 傳輸的距離不長，效能比較好。 1526611810996 Hybrid - 混和型 現在的 OS 很難純粹關屬於某一型。 \(Ex.\) Linux and Solaris 是 Monolitic 且也是Moduler for dynamic loading. \(Ex.\) Windows大致上是 Monolitic，有時真針對不同客戶的需求才會對一些子系統再加入Microkernel。 \(Ex.\) Apple Mac OS Kernel Mach microkernal Some of BSD UNIX I/O kit Dynamic loadable module( kernel extension ) 1526613108853 Aqua：負責 GUI 的顯示。 Vritual Machine 1530162737868 定義：利用軟體技術模擬出一份與底層硬體一模一樣的功能介面之抽象化機器( abstract machine )。 1526613748648 名詞解釋 Host：underlying hardware system, OS. ( 原生的硬體與 VMM 都可稱之為 Host ) VMM ( Virtual Macihine Management or Hypervisor )：Creates and managing/runs Virtual machine. ( 可以用硬體或是軟體實現 ) Guest：Process provided with virtual copy of the host. Abstract hardware of a single computer into several different execution environments. Similar to layered approach, but layer creates virtual machine(VM). Pros 為測試開發中的作業系統之良好的負載平台，具有：\(\;^{[1]}\)其他 user, user process 工作時仍可持續運作不須暫停；\(\;^{[2]}\)萬一測試中的作業系統不穩定，就算當機了也不會影響 Host hardware, OS, user procrss 的工作，因為只是相當於一個 user process 失效而已，不會對 system 有重大危害。 同一部 Host hardware 上可以在虛擬機中執行多個作業系統，可節省成本。 Consolidation( 資源的彙整、調度 )：在雲端運算環境時，通常會用有限的機器建立為數眾多的虛擬機，可以依虛擬機上的應用程式( Applications )之執行的負擔輕重調動 Host Machine 資源作為因應的支援。 較為安全，若被病毒入侵不至於擴散。( 虛擬機之間是獨立的個體 ) 可以 Freeze, Suspend, Running 及 Clone 虛擬機。 1526615255622 1526615230230 VMM的實現 主流 主要以模擬與底層一模一樣的環境(如 cpu)給作業系統使用，有分成下列三種模擬方式。 Type 0 Hypervisor ( Hardware ) Hardware - based solutions via firmware. Ex. IBM LPARS and Oracle LDOMs. Type 1 Hypervisor ( Kernel mode ) OS-like software. Ex. VMware ESX, Joyent SmartOS, Citrix XenServer. General purpose OS that provide VMM functions( Serveices ). Ex. MicroSoft Window Server with HyperV, Redhat Linux with KVM. Type 2 Hypervisor ( User mode ) Applications level provides VMM functionally. Ex. Parallel Desktop, Oracle VirtualBox. 非主流 所實現出來的 VM 不等同於 host 的硬體環境。 Paravirtualization The guest OS need modify to work in cooperator with VMM to optimize performance Preseents guest with similars but not identical to host hardware. (指模擬出常用的機器指令，將少用的指令移除以達到 VM最佳化) Guest must be modified to run on paravirtualization hardware. Application containment ( 創造一個執行環境 ) Oralcle Soaris Zones, BSD Jails IBM AIX WPARs. 1526804733939 Programming - environment virtualization VMMs do not virtualize real hardware but instand create an optimized virtual system. Ex. Java Virtual Machine (JVM) Microsoft.Net ＜Note＞：JVM is a specification (規格) , not a implementation. 其中規範有：\(^{[1]}\)Class Loader, \(^{[2]}\) Class Verifier, \(^{[3]}\) Java Interpreter. Emulator - 模擬器 ( 不同架構的cpu使用模擬器做轉換 ) Allow application writtem for one hardware to run on a very different hardware such as different type of cpu. Policy and Mechanism Policy 定義：“What” to be provided&quot; Policy 會經常改變。 Mechanism 定義：“How” to do that 「The underlying mechanism」甚少改變或不變。 設計原則 Policy and mechanism 最好分開設計，以增進系統的彈性( Flexibility )。 $Ex1. $ Mechanism：運用 Timer 幫助 cpu protection。 Policy：Max time Quantum 的大小制定。 $Ex2. $ Mechanism：cpu 排班採優先權高低。 Policy：優先權高低的定義。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 2]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept-2%2F</url>
    <content type="text"><![CDATA[基礎觀念 - Basic Concept (貳) 機器指令 Stage (階段) 1526805202151 IF：Instruction Fetch ID：Instruction Decode FO：Fetch Operands EXE：Execution WM：Write Result to Memory CPU 會 Memory Access DMA 要用 Memory IF 必用 Conflict ID 不使用 OK FO 可能使用 OK or conflict EXE 不使用 OK WM 可能使用 OK or conflict (P.3 - 66) (原文書 I/O Subsystem P. 596) DMA 之六個步驟： 1526805611478 Life cycle of I/O request (via Tnterrupted I/O) (P.3-65) (原文書P.612) 1526806092878 Blocking I/O and Nonblocking I/O Blocking - I/O：Process suspended until I/O completed. Pros：Easy to use and understand.(撰寫維護簡單，明確的知道什麼user program 需求。) Cons：Insufficient for some needs.(當要載入一個大的影片檔，要等到所有的資料載完才feedback給使用者，會導致使用者體驗不好) Synchronous-I/O 也就是 Blocking I/O Nonblocking I/O：I/O calls return as much as available.(控制權在交付 I/O 的需求後馬上還給user process) Eg：user interface, data copy (Buffer I/O). Implemented via multithreading. Returned quickly with count of bytes read or written.(回傳目前一定的量給 process) 有多少的 I/O 的資料完成就傳回多少資料。 Asynchronous - I/O (屬於Nonblocking I/O 的一步分)：Process runs while I/O executes. Difficult to use. I/O subsystem signal process when I/O - completed. 要完整的將整個 I/O 完成才將資料回傳。 1526807435082 Intruupt 機制與種類 當 interrupt 發生，OS之處理如下： OS 收到中斷後，若中斷是必須要被立即處理的，則OS會暫停目前的 Process 之執行，且保存其Status and register comtents。 OS會依據 interupt ID ( No. ) 查詢Interrupt Vector確認何種中斷發生，且找出其 ISR 的位置。 Jump to ISR位置，執行ISR。 ISR完成後，控制權返回kernel。 OS 會恢復( resume ) 中斷之前 process 的進行。 1526808564478 interrupt 種類 分類一 ( 分三種 ) External interrupt：cpu以外的周邊設備、控制卡…等所引起。例如：I/O completed, I/O - error, machine-check…。 Internel interrupt：CPU 在執行程式過程中，遭遇重大錯誤而引發。(通常優先權最高)。例如：Divide-by-zero, 執行非法的特權指令 … 。 Software interrupt：User process在執行之中，若需要OS提供服務時，必須發出此類中斷，目的是通知OS執行對應的服務請求。例如：I/O-request …。 分類二 Interrupt：Hardware-generated change control flow.例如：設備發出 I/O-completed, I/O-error, machine-check…以及Timer(cpu排班、cpu保護的硬體)發出的time-out Trap：Software-generated interrupt.Catch the arithematic error。利如：divide-by-zerp, 執行非法指令, 非法記憶體存取…user process 需要OS提供服務時，也會發trap通知OS。例如：I/O-request。 分類三：以中斷的優先權高低分類。 Maskable (可遮罩) interrupt：此類中斷發生後，可被忽略或延後處理，也就是說不一定要馬上處理。例如 Software interrupt (優先權低) Non-maskable (不可遮罩) interrput：此類中斷必須立刻處理。例如：internal interrupt (重大錯誤), I/O-error, …。 Hardware Resource Protection 建設基礎的保護 1526808604540 Dual mode operation - 雙重模式 定義：作業系統的運作模式只少要可被區分為兩種模式。 Kernel mode (又稱為 supervisor mode, system mode , privileged mode, monitor mode)：代表此刻是kernel取得系統控制權(i.e. 取得 cpu 執行)，且允許使用特權( privileged )指令 User mode：代表User process取得 cpu 執行，且不允許執行指令。 ＜Note＞：Duel-mode必須要有hardware的支持才可以實現。例如：cpu內會有mode bit用以區分現在的mode為何。 Privileged intrustions - 特權指令 定義：任何可能會造成系統重大危害的指令，可設為特權指令。只可以在kernel mode下執行，不得在user mode 下執行，一旦在user mode執行會發出trap 通知OS，OS通常會終止(terminate)該process。 包含： I/O instruction (for I/Oprotection) Clear memory 關於memory management(保護)所用之Register修改指令(base、limit register) Timer設定指令：set, change (for cpu protection) Enable, Disable Interrupt指令 Halt指令 change user mode to kernel mode指令 \(Ex.33\) (Ref P.3-42) 以下哪些是特權指令？ (1)(3)(4)(5)(1) Set value of Timer(2) Read the clock(3) Clear Memory(4) Turn-off interrupt(5) Switch from user to kernel mode \(Ex.34\)以下哪些是必要的特權指令，且讓使用者程式能最方便且兼顧安全？ (2)(3)(4)(5)(7)(1) Change to user mode ＊原本就是user mode，所以使用也沒差。(2) Change to monitor mode※(3) Read from monitor memory(4) Write to monitor memory※(5) Fetch an instruction from monitor memory(6) Turn on timer interrupt ＊本來就開啟，所以再開啟也沒關係。(7) Turn off timer interrupt I/O Protection 目的：由於I/O運作較為繁瑣複雜，為了降低 user process 操控 I/O之複雜度及避免 user process 對 I/O-Device 之不當操作。 作法：把所有的I/O指令都設為特權指令，再藉由Duel-mode，一律讓user process委託kernel 執行I/O運作。 Memory Protection 目的：防止user process存取其他 user process 之記憶體空間以及kernel的記憶體空間。(防止非法的記憶體的存取) 作法：(以 contiguous memory allocation 為例)針對每個process , kernel會提供一套Base registers 與 Limit registers。其中Base registers 紀錄 process 在記憶體中的起始位址，Limit registers 紀錄 process 在記憶體中的大小。 1526809058649 ＜Note＞：其中檢查是否逾越記憶體位置是交由硬體檢查(MMU, Memory management unit)。(因為記憶體讀取是很頻繁的，若交由軟體檢查是否逾越則會導致中斷太多而讓效能低落) ＜Note＞：Base / Limit register 的設定修改必為特權指令。 CPU Protection 目的：防止user process 無限期/長期佔用 CPU 而不釋放。 作法：利用硬體 Timer 實施保護，同時，OS會規定process使用 cpu time 之最大配額(max time quantum)，當process取得cpu之後time初值即設為max time quantum 值，隨著 process 執行時間增加，timer 值會逐步遞減值到timer 為 0 時會一同發出「Time-out interrupt」以通知 OS 強迫該process 放掉cpu。 ＜Note＞：Timer 的設定與修改必為特權指令。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 1]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept%2F</url>
    <content type="text"><![CDATA[基礎觀念 - Basic Concept (壹) 機器種類 - Machine type Bare Machine(裸機) 只有Hardware Components所組成(eg. CPU, memory, I/O device)，沒有任何輔助使用者 ( User ) 的系統程式 ( System Program )存在。 Extended Machine 以 Bare Machine 為底加上輔助使用者的系統程式 - System Programs (eg. OS, Compiler, DBMS…)，即構成延伸機器。 CPU 的等待時間( Idle time ) 人類手動操作對於 CPU time 太慢。 以「Automatic Job Sequence」的軟體常駐於在早期的電腦上，利用少量的記憶體執行非常駐於的電腦上的軟體，類似於現今的作業系統，稱之為「Resident Monitor」。 I/O 裝置的工作速度遠比 CPU 的工作速度還慢，CPU 針對某些工作必須等待 I/O 工作完成後才能繼續執行，所以造成 CPU 等待時間 ( idle time ) 太久。 以較快速的裝置介入 CPU 與 I/O 裝置之間作為緩衝。 脫機 (Off-line 非即時運作 I/O) 1529920981306 不及時的將 CPU 演算完的資料給予讀取或是列印，利用專門的外圍控制機，將低速 I/O 設備上的數據傳送到高速磁碟 ( 磁帶 ) 上；或者相反，CPU 直接對於磁帶讀寫，使電腦加快讀取的速度。 以磁帶機緩解讀卡機( Input )與印表機( Output )造成過慢的等待( idle )：電腦中間以磁帶機的方式加速與讀卡機與印表機的溝通( 讀卡機與印表機不直接由 CPU 直接操作 )。 磁帶機實作 以專用的 I/O 裝置對於磁帶讀寫。( CPU 直接控制 ) 以一個小型的子電腦對於磁帶讀寫，習慣稱之為衛星機( salellite processing )，主要負責磁帶拷貝的工作，CPU 不直接參與磁帶機的讀寫運作。 Pros CPU 不受到讀卡機或是印表機的速度限制( CPU 受到磁碟機的速度限制 )。 已寫好的程式不必更動，只要把原本直接交付給裝置執行的指令存入磁帶中再給該裝置執行。 裝置獨立性( Device Independent )：泛指同一程式可以在不同的 I/O 裝置上執行的能力。 Cons 因為要先讓電腦先將指令載入至磁帶，再交由該機器執行，導致設定時間需求長。 磁帶只能以循序讀取( Sequential Acess )的方式讀寫。 緩衝區 ( Buffering ) 用以實現 CPU 能與 I/O 同時運作。可以想像成有一個超強者( CPU )，但是要跟一對弱者( I/O device )合作，是必要強者等待弱者將事情做完再交付給強者執行，而強者若要等到某一位弱者執行完後再執行太沒效率了，所以強者準備一個空間( 緩衝區 )給弱者將作完的工作丟入，再來就交由強者以不同策略使用緩衝區的資料達到最佳化。 I/O Bound Job 因為需要大量的 I/O 工作，速度受限於 I/O 裝置速度。 CPU Bound Job 因為需要大量的 CPU 計算，速度受限於 CPU 的處理速度。 假脫機線上同時周邊處理技術( Simultaneous Peripheral Operation On-Line, SPOOL ) 又稱為排隊緩存技術。當系統中引入了多道程序技術( Multiprocess )後，完全可以利用其中的一道程序，來模擬脫機輸入時的外圍控制機功能，把低速 I/O 設備上的數據傳送到高速磁碟上；再用另一道程序來模擬脫機( Off-line )輸出時外圍控制機的功能，把數據從磁碟傳送到低速輸出設備上。這樣，便可在主機的直接控制( On-line )下實現脫機輸入、輸出功能。 1529918563313 外圍操作與 CPU 對數據的處理可以同時進行。 SPOOL 的需求 建立在具有多程序( Multiprocess )功能的作業系統。 高速隨機外存。( 磁碟存儲技術 ) 組成 井：在磁碟上開闢的兩個大存儲空間。輸入井：模擬脫機輸入時的磁碟設備，用於暫存I/O 設備輸入的數據。輸出井：模擬脫機輸出時的磁碟，用於暫存用戶程序的輸出數據。 緩衝區：為了緩解 CPU 和磁碟之間速度不匹配的矛盾，在內存( RAM )中要開闢兩個緩衝區。輸入緩衝區：暫存由輸入設備送來的數據，一旦緩衝區要滿出來了，再傳送到輸入井。輸出緩衝區：暫存從輸出井送來的數據，往後再傳送給輸出設備。 「輸入程序 \(SP_i\) 」 和「輸出程序 \(SP_o\)」。這裡利用兩個進程來模擬脫機 I/O 時的外圍控制機。「程序 \(SP_i\)」：模擬脫機輸入時的外圍控制機，將用戶要求的數據從輸入機通過輸入緩衝區再送到輸入井，當CPU 需要輸入數據時，直接從輸入井讀入內存。「程序 \(SP_o\)」模擬脫機輸出時的外圍控制機，把用戶要求輸出的數據先從內存送到輸出井，待輸出設備空閒時，再將輸出井中的數據經過輸出緩衝區送到輸出設備上。 達到共享 I/O 裝置的目的。 印表機( 獨占設備 )：當用戶進程請求列印輸出時，SPOOLing系統同意為它列印輸出，但並不真正立即把印表機分配給該用戶進程，而只為它做兩件事：1. 由「輸出程序」在輸出井中為之申請一個空閒磁碟塊區，並將要列印的數據送入其中。2. 「輸出程序」再為用戶程序申請一張空白的用戶請求列印表，並將用戶的列印要求填入其中，再將該表掛到請求列印隊列上。如果還有進程要求列印輸出，系統仍可接受該請求，也同樣為該進程做上述兩件事。如果印表機空閒，輸出進程將從請求列印隊列的隊首取出一張請求列印表，根據表中的要求將要列印的數據，從輸出井傳送到內存緩衝區，再由印表機進行列印。列印完後，輸出進程再查看請求列印隊列中是否還有等待列印的請求表。若有，又取出隊列中的第一張表，並根據其中的要求進行列印，如此下去，直至請求列印隊列為空，輸出進程才將自己阻塞( Blocked )起來。僅當下次再有列印請求時，輸出進程才被喚醒( Wake up )。 Pros 提高 I/O 的速度：從對低速 I/O 設備進行操作，演變為對輸入井或輸出井中數據的存取，如同脫機輸入輸出一樣，提高了I/O 速度，緩解了 CPU 與 I/O 設備之間速度不匹配的矛盾。 將獨占設備視為為共享設備：SPOOLing 系統中，實際上並沒為任何進程分配設備，而只是在輸入井或輸出井中為進程分配一個存儲區和建立一張I/O 請求表。 實現了虛擬設備功能：宏觀上，雖然是多個程序在同時使用一台獨占設備，而對於每一個程序會認為自己獨占了一個設備( 邏輯上的設備 )。SPOOLing 系統實現了將獨占設備變換為若干台對應的邏輯設備的功能。 ＜Note＞：Spool 與 Buffer 的差異性。 Spool 允許有程序在執行 CPU 運算時，可以有其他的程序的 I/O 運算同時進行( overlay execution ) Buffer 允許有程序執行 CPU 運算時同時運算( overlay execution )該程序的 I/O 運算。 系統種類 - System Type 多元程序系統 - Multiprogramming System 允許系統 ( 或在記憶體 ) 中存在多個 Process ( 處理程序 ) 同時執行。透過 CPU Scheduling 技術，當某個 Process 取得 CPU 執行時，若因為某些事件發生 ( 如：Wait for I/O completed 、Resource Not Available… ) 而無法往下執行時，作業系統可將 CPU 切換給其他 Process 使用，則CPU在各個 Processes 切換，可以使 CPU 總是為忙碌的狀態( Busy )。 主要用於避免 CPU 的空等( idle )，提高 CPU 效能( Utilization )。 Multiprogramming Degree： 系統中存在執行的 Process 個數。 通常 Multiprogramming Degree 越高，且非為 Thrashing 狀態，則 CPU 效能越高。 多個 Process 同時執行的方法： Concurrent ( 並行 )：一個 CPU，多個 Processes 共同使用。 Parallel ( 平行 )：多核心 CPU 共同執行多個 Processes。 分時系統 - Time Sharing System It’s a logical extension of multiprogramming system, the CPU in this kind of system switch highly frequently. Multiprogramming 的一種，又可以稱為「Multitasking」。＜Note＞：與 Multiprogramming 的差異在於 CPU 切換的頻率極高。 排班使用「RR(Round-Robin) 法則」：作業系統規定一個 CPU Time Quantum ( 區段 )，若 Process 在取得CPU後，未能於區段內完成工作，則必須被迫放棄CPU，等待下一次輪迴。 通常 Quantum 時間很短。( 小於 1 秒 ) 對每個使用者 ( 程序 ) 是公平的。 適用在User Interactive System ( 互動式作業系統 ) 或 Response Time ( 反應時間 )要求較短的系統。 透過 Resource Sharing 技術 (如：CPU資源 - CPU scheduling、記憶體資源 - Memory sharing、I/O 裝置資源 - Spooling )，使得每個使用者 ( 程序 ) 皆認為享有專屬的資源。 Virtual Memory 技術，擴展邏輯的記憶體空間 ( Virtual Memory Space )。 1530091014614 分散式系統 - Distributed System 多處理器系統 - Multiprocessors System ( 緊密耦合 - Tightly Coupled ) 又稱為 Mulitprocessing、Parallel system。 在一台機器 ( 或是在主機板 ) 中，具有多顆 CPUs ( 或是 Processors )。 共享此機器的資源：1. Memory2. Bus3. I/O - Devices4. Power supplier 通常聽從同一個時脈器 ( Clock )。 通常由通一個作業系統管理。 CPUs 溝通藉由「共享記憶體 - Shared memory」的方式完成。 可以進行平行運算 ( Parallel computing )。 Pros 增加吞吐量 ( Throughput )：可以使多個程序在不同的 CPUs 上執行 ( Parallel computing )。＜Note＞：「 N 個 CPUs 之產能」&lt;&lt;「一個有 N 倍 CPU 的產能」，因為會有問題存在使得產能抵銷：1. Resource contention - 資源競爭。2. Processor 之間的 communication。 增加可靠度 ( Reliability )：若有一個 CPUs 在執行時失效，然而還有其餘的 CPUs 可以繼續執行，使得系統不會因此停頓。＜Note＞1. Graceful degradation ( 漸進式滅亡 )：又稱為「Fail - soft」，系統不會因為某些硬體或是軟體元件故障而停頓，仍然保持運作的能力。2. Faild - Tolerent system ( 容錯系統 )：具有「Graceful degradation」特性的系統。 提升運算的經濟效益 ( Economy of scale )：因為「N 個 CPUs 在同一部機器」可共享該機器的資源 ( Memory、Bus、I/O - devices … ) ，所以較於「N 部機器」更為便宜而寫有效率。 1530093944139 Symmtric Multiprocessor - SMP 每個 Processors 的工作能力是相同的 ( Identical )，並且每個 Processors 皆有對等的權利存取資源。 Pros 可靠度較為 ASMP 高。 效能較高。 Cons SMP 的作業系統開發互斥存取的機制，使得設計較為複雜。 Asymmtric Multiprocessor - ASMP ASMP_2 每個 Processors 的工作能力不盡相同，通常採取「Master-Slave ( Boss-Employee )」架構。Master Processor 負責工作分派、資源分配與監督 Slave Processor 等管理工作，其餘的 Slave Processors 負責執行工作。 Pros 因為與開發「Single - CPU」的作業系統相似，所以相較為簡單。 Cons 可靠度較為 SMP 低。 由於 Master Procrssor 是效能的瓶頸，所以效能較低。 「Multiprocessor」 V.S 「Multicore Processor」 依作業系統的設計觀點是沒有差異的。( 將一個 Core 視為一個 logical CPU 資源 ) $Ex. $ 主機板中有 4 顆 Duel-core CPUs ，對於作業系統來說，視為 \(4 \times 2 = 8\) 個 CPUs 可以使用。 Multiprocessor 1530099598137 Multicore Processor Pros1. Power Saving2. 因為在同一個晶片之內，傳輸的速度較快。 multicore 分散式系統 - Distributed System 又稱為「Loosely-Coupled system ( 鬆散耦合系統 )」。 多部機器彼此透過網路( Network )、Bus 的方式相互串聯。 每部機器之 CPU 都有各個自有的 Memory、Bus、I/O-device … ，且並不共享，Clock time 也不盡相同。 每部機器的作業系統也不盡相同。 溝通採用「Message Passing」的方式。 建立連線 ( Communication Link )。 Message 相互傳輸。 釋放連結 ( Link )。 實現「Client - Server Computing Model」 Server：提供服務的機器。$Ex. $ Mail server、File server、DNS、Printer server、Computing server…。 Client：本身不提供服務，當需要某項服務時，向對應的 Server 發出請求，當 Server 服務完成，再將結果回傳至 Client。 ＜Note＞：「Peer-to-Peer Model」Peer：同時具有 Server 與 Client 的角色。 用以實現「Remote site communication」 $Ex. $ 透過網際網路可以實現 Email、FTP。 Pros Computation speed up - 增加吞吐量 ( Throughput )： 增加可靠度 ( Reliability )： Resource Sharing - 提升運算的經濟效益 ( Economy of scale )：所以成本低。 即時系統 - Real-time System Hard Real-time System 1530103496272 This system must ensure the critical task completed on time. 工作必須要再規定的時間內完成，否則會有重大危害的狀況發生。 設計考量： 所有時間延遲之因素皆須納入考量( 如：感測器資料傳輸速度、運算速度、Signal 傳輸速度… )，並且確保這些時間加總能在 Deadline 前做完。 所有會造成時間過久或無法預測之設備或機制，最好少用或不要使用。$Ex. $ 磁碟 ( Disk ) 最好少用或不用、虛擬記憶體 ( Virtual Memory ) 絕不使用。 針對 CPU 排班的設計，需要先考量是否可排程化 ( Schedulable )，在進行排程規劃 ( 如：Rate-monotonic、EDF scheduling )。 Time sharing system 無法與 Hard real-time system 並存。 現行的商用作業系統不支援 Hard Real-time 的特性。( 通常保留於客製化的作業系統之中。 ) 作業系統造成的「Dispatch latency」要盡量降低。 ＜Note＞：一般實務上，Hard Real-time System 少有作業系統的存在。 應用於：軍事防衛系統、核能安控系統、工廠自動化生產、機器人控制 …。 Soft Real-time System This system must ensure the real-time process get the highest priority than the others and retain this priority level until it completed. 應用於：Multimedia system、Simulation system、VR system …。 針對 CPU 排班的設計 必須支持「Preemptive priority scheduling - 可插隊排程」。 不可提供「Aging」功能。 儘量降低核心 ( kernel ) 的 Dispatch latency time。 可支援 Virtual memory，但是要求 Real-time processes 的全部 pages 在完工前，必須置於記憶體之中。 可以與「Time-sharing system」並存。 $Ex. $ Solaris。 一般商用作業系統皆支持 Soft real-time system 的功能。 批次系統 - Batch system 將一些較不緊急、定期性、非交談互動性 ( non-interactive ) 的工作，累積成堆，再分批送入系統處理。 主要目的：提高資源的利用度 ( Resource utilization ) 利用冷門時段的時間批次將工作送入執行。 不適合用於 Real-time system、User-interactive application。 $Ex. $ 庫存盤點、報稅、掃毒、磁碟重組、清算系統 …。 掌上型系統 - Hand Held System $Ex. $ PDA、Smartphone (智慧型手機)、PAD (平板) …。 硬體天生的限制會導致軟體必須配合的功能。 硬體限制 軟體應對設計 因為電源供應、散熱不易所以閹割處理器的性能 運算量宜簡單 記憶體有限 程式量宜小，並且要適當的管理記憶體，將不用的記憶體立刻釋放。 顯示器很小 ( 解析度、長寬比 ) 顯示內容精簡化 ( 手機網站須有所刪減 ) I/O 運作方式 詢問式 I/O - Polling I/O 又稱為 Busy-waitting I/O or programmed I/O 。 操作流程 User process 發出 I/O 要求給作業系統。 作業系統收到請求後，( 有可能 )會暫停目前此 process 的執行，並執行對應的 System calls。 Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。 裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。 裝置控制器起動，監督 I/O 設備的運作進行， 在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。 但是 CPU 在執行 Process 工作的過程中，卻要不斷去 Polling 裝置控制器以確保 I/O 運作是否完成或有 I/O-Error。 Cons CPU 耗費大量時間用於 Polling I/O 裝置控制器上，並未全用於 Process 執行，所以 CPU 的效能 ( Utilization ) 低，產量 ( Throughput ) 低。 1530157733165 中斷式 I/O - Interrupted I/O 操作流程 User process 發出 I/O 要求給作業系統。 作業系統收到請求後，( 有可能 )會暫停目前此 process 的執行，並執行對應的 System calls。 Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。 裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。 裝置控制器起動，監督 I/O 設備的運作進行， 在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。 當 I/O 運作完成，裝置控制器會發出「I/O-completed」的中斷 ( Interrupt ) 通知作業系統 ( CPU )。 作業系統收到中斷後 ( 可能 ) 會先暫停目前 Process 的執行。 作業系統必須查詢「Interrupt Vector ( 中斷向量表 )」，確認是何種中斷發生，同時也要找到該中斷之服務處理程式的位置 ( ISR：Interrupt service routine )。 跳至 ISR 位置並執行 ISR。 ISR 完成後，交還使用權給 Kernel，Kernel 可能會作通知的動作給 User process。 恢復 ( Resume ) 原先中斷前的中作執行 ( 或交由 CPU 排程器決定 )。 Pros CPU 不需耗費時間用於 Polling I/O 裝置上，而是可以用於 Process 執行上，所以 CPU 效能 ( Utilization ) 提升、產量 ( Throughput ) 提升。 Cons 中斷 ( Interrupt ) 處理仍需耗費 CPU 的工作時間。 ＜Note＞：若「I/O 運作的時間」&lt;「中斷處理時間」，則使用中斷 I/O 就不是一個好選擇，因此 Polling 還是有其存在必要性。 若中斷發生的頻率太高，則大量的中段處理會占用幾乎全部的 CPU 工作時間，導致系統效能很差。 CPU 仍需耗費一些時間用於監督 I/O 裝置與記憶體之間的「資料傳輸」過程。 1530159007395 DMA (Direct Memory Access) I/O DMA-controller 負責 I/O 裝製與記憶體之間的資料傳輸工作，過程中無須 CPU 5 參與監督，所以讓 CPU 有更多時間用於 Process 執行上。 Pros CPU 效能 ( Utilization ) 更高。 適合用在「Block-transfer oriented I/O-device」上 ( 因為中斷發生頻率不至於過高 )，如：Disk。＜Note＞：不適合用在「Byte-transfer oriented I/O-device」。 Cons 因為 DMA 控制器( controller ) 會與 CPU 競爭記憶體與 Bus 的使用權，當控制器占用記憶體或是Bus時，CPU 要被迫等待，所以引進 DMA 控制器增加硬體設計的複雜度。 DMA controller 通常採用「Cycle stealing (Interleaving)」技術，與 CPU 輪替使用記憶體以及 Bus，若 CPU 與 DMA controller 發生衝突 ( conflict：同時要使用記憶體或 Bus )，則會給予 DMA 較高的優先權。 通常系統會給予「對該資源需求量頻率較小」的對象有較高的優先權，可以使得1. 平均等待時間較小。2. 平均產能較高。 參考 SPOOLing技術]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F19%2FDijkstra-algorithm%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344Graph&#123; set&lt;int&gt; V map&lt;int, map&lt;int, int&gt;&gt; E;&#125;Graph g;Graph sp;bool check[MAXN];int cost[MAXN];Node &#123; int id; int value; bool operator&lt;( const Node r ) &#123; return value&lt;r.value; &#125;&#125;void dijkstra (int s, int e) &#123; priority_queue&lt;Node, vecotr&lt;Node&gt;, greater&lt;Node&gt;&gt; pq; Node start; start.id = s; start.value = 0; pq.push_back(start); int last = -1; for(int i = 0; i &lt; MAXN; i++) &#123; cost[i] = INT_MAX; &#125; while(!pq.empty()) &#123; Node tmp = pq.top(); pq.pop(); if(check[tmp.id]) continus; check[tmp.id] = true; if(last!=-1) &#123; sp.V.push_back(tmp.id); sp.V.push_back(last); sp.V.E[tmp.id][last] = g.V.E[tmp.id][last]; sp.V.E[last][tmp.id] = g.V.E[last][tmp.id]; &#125; if(tmp.id==e) break; for(auto it: g[tmp.id]) &#123; if(!chcek[it.first]) &#123; if( tmp+it.second&lt;cost[it.first] ) &#123; Node tmpi = &#123;it.first, tmp+it.second&#125;; cost[it.first] = tmp+it.second; pq.push_back(tmpi); &#125; &#125; &#125; last = it.first; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[KNN and Radial Basis Function - K近鄰算法 與 放射狀基底函數網路]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F13%2FKNN-and-Radial-Basis-Function-K%E8%BF%91%E9%84%B0%E7%AE%97%E6%B3%95-%E8%88%87-%E6%94%BE%E5%B0%84%E7%8B%80%E5%9F%BA%E5%BA%95%E5%87%BD%E6%95%B8%E7%B6%B2%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前言機器學習分兩大類 Eager alogorithm(積極) 性質 將歷史資料做了很多分析與篩選( Munge )等預處理。 因為訓練出的假說很明確( Explicit )，所以自然判斷也比起 Lazy 方法更迅速。 \(Ex.\) Artifitial neural network Decision tree Lazy algorithm(被動) 性質 簡單的處理訓練資料，不會將資料轉成其他方式表達，所以資料不會因為處理過後而喪失一些屬性。 這種訓練方法在「判斷」未知案例時，因為要做的比對處理比較多，比起利用歷史資料先處理的 Eager算法需時更長。 因為這種方法是將資料做區域化的處理( Localized )，所以每次判斷全域( Generalization )時都要重新花一次時間。 \(Ex.\) KNN KNN and Radial Basis Function Instance-based Learning 以先前的案例( 未做處理或修飾的 )建立假說空間。 重點 概念 只有將先前的案例完整的儲存起來，不要有任何的修飾或是處理。 \[&lt;x_i, f(x_i)&gt;\] 最近鄰法 ( Nearest neighbor ) 給定一個要判斷的案例 \(x_q\)，接者我們在該案例空間中找到一個最靠近的先前案例以猜測之。 \(\hat{f}(x_q) \leftarrow f(x_{Nearest \; neighbor})\) 近 \(K\) 鄰法 ( KNN ) 給定一個要判斷的案例 \(x_q\)，接著我們在近 \(K\) 個鄰居之中做多數決選擇法。 ( 當目標結果 Target function 是離散值時 ) 給定一個要判斷的案例 \(x_q\)，接著我們在近 \(K\) 個鄰居之中取其平均數決定。 ( 當目標結果是在實數值時 ) \(i.e., \quad \hat{f}(x_q) = \frac{\sum_{i = 1}^k f(x_i)}{k}\) Voronoi Diagram - 沃羅諾伊圖 K-Nearest Neighbor knearestneighbor Voronoi Diagram (K= 1) voronoidiagram Nearest neighbor - 最近鄰法 重點性質 將所有的案例( Instance )儲存在一個 \(R^n\) 案例空間之中。( \(n\) 的多寡代表這些資料的 Attribute - 環境引響因素有多少 ) 盡量將 環境引響因素 去蕪存菁，最好少於 20 個 。 ＜Note＞： 引響的環境因素最好是具有意義實數且不可以太多。舉例：假設今天有一筆資料同時可以被兩個與三個的環境因素所表達，但在有三個環境因素案例空間的資料間隔會更分散。 Pros 訓練的時間很快。 可以學習很複雜的「目標函數 ( 概念 )」 不會捨去訓練資料的資訊。 Cons 判斷新進的案例需時很長。 容易被不重要的環境因素所誤導。 K-Nearest Neighbor Learning - 近 \(K\) 個鄰法 若今天給定資料案例 \(x\) 是由 \(n\) 個 attributes - 環境因素所構成，可以表達為：\(x = ＜a_1(x), \ldots, a_n(x)＞\)。 接者，使用平常對於歐基里德空間最熟悉的兩點求距( Euclidean distance ) \(d(i, j) = \sqrt{\sum_{r = 1}^n (a_r(x_i) - a_r(x_j))^2}\) ###Algorithm - 演算法 給定一個要判斷的案例 \(x_q\) 。 欲找到 \(k\) 個與 \(x_q\) 靠最近的 \(x_i\) 。( 利用 \(d(x_i, x_q)\) 判斷距離 ) 選出 \(k\) 個案例之中出現比較多次的結果作為 \(x_q\) 的結果。( 當這份資料的結果是由離散的資料組成採用此方法 ) - 以下圖舉例 \(k = 1\) ，判定 \(x_q\) 為正向輸出。\(k = 5\) ，判定 \(x_q\) 為負向輸出。 當資料的結果為連續的時數值時，我們判定 \(x_q\) 的輸出為 \(k\) 個鄰居的平均值。 建立的假說空間 使用 KNN 時我們建立的假說空間 \(H\) 不是明確的。 隱式的假說空間 \(H\) 將所有的訓練資料( 案例 )都完整地保留在我們建立的假說之中。 要檢驗新的 \(x_q\) 時，需要將所有的案例都檢查過一遍。 1-NN：\(H\) = Voronoi Diagram voronoidiagram2 距離權重近鄰法 Distance - Weighted \(K\)NN 欲考慮比較近的鄰居佔比越重。( 所以距離與權重呈現倒數的關係 ) \(\hat{f} \leftarrow \frac{\sum_{i = 1}^k w_if(x_i)}{\sum_{i = 1}^k w_i}\) \(w_i \equiv \frac{1}{d(x_q, x_i)^2}\) \(d(x_q, x_i)\) 是 \(x_q\) 與 \(x_i\) 的距離。 問題來了，那我們要選擇幾個鄰居作為參考值呢？ Shepard’s Method ：將整個案例空間所有的 \(x_i\) 都納入考量。 Curse of Dimensionality - 維度災難 (閱讀更多) 想像一個案例可以用20個環境變因( Attribute )所解釋，但是只有其中兩個變因是實際有影響的，若變因的維度太高可能會讓不重要的因素導致整個空間裡的案例之間的距離變得更稀疏，進而干擾我們最終呈現的「想法」。 解決方法：計算兩個案例之間的距離時對每個變因進行加權 這樣的方法相當於按比例縮放歐式空間中的坐標軸，先決定哪些環境邊因對我們的訓練比較重要(Try and error)，縮短對應到相關不大之變因的坐標軸，拉長對應於相關較大之變因之座標軸。每個座標軸的伸縮量可以透過交叉驗證的方法自動決定。 一些專有名詞 Regression - 回歸 逼近一個實數函數 \(f\) ( 最終「想法」) Residual - 殘差 「某樣本的均值」與「所有樣本集均值」的均值之偏離，代表取樣的合理性即該樣本是否具代表意義。残差大，表明樣本不具代表性，也有可能由特徵值引起。 ＜Note＞：誤差: 所有「不同樣本集的均值」之均值與真實總體均值的偏離量。由於真實總體均值通常無法獲取或觀測，因此通常是假设總體為某一分部類型，則有 \(N\) 個估算的均值；代表的是觀測/測量的精確度。誤差大，由變異數引起。表明數據可能有嚴重的測量錯誤，或者所選模型不合適。 要看一個模型是否合適，看誤差；要看所取樣本是否合適，看残差。 \(\hat{f}(x) - f(x)\) Kernel function \(K\) - 核心函數 \(K\) 決定距離的函數，用於決定權重影響的比例。 \(w_i = K(d(x_i, x_q))\) \(\Rightarrow w_i = K(d(x_i, x_q)) = \frac{1}{d(x_i, x_q)^2}\) Locally Weighted Regrassion - 區域加權回歸 ＜Note＞：全域法 v.s 區域法：在估計 \(f(x_q)\) 時， 全域法 將所有的案例 \(＜x, f(x)＞\) 納入參考。 區域法 只將區域的( knn )鄰居納入參考。 區域法 加權：由對應的案例 \(x_i\) 與 \(x_q\) 的距離產生的權重。 回歸：逼近一個實數的目標函式。 直觀 \(K\) - NN 對於目標函式 \(f(x)\) ，有一個 \(x_q\) 的需求時，產生一個區域型的逼近結果。 區域加權回歸其實就是泛化的 \(K\) - NN 。 藉由 \(x_q\) 劃出來的範圍 \(K\) 直觀( explicit )的逼近目標函式 \(f(x)\)。 舉例來說，可以一個「線性方程」表達 \(K\) 個鄰居的加權影響值。 \[ \hat{f}(x) = w_0 + w_1a_1(x) + \ldots +w_na_n(x) \] \(a_i\) 代表 \(x\) 對應環境變因的值。 特別的是，有可能可以用「非線性方程」來表達。 K 個鄰居以二次多項式( quadratic function )呈現權重值。 以「分段近似法( piecewise approximation )」求取 \(f\)。 ( 類似cubic spline的手法 ) 以各種不同的「殘差函式」將殘差降到最低求取最終的 \(f\) 在「 \(K\) 個鄰居」之間可以找到 Sum Square Error (SSE) \(E_1(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2\) 在「所有鄰居」之間可以找到距權 Distance-Weighted SSE \(E_2(x_q) \equiv \frac{1}{2} \sum_{x \in D} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\) 將上面兩者合體後 \(E_3(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\) Radial Basis Function Networks 放射狀基底函數網路 將所有的區域逼近組合成全域型地逼近目標函數 \(f\)，通常用於影像、訊號分析。 ＜Note＞：這種網路模型是完全不相干於「Artificial Neural Network - 類神經網路」，相較起來比較與「距離加權回歸」相近，但是以積極的( Eager )的方式而不是以被動的( Lazy )的方式實現。 radialbasisfunction \[ \hat{f}(x) = w_0 + \sum_{u = 1}^k w_u \times K_u (d(x_u, x)) \] \(a_i\)代表 \(x\) 的第 \(i\) 個環境變因，而 \(K_u (d(x_u, x))\) 已經定義為當距離 \(d(x_u, x)\) 變大時會隨之變小。 常用的 \(K_n\) ：Gaussian kernel function \[ K_u (d(x_u, x)) = e^{-\frac{1}{2 \times {\delta_u}^2} d^2(x_u, x)} \] ＜Note＞：常態分布( 又稱為高斯分布 ) \(y = p(x) = \frac{1}{\sqrt{2\pi \delta^2}}e^{-\frac{1}{2}(\frac{x-\mu}{\delta})^2}\) * 訓練 RBF 網路 問題一：對於核心函式\(K_u(d(x_u, x))\)，如何選定一個 \(x_u\) ？ 問題亦是在問如何選定套用一個樣板( prototypes )當作訓練模型。 確認何點為這個案例空間的「常態分布中心點」。 或是以其他的分布套用於該案例空間。 問題二：如何訓練權重( 假設使用Gaussian \(K_u\)的狀態下 )？ 對於每個 \(K_u\) 先設定為變異數( 或是平均數 )。 將 \(K_u\) 固定，訓練出一個線性式的輸出層。 參考 Quora - What is the difference between eager learning and lazy learning? 沃羅諾伊圖 K近邻算法(kNN) - 知乎专栏 机器学习：维度灾难问题- CSDN博客 残差residual VS 误差 error 機器學習技法學習筆記(7)：Radial Basis Function Network與Matrix Factorization 放射狀基底函數網路- 維基百科，自由的百科全書 - Wikipedia]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>KNN</tag>
        <tag>Radial Basis Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chinese Remainder Theorem - 中國剩餘定理專題]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F08%2FChinese-Remainder-Theorem-%E4%B8%AD%E5%9C%8B%E5%89%A9%E9%A4%98%E5%AE%9A%E7%90%86%E5%B0%88%E9%A1%8C%2F</url>
    <content type="text"><![CDATA[Modular 反元素 (模反元素、數論倒數) 整數 \(a\) 對同於 \(n\) 之模反元素滿足以下： \[a^{-1} \equiv b \quad (mod \; n)\] 等價於 \[a \cdot b \equiv 1 \quad (mod \; n)\] ＜Note＞：整數 \(a\) 對模數 \(n\) 之模反元素存在的充分必要條件(iff)是“\(a\)”與“\(n\)”互質。 求 Modular 反元素 輾轉相除法( 歐基里德演算法 ) 原理：\(a, b\)兩整數最大公因數等於各自\(( a , b )\)與兩數相差( a - b )的最大公因數。 \(Ex\)： 252 與 105 的最大公因數為 21 \(252 = 21 \cdot 12 \quad 105 = 21 \cdot 5\)\((21 \cdot 12) - (21\cdot 5) = 21 \cdot (12 - 5) = 21 \cdot 7 = 147\) \(gcd(252, 105) = gcd(252, 147) = gcd(147, 105)\) 使用原理的過程之中，較大的數的最大公因數可以由較小的數所代表，所以繼續進行同樣的計算可以不斷縮小\(a, b\)兩數，直到最後有一數變為 \(0\) 。這時所剩下的非零數就是兩數的最大公因數。 由歐幾里得演算法的過程之中，可以推出兩數的最大公因數能用兩數的整數倍( \(\forall k \in \mathbb{Z}\) )相加來表示，承上例：\(21 = 5 \cdot 105 + (-2) \cdot 252\) Bézout’s lemma - 貝組定理 (丟番圖方程) \(\forall a, b, m \in \mathbb{Z}\) ，求未知數 \(x, y\) 的線性丟番圖方程式（稱為貝祖等式）： \[a \cdot x + b \cdot y = m\] 當 $x, y $有整數解時若且唯若( \(\Leftrightarrow\) ) \(gcd(a, b)\; | \; m\) 。此等式有解時必然有無窮多個解，每組解 \(x, y\) 都稱為貝組數可用擴展歐幾里得演算法求得，也就是說若 \(a\) 為負數\(a \cdot (-x) + b \cdot y = m\) 有整數解時\(gcd(|a|, b) \;| \; m\)。 $Ex. $ 求 \(47 \cdot x + 30 \cdot y = 1\)，求 \(x, y\)？ $47 = 1 30 + 17 $ \(\Rightarrow 30 = 1\cdot 17 + 13\) \(\Rightarrow 17 = 1 \cdot 13 + 4\)\(\Rightarrow 13 = 3\cdot 4 +1\) 我們得知 \(gcd(47, 30) = 1\)且\(1 \; | \; 1\)，所以接著改寫成「餘數等於」的形式\(17 = 1\cdot 47 - 1 \cdot 30\) \(13 = 1\cdot 30 - 1 \cdot 17\) \(4 = 1\cdot 17 - 1 \cdot 13\)\(1 = 1\cdot 13 - 3 \cdot 4\)最後再反著倒寫回去\(1 = 1\cdot 13 - 3 \cdot 4\)\(\Rightarrow 1 = 1\cdot 13 - 3 \cdot (1\cdot 17 - 1\cdot 13)\)\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot 13\)\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot (1\cdot 30 - 1 \cdot 17)\) $1 = 430 + (-7)17 $ \(\Rightarrow 1 = 4\cdot 30 + (-7)\cdot ( 1 \cdot 47 - 1 \cdot 30 )\) \(\Rightarrow 1 = 47 \cdot (-7) + 30\cdot 11\) 其中， \(x = -7\) 與 \(y = 11\) 為其中一組貝組數，其無限解為 \(x = -7 + 30\cdot k, y = 11 - 47 \cdot k, \forall k \in \mathbb{Z}\) Modular 反元素 若貝組等式 \(a \cdot x + b \cdot y = 1\) (若 \(\neq 1\) 則模反元素不存在)則：\(a \cdot x = 1 - b\cdot y \Leftrightarrow a\cdot x \equiv 1 \quad (mod \; b)\)所以\(a \cdot a^{-1} \equiv 1 \quad (mod \; b)\) ，此時\(x\)為\(a\)的一個模反元素，其無限表示式為\(a^{-1} = x + k\cdot b, \forall k \in \mathbb{Z}\)。 Modular - 同餘的性質 整除性 \(a\equiv b \quad (\mod m) \Rightarrow c \cdot m = a - b , c \in \mathbb{Z}\)\(\Rightarrow a \equiv b\quad ( \mod m ) \Rightarrow m \; | \; a-b\) 遞移性 若 \(a \equiv b \quad (\mod c) , b \equiv d \quad (\mod c)\)則 \(a \equiv d (\mod c)\) 保持基本運算 \(\left \{ \begin{matrix} a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right.\) 放大縮小模數 令\(k \in \mathbb{Z}^+ , a \equiv b \quad (\mod m) \Leftrightarrow k \cdot a \equiv k \cdot b \quad (\mod k \cdot m)\) 費馬小定理 假設 \(a \in \mathbb{Z}\) 且 \(p\) 是質數 \(\ni gcd (a, p) = 1\)，則：\(a^p \equiv a \quad (\mod p)\)\(\Leftrightarrow a^{p-1} \equiv 1 \quad (\mod p)\) 由拉 \(\phi\) - 函數 假設 \(n \in \mathbb{Z}^+\)，定義\(\phi (n)\) 為 \(\\{ 1, 2, \ldots, n-1 \\}\) 中與\(n\)互質(coprime)的元素個數。 假設 \(m \in \mathbb{Z}, n \in \mathbb{Z}^+\)且 \(gcd(m, n) = 1\)，則：\(m^{\phi (n)} \equiv 1 \quad (\mod n)\) Chinese Remainder Theorem - 中國剩餘定理 用例子來推演整個過程： \(Ex.\) 求 \[ \left\{\begin{matrix} x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right. \] 首先拆開來解方便計算： \(\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_1 = 35 \cdot n_1\) \(\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_2 = 21 \cdot n_2\) \(\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_3 = 15 \cdot n_3\) 接著使用同餘的保持基本運算，令\(x = a_1 + a_2 + a_3\)：\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 3)\)\(x = a_1 + a_2 + a_3 \equiv 3 \quad (\mod 5)\)\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 7)\) 計算 \(a_1\)：\[\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_1 = 35\cdot n_1 \equiv 2 \quad(\mod 3)\)不好運算，轉成\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3)\)\(\Rightarrow 35 = 11 \cdot 3 + 2\)\(\Rightarrow 3 = 2 \cdot 1 + 1\)\(1 = 1 \cdot 3 - 1 \cdot 2\)\(\Leftrightarrow 1 = 1 \cdot 3 - 1 \cdot ( 1 \cdot 35 - 11 \cdot 3 )\)\(\Leftrightarrow 1 = (-1) \cdot 35 + 12 \cdot 3\)令\(m_1 = -1 + 3 \cdot k\) (模反元素)所以，\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3) \Leftrightarrow 2 \cdot b_1 \equiv 2 \cdot 35 \cdot m_1 \equiv 2 \cdot 1 \quad (\mod 3)\)則可以令\(a_1 = b_1\cdot 2\)，取\(k = 1, b_1 = 35 \cdot 2 = 70 \Rightarrow a_1 = 140\) 計算\(a_2\)：\[\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_2 = 21\cdot n_2 \equiv 3 \quad(\mod 5)\)不好運算，轉成\(b_2 = 21\cdot m_2 \equiv 1 \quad(\mod 5)\)\(\Rightarrow 21 = 4 \cdot 5 + 1\)\(1 = 21 \cdot 1 - 4 \cdot 5\)令\(m_2 = 1 + 5 \cdot k\) (模反元素)所以，\(b_2 = 21 \cdot m_2 \equiv 1 \quad (\mod 5) \Leftrightarrow 3 \cdot b_2 = 3\cdot 21 \cdot m_2 \equiv 3 \cdot 1 \quad (\mod 5)\)所以令\(a_2 = b_2 \cdot 3\)，取\(k = 0, b_2 = 21 \cdot 1 = 21 \Rightarrow a_2 = 63\) 計算\(a_3\)：\[\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_3 = 15\cdot n_3 \equiv 2 \quad(\mod 7)\)不好運算，轉成\(b_3 = 15\cdot m_3 \equiv 1 \quad(\mod 7)\)\(\Rightarrow 15 = 2 \cdot 7 + 1\)\(1 = 15 \cdot 1 - 2 \cdot 7\)令\(m_3 = 1 + 7 \cdot k\) (模反元素)所以，\(b_3 = 15 \cdot m_3 \equiv 1 \quad (\mod 7) \Leftrightarrow 2 \cdot b_3 = 2\cdot 15 \cdot m_3 \equiv 2 \cdot 1 \quad (\mod 7)\)所以令\(a_3 = b_3 \cdot 2\)，取\(k = 0, b_3 = 15 \cdot 1 = 15 \Rightarrow a_3 = 30\) 最後計算 \(x = a_1 + a_2 + a_3 = 233\)，驗算\(\left\{\begin{matrix} 233 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ 233 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ 233 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\) ，OK。 常見題目類型 Type 1 (模數都互質) \(Ex.\)(99 政大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 5 &amp; ( \mod 7 &amp; )\\ x &amp; \equiv &amp; 4 &amp; ( \mod 9 &amp; )\\ x &amp; \equiv &amp; 3 &amp; ( \mod 13 &amp; )\end{matrix}\right.\) Type 2 (模數不全是互質) \(Ex.\)(97 台科大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 8 &amp; ( \mod 15 &amp; )\end{matrix}\right.\) Type 3 (模數重疊) \(Ex.\)(97 高師大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 13 &amp; ( \mod 16 &amp; )\\ x &amp; \equiv &amp; 73 &amp; ( \mod 81 &amp; )\end{matrix}\right.\) Type 4 (矛盾 - 無解) \(Ex.\)(97 台科大 - 改) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 10 &amp; ( \mod 15 &amp; )\end{matrix}\right.\)]]></content>
      <categories>
        <category>Number Theory</category>
      </categories>
      <tags>
        <tag>Modular</tag>
        <tag>Mod</tag>
        <tag>Inverse</tag>
        <tag>Chinese Remainder Theorem</tag>
        <tag>模數</tag>
        <tag>模反元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra - 重點分析 - LU分解]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F07%2FLinear-Algebra-%E9%87%8D%E9%BB%9E%E5%88%86%E6%9E%90-LU%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Linear Algebra - 重點分析 LU分解 LU 分解的外表看似平淡無奇，但它可以用來解線性方程，逆矩陣和計算行列式，堪稱是最具實用價值的矩陣分解式之一。 令 \(A\) 為一個 \(n\cdot n\) 階矩陣。LU 分解是指將 \(A\) 表示為兩個 \(n \cdot n\) 階三角矩陣的乘積 \[ A = L\cdot U \] 其中 \(L\) 是下三角矩陣，\(U\) 是上三角矩陣，如下例， \[ \begin{bmatrix}3 &amp; 1 &amp; 2 \\ 6 &amp; -1 &amp; 5 \\ -9 &amp; 7 &amp; 3\end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 2 &amp; 1 &amp; 0 \\ -3 &amp; 4 &amp; 1 \end{bmatrix} \begin{bmatrix}3 &amp; -1 &amp; 2\\ 0 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 5 \end{bmatrix} \] 高斯消去法可以通過一連串的矩陣乘法來實現。每一個基本列運算等同於左乘一個基本矩陣，而對應列取代的基本矩陣 \(E_{ij}\) 的 \((i, j)\) 元即為 \(-l_{ij}\)。 消去程序可用下列矩陣乘法表示： \[ E{32}E{31}E_{21}A=U \] 因為基本矩陣 \(E_{ij}\) 都是可逆的 \[ A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U=LU \] 存在性 然而，並非任何可逆矩陣都具有 LU 分解形式，例如：\(A=\begin{bmatrix} 0&amp;2\\ 1&amp;3 \end{bmatrix}\)。假若 \(A\) 可以寫為 \[ A=LU=\begin{bmatrix} 1&amp;0\\ l_{21}&amp;1 \end{bmatrix}\begin{bmatrix} u_{11}&amp;u_{12}\\ 0&amp;u_{22} \end{bmatrix} \] 則必有 \(u_{11}=0\)， \(U\) 是不可逆的，這與 為 \(LU=A\) 可逆矩陣的事實相互矛盾。矩陣 之所 \(A\) 以不存在 分解的\(LU\) 原因在於 \(0\) 占據了 \((1,1)\) 元，但軸元必須不為零才能產生乘數。根據這項觀察，即知可逆矩陣 \(A\) 的 LU 分解存在條件是：列運算過程中，\(0\) 不得在軸元位置。萬一碰上零軸元的情況，還是有補救辦法，那就是使用列交換運算設法產生其他非零軸元，不過 LU 分解要修改成 \(PA=LU\)，\(P\) 是排列矩陣。例如， \[ \begin{aligned} PA&amp;=\begin{bmatrix} 0&amp;1\\ 1&amp;0 \end{bmatrix}\begin{bmatrix} 0&amp;2\\ 1&amp;3 \end{bmatrix}=\begin{bmatrix} 1&amp;3\\ 0&amp;2 \end{bmatrix}\\ &amp;=\begin{bmatrix} 1&amp;0\\ 0&amp;1 \end{bmatrix}\begin{bmatrix} 1&amp;3\\ 0&amp;2 \end{bmatrix}=LU.\end{aligned} \] 應用 最後討論 LU 分解的應用。LU 分解不僅僅只是記錄消去過程，它還有一個非常重要的實際用途：LU 分解具備快速求解線性方程 \(A\mathbf{x}=\mathbf{b}​\) 的良好結構。一旦得到了可逆矩陣 \(A​\) 的 LU 分解 \(A=LU​\)，我們大可把 \(A​\) 拋棄，將 \(A\mathbf{x}=\mathbf{b}​\) 改為 \(L(U\mathbf{x})=\mathbf{b}​\)，再令 \(\mathbf{y}=U\mathbf{x}​\)，原線性方程等價於兩組三角形系統： \[ \begin{aligned} L\mathbf{y}&amp;=\mathbf{b}\\ U\mathbf{x}&amp;=\mathbf{y}. \end{aligned} \] 接著使用兩次迭代即可得到解。上例中，先以正向迭代解出 \(\mathbf{y}\)， \[ \left[\!\!\begin{array}{rcc} 1&amp;0&amp;0\\ 2&amp;1&amp;0\\ -3&amp;4&amp;1 \end{array}\!\!\right]\begin{bmatrix} y_1\\ y_2\\ y_3 \end{bmatrix}=\left[\!\!\begin{array}{r} 10\\ 22\\ -7 \end{array}\!\!\right]\Rightarrow\begin{cases} y_1=10&amp;\\ y_2=-2y_1+22=2&amp;\\ y_3=3y_1-4y_2-7=15&amp; \end{cases} \] 再以反向迭代解出 ， \[ \left[\!\!\begin{array}{crc} 3&amp;-1&amp;2\\ 0&amp;1&amp;1\\ 0&amp;0&amp;5 \end{array}\!\!\right]\begin{bmatrix} x_1\\ x_2\\ x_3 \end{bmatrix}=\left[\!\!\begin{array}{r} 10\\ 2\\ 15 \end{array}\!\!\right]\Rightarrow\begin{cases} x_1=(x_2-2x_3+10)/3=1&amp;\\ x_2=-x_3+2=-1&amp;\\ x_3=15/5=3&amp; \end{cases} \] 對於 階矩陣 ，LU 分解耗費的乘法運算量大約是 \(\mathbf{O}(\frac{1}{3}n^3)\)，與高斯消去法相同。這個數字其實不算太糟，因為兩個 \(n\) 階方陣相乘就使用了 \(n^3\) 次運算。另外，正向迭代或反向迭代的運算量都只有\(\mathbf{O}(\frac{1}{2}n^2)\) ，遠比 LU 分解來的少。所以如果只要解出單一線性系統 ，直接用消去法化簡增廣矩陣 \(\begin{bmatrix} A\vert\mathbf{b} \end{bmatrix}\) 和 LU 分解的兩段式解法兩者之間並沒有多大差別，但如果稍後還要解多個係數矩陣相同但常數向量改變的系統 ，LU 分解便能夠派上用場。舉例來說，LU 分解可以用來計算逆矩陣 \(A^{-1}\)。將矩陣方程 看成三個線性方程： \[ A\mathbf{x}_1=\begin{bmatrix} 1\\ 0\\ 0 \end{bmatrix},~ A\mathbf{x}_2=\begin{bmatrix} 0\\ 1\\ 0 \end{bmatrix},~ A\mathbf{x}_3=\begin{bmatrix} 0\\ 0\\ 1 \end{bmatrix} \] 解出的未知向量 \(\mathbf{x}_i\)，\(i=1,2,3\)，就是逆矩陣 \(A^{-1}\) 行向量。LU 分解還可以用來計算 \(n\times n\) 階行列式。根據矩陣乘積的行列式可乘公式 \[ \det A=\det(LU)=(\det L)(\det U) \] 三角矩陣的行列式等於主對角元乘積，因此 \(\mathrm{det}L=1\)，推論 \[ \det A=\det U=\displaystyle\prod_{i=1}^nu_{ii} \] 方陣 \(A\) 的行列式即為消去法所得到的上三角矩陣 \(U\) 主對角元之積 (關於其他行列式計算方法的介紹，請見“Chiò 演算法──另類行列式計算法”)。 參考 LU 分解| 線代啟示錄]]></content>
      <categories>
        <category>Linear Algebra</category>
        <category>重點分析</category>
      </categories>
      <tags>
        <tag>LU分解</tag>
        <tag>LU Decomposition</tag>
        <tag>重點</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Claim - 專利聲明]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Claim-%E5%B0%88%E5%88%A9%E8%81%B2%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Patent Claim - 聲明專利 專利的「異議」與「舉發」 異議 對於審定公告之專利原則上，任何人得自審定公告之次日起3個月內提起異議。 用於撤銷該專利之審定。 舉發 對於以取得之專利，得對之提起舉發。 用於撤銷「專利權」，使專利自使部存在。 ＜Note＞：有無仿冒？以專利角度看待，抄襲仿冒不是重點，重點是有無落入對方的專利申請範圍內。 專利範圍之記載要件 包含必要的技術特徵。 明確，使相關領域具通常知識者，可以明確瞭解其意義，不生疑義。 所載的發明符合產業利用性、新穎性與進步性。 為發明說明所支持。 結構 ( P + T + B ) 前言 ( Preamble ) 連接詞 ( Transition ) 主體 ( Body ) 獨立項與附屬項 ★★★★★ 獨立項：載明申請專利之標的及其實施之必要技術特徵。 ☆☆☆☆★ 附屬項：包含所依附項目之全部技術內容，並說明依附請求項以外之技術特徵。 ＜Note＞：獨立項遠重要於附屬項。 \(Ex.\) 一種杯子，其包含方形杯體及連接其上之把手。如請求項1之杯子，其中該杯體高度為10公分。如請求項2之杯子，其中該把手是透明的。 請求項 ( Claim ) 一般建議涵蓋不同範圍的請求項 最廣 中等 - 最小：最終銷售產品。 thedifferentsetofclaim 選擇一個「女友」？ 請根據以下條件以請求項( Claim )的方式要求。 覺得她長的漂亮 身高165公分以上，必須比我矮5公分，所以要在175公分以下 瘦瘦的 懂得化妝 最好長髮飄逸 即使是生氣時，也要很溫柔 要當太太不一樣，要會做家事，會煮飯，喜歡小孩 年輕的未婚女性 \(Ex.\) 獨立項( 範圍 ) 一名女性人類( P )，包含( T )下述之特性( B )： 覺得她長的漂亮\(\rightarrow\)五官特徵與松島菜菜子差異0%~20%之間。 身高165公分以上，必須比我矮5公分，所以要在175公分以下\(\rightarrow\)身高165公分至175公分之間。 瘦瘦的\(\rightarrow\)以身高推算後之標準體重再減10%~20%之間。 懂得化妝\(\rightarrow\)修過認證化妝課程20小時以上。 即使是生氣時，也要很溫柔\(\rightarrow\)喜歡不聽話的0歲到16歲人類。 要當太太不一樣，要會做家事，會煮飯，喜歡小孩\(\rightarrow\)喜歡也愛做被分配到的工作，但不要求薪水。 年輕的未婚女性\(\rightarrow\)年齡16歲到20歲的未婚人類。 附屬項( 範圍 ) 如專利範圍第1項所述之女性人類，更包括下述特性： 最好長髮飄逸\(\rightarrow\)長髮過肩30公分以上。 ＜Note＞：申請專利範圍用字要具體。越抽象的形容詞\(\rightarrow\)越難寫長得漂亮\(\rightarrow\)五官特徵與松島菜菜子差異0%20%之間\(&lt;br&gt;\rightarrow\)五官特徵與20歲松島菜菜子，經微軟發行的臉部辨識軟體，辨識之後差異0%20%之間 申請專利範圍所列的條件，『都』必須符合，才算是在專利範圍所主張的範圍之內。 來了1個大美女、但少了一隻耳朵、指甲長且銳利、手常過膝 解決： 加入 Claim 3 一名女性人類( P )，包含( T )下述之特性( B )： 除了剛剛所述另外加入 有兩隻健全耳朵、且可辨識聲波。 四肢健全、雙手自然下垂、長度介於腰繫之間。 每根手指指甲長度在1.2~2公分之間。 來了個日本女生，但是個六指琴魔 修正 Claim： 有兩隻健全耳朵、且可辨識聲波。 四肢健全、雙手自然下垂、長度介於腰繫之間。 每隻手有五根手指頭、每根手指指甲長度在1.2~2公分之間。 thedifferentsetofclaim2 外加一個Claim 4涵蓋Claim 1～3 一名女性人類，包含以下特性。 - 一名女性人類，目前未婚 thedifferentsetofclaim3 申請專利範圍之結構 前言 ( Preamable ) 連接詞 ( Trainsition ) 開放式：包含、包括、其特徵在於。(Comprise, contain, characterized by) 封閉式：由…組成。( Consisting of ) 半開放式：基本上由…組成。( Consisting essentially of ) 主體 ( Body ) 前言 描述所請發明之標的型態： 一種組合物… 一種裝置… 一種方法… 限制條件? 一種用於載裝飲料( 用途限定 )的杯子… 一種具有兩分裝空間( 結構限定 )的杯子… 一種杯子… 連接詞 開放式：包括、包含(comprise, contain) 表示所申請範圍包含主體中未記載之元件、成分、或步驟。 例如：一種組合物，包括成分A及B。 ＜Note＞：專利範圍涵蓋度最廣。 半開放式：基本上由…組成(consisting essentially of) 不排除實質上無影響力之成分。 例如：一種組合物，基本上由成分A及B組成。 ＜Note＞：專利範圍涵蓋度中度。 封閉式：由…組成(consisting of) 僅包含主體中記載之元件、成分、或步驟。 例如：一種組合物X，由成分A及B組成。 ＜Note＞：專利範圍涵蓋度最低。 主體 記載所請發明的主要特徵 標的請求項：物品或物質的結構特徵。 方法請求項：步驟。 \(Ex.\) claimpractice1 Claim A claimpractice2 Claim B claimpractice3 Claim C claimpractice4 Claim D claimpractice5 Claim E claimpractice6 upload successful ＜Note＞：限制條件越多，權力範圍越小。專利說明書的所有部分，都是為『申請專利範圍』而活。 theeffectofthesizeofclaim 範圍可以無限擴大嗎？ 專利範圍當然是越大越好。 『發明之必要條件』與『既有技術』，專利說明書的具體實例也會影響專利範圍的大小。 最後，範圍無限擴大的專利的問題在能否通過。]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Claim</tag>
        <tag>專利聲明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Specification - 專利說明書]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Specification-%E5%B0%88%E5%88%A9%E8%AA%AA%E6%98%8E%E6%9B%B8%2F</url>
    <content type="text"><![CDATA[Patent Specification - 專利說明書 不能只提出要解之問題，要寫出『如何辦到』。專利說明書要說明『如何辦到』。 想法：趁聖誕老公公發禮物時抓住他。 作法：需要具體機制。 狗應該要有專門的馬桶。 作法：如何設計一個狗狗專用的馬桶。 說明書的內容 patentspecificationcontent INID專利書目識別碼 Internationally agreed Numbers for the Identification of bibliographic Data 二位阿拉伯數字組成的數字，作為辨識專利公報之書目資料項目的重要指標 國際專利分類號 1971年由Strasburg國際專利協定所制定，並由世界智慧財產權組織(WIPO)每五年修訂一次並出版，其分類目的在便於專利資料的整理、查索及管理等運用。 目前最新版本為第八版，已於2006.01公佈並使用，並區分為核心版與進階版。 IPC從第一版的47,263個分類增加到第七版的67,634個分類，第八版的分類總數增加至約70,000個分類(進階版)，且分類架構已有大幅度的變動。 第七版以前約每五年更新一次，從第八版起，核心版將縮短為三年一次，進階版則隨時更新。 IPC分類之編排大致以 部(Section) 類(Class) 次類(Subclass) 主目(Group) 次目(Subgroup) 五大階層編排中，每一階層彼此之間具有從屬關係。 Section - 部 theclassficationofIPC_section Class - 類 upload successful Santa Calus Detector Patent 5523741 thesantacalusdetector1 thesantacalusdetector2 thesantacalusdetector3 upload successful 小結論 subsummary1 subsummary2 代號意義 [10] 文件識別 Identification of the patent, SPC, or patent document [11] 文件號碼 Number of the patent , SPC, or patent document [12] 文件種類 Plain language designation of the kind of document [13] 文件種類代碼 Kind-of-document code according to WIPO Standard ST. 16 [15] 專利修正資訊 Patent correction information [19] 文件發行單位 WIPO Standard ST. 3 Code, or other identification, of the office or organization publishing the document Santa Claus Detactor Patent 5523741 santacalusdetector5 [20] 專利申請登記項目 Data concerning the application for a patent or SPC [21] 申請號 Number(s) assigned to the application(s) [22] 申請日 Date(s) of filing the application(s) [23] 其他日期 Other Date(s), including date of filing complete specification following provisional specification and date of exhibition [24] 工業產權生效日 Date from which industrial property rights may have effect [25] 申請案最初提出時使用語文 Language in which the published application was originally filed [26] 最初申請案之語文 Language in which the application is published Santa Claus Detactor Patent 5523741 santacalusdetector6 [30] 國際優先權 Data relating to priority under the Paris Convention [31] 優先權申請號 Number(s) assigned to priority application(s) [32] 優先權申請日 Date(s) of filing of priority application(s) [33] 優先權申請國家 WIPO Standard ST. 3 code identifying the national industrial property office allotting the priority application number or the organization allotting the regional priority application number ; for the international applications filed under the PCT, the code “WO” is to be used [35] 優先權申請日期 For priority filings under regional or international arrangements, the WIPO Standard ST. 3 code identifying at least one country party to the Paris Convention for which the regional orinternational application was made [40] 公開日期 Date(s) of making available of the public [41] 未經審查尚未獲准專利的說明書提供公眾閱覽或複印的日期 [42] 經審查但尚未獲准專利的說明書提供公眾閱覽或複印的日期 [43] 未經審查之出版日期(公開日) Date of making available to the public by printing or similar process of an unexamined patent document, on which no grant has taken place on or before the said date [44] 經審查未獲權之出版日期 [45] 經審查已獲權之公告日(公告日) Date of making available to the public by printing or similar process of an examined patent document on which grant has taken place on or before the said date [46] 僅有申請專利範圍的出版日期 [47] 獲准專利說明書提供公眾用覽或複製的日期 Date of making available to the public by viewing, copying on request, a patent document on which grant has taken place on or before the said date Santa Claus Detactor Patent 5523741 upload successful [50] 技術資料 Technical Information [51] 國際專利分類 International Patent Classification or, in the case of a design patent, as referred to in subparagraph 4(c) of this Recommendation, International Classification for Industrial Designs [52] 本國專利分類 Domestic or national Classification [54] 發明名稱 Title of the invention [56] 先前技術文件明細 List of prior art document, if separate from descriptive text [57] 摘要或申請專利範圍 Abstract or claim [58] 檢索範圍 Field of search Santa Claus Detactor Patent 5523741 santacalusdetector8 [60] 與申請有關之法律文件 References to other legally or procedurally related domestic or previously domestic patent documents including unpublished applications therefore [61] 追加關係 Earlier document to which this is an addition [62] 分割關係 Earlier application form which the present document has been divided out [63] 延續關係 Continuations [64] 再發行關係 Document being reissued [65] 同申請案, 先前公開於其他國家之文件 Previously published document concerning same application [66] 取代關係 Document for which this is a substitute [70] 人事項目 Identification of parties concerned with the patent ot SPC. [71] 專利權人/申請人 Name(s) of applicant(s) [72] 發明人 Name(s) of inventor(s) if known to be such [73] 受讓人 Name(s) of grantee(s), holder(s),assignee(s), or owner(s) [74] 代理人 Name(s) of attorney(s) agent(s) [75] 發明人兼申請人 Name(s) of inventors who is (are) also applicant(s) [76] 發明人兼申請人及受讓人 Name(s) of inventors who is (are) also applicant(s) and grantee(s). Santa Claus Detactor Patent 5523741 santacalusdetector9 [80] 有關國際條約之資料識別 Identification of data related to International Conventions other than the Paris Convention, and to legislation with respect to SPCs. [81] PCT國際申請指定國 [82] PCT選擇國 Elected State(s) according to the PCT [83] 微生物寄存資料 Information concerning the deposit of microorganisms [84] 專利指定國 Designed Contracting States under regional patent conventions [85] 符合PCT第23條第1款或第40條第1款之規定而開始國內程序之日期 [86] PCT申請案相關資料 [87] PCT公開資料(公開號、公開語言、公開日) [88] 檢索報告延遲公佈日期 [89] 發明人證書，或基於CMEA協定對於發明之保護文件號碼及原始國 Santa Claus Detactor Patent 5523741 santacalusdetector10]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>專利</tag>
        <tag>Specification</tag>
        <tag>專利說明書</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Content of Patent 專利看討]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FContent-of-Patent-%E5%B0%88%E5%88%A9%E7%9C%8B%E8%A8%8E%2F</url>
    <content type="text"><![CDATA[專利看討 不是攻擊對手，而是保護自己(和公司)的權力。 專利制度 中華民國專利法 分為3章共156條 ＜專利法(1)＞：為鼓勵、保護、利用發明、新型及設計之創作，以促進產業發展，特制定本法。 ＜專利法(2)＞：本法所稱專利，分為 發明專利。 (新發明) 新型專利。 (新型) 設計專利。 (新式樣) formoftypeofpatent 什麼可以成為專利？ 若認為能賺錢的發明才是發明，會非常難達成。專利保護的概念，往往比大部分人想的都要廣，就算看起來不像是可受專利保護的概念，換個角度想也常能受專利保護。 thepatentofconcept 「改良」也算是發明 發明電燈泡的只有一個人？ 事實上，愛迪生的電燈泡出現之前70年，已經知道用白金當燈絲，但非真空。 只要有發明的概念 並有具體的作法。 不能成為專利的「概念」 動植物的新品種。 如基因改造過的玉米、新品種的老鼠。 人體或動物疾病之診斷、治療或治療方法。 心臟移植手術的方法。 ＜Note＞： 藥物、製藥方法、醫療器材等這些不包含在此。 科學原理或數學方法本身 \(E = M\cdot C^2\) ＜Note＞： 利用科學原理或是數學方法是可以成為專利的。\(Ex.\) MP3 壓縮技術、加解密技術。 純為人類智力的規則或方法。\(Ex.\)：如何節稅、如何開連鎖店。 屬著作權保護的美術、文學與音樂創作。 負面表列 一般是否屬於專利會保護的概念，只要看當地專立法所列的『負面表列』即可。 ＜專利法(24)＞：下列各款，不予發明專利： 動植物及生產動、植物之主要生物學方法。但微生物學之生產方法 ，不在此限。 人類或動物之診斷、治療或外科手術方法。 妨害公共秩序或善良風俗者。 專利在國際的考慮 各國價值觀不同，所核准的專利範圍也不盡然相同。慎選區域，因為所費不斐，最好以市場大小及競爭對手的區域為基準考量。]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Concept</tag>
        <tag>專利看討</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Applying 專利申請]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Applying-%E5%B0%88%E5%88%A9%E7%94%B3%E8%AB%8B%2F</url>
    <content type="text"><![CDATA[申請專利 申請流程 申請→18個月後公開→3年內請求實體審查→實體審查→審定公告3個月→審查確定(無異議或異議不成立)→領證→( 舉發 )。 申請日 決定誰可以獲得勝利！ 申請日之取得 專利法(25)：申請發明專利，由專利申請權人備具申請書、說明書、申請專利範圍、摘要及必要之圖式，向專利 專責機關 申請之。 專利法(25)：申請發明專利，以申請書、說明書、申請專利範圍及必要之圖式齊備之日為『申請日』。 申請文件 需求 申請書 說明書 發明名稱 發明說明應明確且充分揭露發明之內容。 申請專利範圍各請求向以簡潔之方式記載。 圖示 ＜Note＞：若申請有『生物材料專利』，申請人應將該生物材料寄存於指定機構。 專利生效時間線 timelineofpatentapplying 專利權人 發明人 對於這個發明有貢獻的人。 專利申請人 提出專利申請的人，可以是公司、組織( 法人 )或是個人( 自然人 )。 ＜Note＞： 一定要填寫發明人，用來表彰發明人的貢獻，若發明人的填寫有捏造的事實，即便取得專利權也可能被撤銷專利。 誰是專利權人？ 真正擁有該專利權的人是「專利申請人」。 審查 專利提出申請 (繳費) 請求審查 (再繳費) 申請後必須要在 2~5年( 大部分是3年 )提出，否則專利視同撤回。＜用意＞： 考慮專利是否具備價值。’ ＜Note＞：美國的專利申請，一律自動審查，無請求審查制度，所有費用都包含在提出專利申請時的繳費。 始得權力日 專利權有效自申請日起算。 侵權日自專利審查完成後起算。 timelineofpatentapplying2 早期公開制度( Limited Early Publication System ) 『早期公開，請求審查』 為大部分國家所採用。 在申請日後，18個月會在『公開公報』上刊登申請專利的內容。＜目的＞：使同產業提早新技術內容，以及避免重複研發相同技術。 暫准專利權( Provisional right ) 如果在早期公開至專利核准期間，發生侵權行為，日後專利核准之後，專利權人可以要求暫准專利權其間的損失。 公眾審查制度( Public review system ) 有些國家規定，在核准專利過後的3～6個月，會公開讓民眾確認這項專利的合格性，待時間過後繳交「專利領證費」並領證，接著，每年還需繳交「專利維持費」。 歐盟 [x] 公眾審查制 ( 3～6個月 ) 美國 [ ] 公眾審查制 核准後直接領證。 撤銷專利 在領到證書之後，任何人都可以主張撤銷你的專利。 可能的原因 沒有符合「專利要件」。 不同意審查委員的看法。 提出當初審查委員沒有看討的先前技術( 習之技術 )。 先申請主義( Double Patenting ) 誰將獲得台灣專利？ doublepatenting ( 乙君 ) ＜先申請主義＞ 現在沒有所謂的＜先發明主義＞；依我國專利法(31)：相同發明有二以上之專利申請案時，僅得就其最先申請者准予發明專利。 ＜Note＞：先申請先贏。 屬地主義 只有在該國的專利核准過的專利，才能在該國享有專利權，其餘國家的專利權皆無法在該國產生任何作用。 國際、國內優先權 Right of Priority - 國際優先權 誰將獲得台灣專利？ rightofpriority ( 乙君 ) 甲君未聲明＜國際優先權＞！ 專利申請人就相同發明，在他國提出第一次申請案後，於特定期間內向我國提出之專利申請案得以主張「優先權』，換句話說，以國外第一次申請案之申請日為『優先權日』，並據以作為審查是否符合專利之基準日。 ＜專利法(28)＞：申請人就相同發明在與中華民國相互承認優先權之國家或世界貿易組織會員(WTO)第一次依法申請專利，並於第一次申請專利之日後十二個月內，向中華民國申請專利者，得主張優先權。 ＜專利法(29)＞：依前條規定主張優先權者，應於申請專利同時聲明下列事項： 第一次申請之申請日。 受理該申請之國家或世界貿易組織會員。 第一次申請之申請案號數。申請人應於最早之優先權日後十六個月內，檢送經前項國家或世界貿易組織會員證明受理之申請文件。 rightofpriority2 Right of Domestic Priority - 國內優先權 誰將獲得台灣專利？ rightofdomesticpriority ＜專利法(30)＞：申請人基於其在中華民國先申請之發明或新型專利案再提出專利之申請者 ，得就先申請案申請時說明書、申請專利範圍或圖式所載之發明或新型，主張優先權。 ＜Note＞：但有下列情事之一，不得主張之 自先申請案申請日後已逾十二個月者。 upload successful 曝光條款 ＜專利法(22)＞：可供產業上利用之發明，無下列情事之一，得依本法申請取得發明專利。 申請前已見於刊物者。 申請前已公開實施者。 申請前已為公眾所知悉者。 ＜Note＞：發明雖無前項各款所列情事，但為其所屬技術領域中具有通常知識者依申請前之先前技術所能輕易完成時，仍不得取得發明。 ＜專利法(22)＞：申請人有下列情事之一，並於其事實發生後六個月內申請，該事實 非 屬第一項各款或前項不得取得發明專利之情事。 因實驗而公開者。 因於刊物發表者。 因陳列於政府主辦或認可之展覽會者。 非出於其本意而洩漏者。 情境題 甲君獲得專利 situationquestion1 乙君無法獲得專利 upload successful 甲君獲得專利 upload successful 沒有人可獲得專利 ( 超過六個月的申請期 ) upload successful 審查 中華民國由智慧財產局依該申請是否具備專利要件決定。 符合專利要件→授予專利(核准) 不符合專利要件→應予駁回(核駁) 核駁 申請人對於『不給專利之審定』，不服者可以申請再審查。 ＜專利法(48)＞：發明專利申請人對於不予專利之審定有不服者，得於審定書送達後二個月內(60天內)備具理由書，申請再審查。但因申請程序不合法或申請人不適格而不受理或駁回者，得逕依法提起行政救濟。 行政救濟 對於『再審查』不服之一方：應提起訴願。( 向經濟部為之 ) 對於『訴願』不服之一方：應提起行政訴訟。( 向行政院為之 ) 起訴：高等行政法院 上訴：最高行政法院 專利權人 專利權人是誰？ situationquestion5 ＜專利法(7)＞： 受雇人於職務上所完成之發明、新型或設計 其專利申請權及專利權屬於雇用人，雇用人應支付受雇人適當之報酬。 但契約另有約定者( 合約 )，從其約定。 ＜Note＞：發明人具有『姓名表示權』。 ＜專利法(8)＞：受雇人於非職務上所完成之發明、新型或設計，其專利申請權及專利權屬於受雇人。 ＜專利法(7)＞：一方出資聘請他人從事研究開發者，其專利申請權及專利權之歸屬 依雙方契約約定 契約未約定者，屬於發明人、新型創作人或設計人。 ＜Note＞： 出資人得實施其發明、新型或設計之權力。 ＜Note＞： 美國專利的專利申請人一定是發明人，因此當職務上之發明，則在申請的同時，送交一份『讓與書』，以便權力由個人轉到公司。 Contract of Employment 聘用合約書 contractofemplement 補充 專利費用預估參考 - 以新台幣計(工研院資料) feeofpatent 輔大專利申請 patentapplyingofFJU patentofapplyingofFJU2 參考 中華民國專利公報檢所解析 早期公開を英語で・英訳 - 英和辞典・和英辞典 Weblio辞書 雙語詞彙]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Apply</tag>
        <tag>專利</tag>
        <tag>申請</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Technical Patent Study - 科技專利專題]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F04%2FTechnical-Patent-Study-%E7%A7%91%E6%8A%80%E5%B0%88%E5%88%A9%E5%B0%88%E9%A1%8C%2F</url>
    <content type="text"><![CDATA[科技專利專題 Technical Patent Study - 概觀 首先，要了解專利就必須先思考到底是甚麼東西、有什麼用？ 瞭解專利對於企業發展及生存的重要性。 知道自己或團隊研發成果，哪些可以申請專利。 透過專利檢索快速學習他人技術。 避免侵害他人的專利。 撰寫優質的專利說明書(申請專利的技術文件)。 智慧財產權 Intellectual Property Right 智慧財產權，是一種無體財產權，係指人類精神活動之成果而能產生財產上之價值者，由法律所創設的一種權利，包括： 著作權 商標權 專利權 工業設計 積體電路布局 (IC) 鄰接權 植物種苗 商業秘密 不公平競爭 intalletualpropertyform 創作保護主義 創作保護主義，僅有創作之事實，即取得著作權。但為期權利明確及有完整之著作權記錄，得兼採登記主義，而登記機關改歸中央圖書館。但著作物登記並非著作權之取得要件，僅推定其權利為真實。至於著作權之移轉或處分之限制，以及以著作權為標的之質權的設定、移轉、變更或消滅或處分之限制，則非經登記，不得對抗第三人。 其保護僅及於該著作之表達(Expression)，而不及於其所表達之思想(Idea)、程序、製程、系統、操作方法、概念、原理、發現。 ＜小見解＞：上述的「表達(Experssion)」就是已經動手做出的有形實體(書畫)，或無形創作(音樂、文章、程式碼)。 著作權 著作權法之沿革 前清宣統 2年（ 1910 年）頒布之著作權律，係我國第一部之成文著作權法，其採註冊保護主義，著作物經註冊給照者，受著作權保護（著作權律第 4 條）。民國建立後，著作權律仍然沿用。北洋政府嗣於 1915 年頒布一部著作權法。國民政府亦於 1928年頒布著作權法，期間於 1944年、1949年、1964年、1985年、1990年、1992年、1993年、1998年、2001年、2003年及2004年均有修正。1985年修法前，作者必須申請註冊登記，始取得著作權，1985年修法後，改為著作人於著作完成時，享有著作權，係創作保護主義或稱自然發生主義。註冊或登記均僅具存證之性質，並非取得著作權之要件，倘當事人對於權利有爭執時，應由當事人自行提出證據證明之，並由司法機關依具體個案調查事實認定之，不應以著作權登記簿謄本之核發，作為認定著作權有無之唯一證據。而智慧財產局自1998年1月23日起，已不再受理著作權登記業務，倘原登記或註冊事項如有變更亦無從辦理更新。 著作權侵害 判斷是否受侵害時須考慮的因素有二： 被侵害的標的必須是表達而非思想。 被告須有接觸(Access)或實質相似(Substantial Similarity)的抄襲(Copying)行為。 ＜小見解＞：接觸(Access)就是該被告有可能接處到原創作者的任何途徑，所以有些創作者會在淨室(Clean Room)創作，防止任何的接觸可能性。 如何保護著作權 「舉證之所在、敗訴之所在」，如何舉證該著作是自己的原創是件很重要的事，用白話文來說，就是在創作時要無時無刻保留自己的手稿，來證明創作的靈感。法律是講求證據的，如果研發過程中未留下任何紀錄，則明明是贏的官司也可能會打輸。 有些科技公司會有研發紀錄簿，證明創作的理念。 建立淨室(Clean Room)，意旨個隔離所有可能的接觸。 小結論 『專利保護概念，著作權不保護概念』 舉例 \(Ex1.\) 微積分或力學原理，教師製作磨課師課程可以參考原文教科書，另行自編教材並解說，但在作業或測驗方面，就必須使用原文書的例題及習題內容了，這部分可以自由利用嗎？如果台灣書商無法授權，又該如何？ 原文教科書的例題及習題，仍是受著作權法保護，教師必須自行製作題目，否則就只能取得授權。 台灣書商無法給予課本內容之授權，通常是因為他只有賣書的權利，沒有內容授權的權利，必須與出版社連繫。若出版社無權授權，就要與著作人聯絡。真的找不到，就只能自己創作，才是安全的。 這就說明了，編一本書是很辛苦的，內容及例題和解答，都是智慧成果，所以書才會賣得很貴。磨課師課程的內容製作也很辛苦，若想少辛苦一點，就是付錢取得他人既有成果來使用，這無法單是以標明出處，就可取代授權的。 \(Ex2.\) patentexample1 patentexample2 patentexample3 patentexample4 patentexample5 patentexample6 審查主義 指創作完成後，須向 主管機關 提出申請、並經主管機關審查通過後，始能取得權利者。 中華民國的主管機關為『經濟部智慧財產局』 美國的主管機關為『專利商標局』 日本的主管機關為『特許廳』 大陸的主管機關為『知識產權局』 商標 商標（英語：Trademark）是識別某商品、服務或與其相關具體個人或企業的顯著標誌，可以是圖形或文字，也可以聲音、氣味或立體圖來表示。 標記 在採商標註冊標示國家，如美國，圖形「®」表示某個商標經過註冊，並受法律保護，稱作「主要註冊」（Principal Register）。圖形「™」常用來指某個標誌未經註冊通過而作為商標使用，僅具描述（merely descriptive）性質，可申請「輔助註冊」（supplemental register）避免日後其他類似商標註冊混淆，但標示使用上不限商標是否註冊通過。另外，尚有「℠」的服務商標。 目前兩岸三地商標法規中，中國大陸有明確規範「®」及圈內中文化的「注」，香港和台灣則無。 專利 專利流程 3 階段 upload successful 專利申請 繼續閱讀 參考 五南文化 - 著作法參考書 著作權之侵害與救濟：第六章 著作權侵害之救濟的基本問題 認識智慧財產權 - 國立政治大學 Wiki - 商標]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integration by parts - 分部積分法以及常用的分部積分]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F01%2FIntegration-by-parts-%E5%88%86%E9%83%A8%E7%A9%8D%E5%88%86%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E9%83%A8%E7%A9%8D%E5%88%86%2F</url>
    <content type="text"><![CDATA[分部積分法是種積分的技巧常應用於微積分數學與數值分析之中。它是由微分的乘法定則和微積分基本定理推導而來的。其基本思路是將不易求得結果的積分形式，轉化為等價的但易於求出結果的積分形式。 規則 當 \(u = u(x)\) 、 \(du = u&#39;(x)dx\) 、 \(v = v(x)\) 與 \(dv = v&#39;(x)dx\) ， 那分部積分就可以寫為： \[ \int_a^b u(x)v&#39;(x)dx=[u(x)v(x)]_a^b-\int_a^b u&#39;(x)v(x)dx \] \[ \Leftrightarrow u(b)v(b)-u(a)v(a)-\int_a^b u&#39;(x)v(x)dx \] 或是以更常見的簡寫： \[ \int u \; dv = uv - \int v \; du \] 定理 假設 \(u(x)\) 與 \(v(x)\) 是兩個連續可導函數 (continuously differentiable functions). 由乘法定理 (product rule) 可知(用來布尼茲表示法 Leibniz’s notation)： \(\frac{d}{dx} ( u(x) \cdot v(x) ) = \frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx}\) 對兩側求不定積分： \(uv = \int (\frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx})dx\)\(\Leftrightarrow \int d(u(x))\cdot v(x) + \int u(x)\cdot d(v(x))\)\(\Rightarrow \int u \; dv = uv - \int v \; du\) 常用的分部積分 \(\int \ln(x) dx = x\ln(x) - x + C\) \(\int \ln(x)dx\) 令 \(u = \ln(x)\) 、 \(dv = dx\) ， 則 \(du = \frac{1}{x} dx\) 、 \(v = x\) 帶入： \(\int \ln(x) dx = \ln(x) \cdot x - \int x\cdot \frac{1}{x}dx\) \(\Leftrightarrow \ln(x)\cdot x - \int(1)dx\) \(\Leftrightarrow \ln(x)\cdot x - x + C\) \(\int \log (x) dx = x\cdot \log (x) - \frac{x}{\ln 10} + C\) 令 \(u = \log (x)\) 、 \(dv = dx\) ， 則 \(du= d(\log (x)) \Leftrightarrow d(\frac{\ln x}{\ln 10})\) ＜乘法定理＞： 上微下不微 + 下微上不微 \(\Leftrightarrow d(ln x)\cdot \frac{1}{\ln 10} + \ln x\cdot d(\ln 10)\) \(\Leftrightarrow \frac{1}{x}\cdot \frac{1}{\ln 10} + \ln x \cdot 0\) \(\Leftrightarrow \frac{1}{x\ln 10}\) 接著 \(v = x\) 。 \(\int \log x dx = \log x \cdot x - \int x \cdot \frac{1}{x \ln 10} dx\) \(\Leftrightarrow x\cdot \log x - \int \frac{1}{\ln 10} dx\) \(\Leftrightarrow x\cdot \log x - x\cdot\frac{1}{\ln 10} + C\) 參考 Wiki - 分部積分法 Math2.org Math Tables: Integral ln(x) Derivative of Log X]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Integration</tag>
        <tag>Partial Integration</tag>
        <tag>Integration By Parts</tag>
        <tag>logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Neural Networks 類神經網路學習]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F25%2FArtificial-Neural-Networks-%E9%A1%9E%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E5%AD%B8%E7%BF%92%2F</url>
    <content type="text"><![CDATA[Artificial Neural Networks 類神經網路概論( 未完成 ) 簡介 類神經網絡是一種受生物學啟發而產生的一種模擬人腦的學習系統。 Youtube - 介紹神經元與類神經的關係 neuralgraph ↑ 神經元示意圖( *synapse：比重 ) 對於神經(neuron)我們有一個簡單的抽象：每個神經元是與其他神經元連結在一起的，一個神經元會受到多個其他神經元狀態的衝擊，並由此決定自身是否激發。 神經細胞透過輸入神經樹由其它神經細胞輸入脈波訊號後，經過神經細胞核的處理，其處理大約是： 將收集到的訊號作加總 非線性轉換 產生一個新的脈波信號 如果這個訊號夠強，則新的脈波信號會由神經軸傳送到輸出神經樹，再透過神經節將此訊號傳給其它神經細胞。值得注意的是：當訊號經過神經節後，由於神經節加權值的影響，其訊號大小值會改變。 神經網絡裡的結點相互連結決定了輸入的數據在裡面經過怎樣的計算。我們可以通過大量的輸入，讓神經網絡調整它自身的連接情況從而總是能夠得到我們預期的輸出。 neuralgraph2 ＜比較＞電腦裡的模擬神經網路的架構需具備： 模擬頭腦神經的連結( 包含模擬突觸、細胞本體( 隱藏層 )、軸突 ) 每個神經節點 實數的輸入與輸出 極大量的資訊 遷移學習( Transfer learning ) 基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning 實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning 什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？ 感知器 ( Perceptron ) 設有 \(n\) 維輸入的單個感知機( 從其他類神經元接收到的資訊 )，\(a_1\) 至 \(a_n\) 為 \(n\) 維輸入向量的各個分量，\(w_1\) 至 \(w_n\) 為各個輸入分量連接到感知機的權值( 比重 )，\(w_0\) 為偏置( 常數 )，一個神經元( Cell Body )分成兩個步驟，第一個 \(\sum\) 為彙總資料，後面那個 \(f(.)\) 為傳遞函數( 圖上的函數是“Sign function” )，判斷最後輸出的值， 最後以純量輸出( 1 or -1 )。 \[ Input: x_1, x_2, …,x_n \] \[ Output: 1 or -1 \] perceptrongraph 類神經元示意圖 ＜注意＞\(w_0\)不是伴隨其他的資訊傳進神經元的，而是因為某些演算法的需求，而另外多加的一個閾值( 正負常數值 )。 $ _{i = 0}^n W_i X_i$又稱為淨輸入( Net Input )，可處理線性組合的假說空間( Hypotheses )。 sgn_triggerfunction 上圖為此神經元判斷的觸發函數( 每個神經元的判斷都不盡相同，此為其中一種 )，帶入剛剛所算的淨輸入，計算輸出( -1就是判斷為無反應的狀況 )。 權值(\(w\))：如果當前神經元的某個輸入值權值為零，則當前神經元激發與否與這個輸入值無關；如果某個輸入值的權重為正，它對於當前神經元的激發值產生正影響。反之，如果權重為負，則它對激發值產生負影響。 偏移量(\(w_0\))：它定義了神經元的激發臨界值在空間上，它對決策邊界(decision boundary) 有平移作用，就像常數作用在一次或二次函數上的效果。感知器表示為輸入向量與權向量內積時，偏置被引申為權量，而對應的輸入值為 1。 決策邊界(decision boundary)：設輸入向量與權向量的內積為零，可得出 n+1 維的超平面。平面的法向量為 w，並經過 n+1 維輸入空間的原點。法向量指向的輸入空間，其輸出值為+1，而與法向量反向的輸入空間，其輸出值則為−1。故可知這個超平面定義了決策邊界，並把輸入空間劃分為二。 decisionboundery 激勵函數(activation function)：激勵函數代表神經元在什麼輸入情況下，才觸發動作。 activationfunction 感知器可以「學習」的函數 singlelayertwoinputperceptron Consider a 2-input perceptron ( 感知器 ) : It outputs 1 iff \[ o( x_1, x_2 ) = ( w_0+w_1 \cdot x_1+w2 \cdot x2 &gt; 0 )? \] equivalent to \[ o( x_1, x_2 ) = sgn( w_0+w_1 \cdot x_1+w2 \cdot x2 ) \] What weights represent \(AND (x1, x2)\)? \(w_0 = -0.8, w_1 = w_2 = 0.5\)\(o( x_1, x_2 ) \Rightarrow sgn(-0.8 + 0.5 \cdot x_1 + 0.5 \cdot x_2 )\) weighttorepresentAND What weights represent \(OR (x1, x2)\)? \(w_0 = 0.3, w_1 = w_2 = 0.5\)\(o( x_1, x_2 ) = sgn(0.3 + 0.5 \cdot x1 + 0.5 \cdot x2 )\) weighttorepresentOR What weights represent \(NOT (x1, x2)\)? \(w_0 =0.0, w_1 = -1.0, w_2 = 0\)\(o(x_1) = sgn( 0.0 –1.0x_1)\) weighttorepresentNOT What weights represent \(XOR (x1, x2)\)? Not possible. possibletorepresentXOR ＜NOTE＞Not linearly separable \(\rightarrow\) Can not be represented by a single percepton. Solution: use multilayer networks. multilayertorepresentXOR How to Determine a Weight Vector? 如何決定權重向量？ 在類神經網路學習的過程中，最重要的就是權重向量( Weight Vector )，因為這就是決定到時候感知器( Perceptrons )能不能做出正確預測( correct \(\pm 1\) output )的關鍵依據。 通常來說，都會給定一組訓練範例( Trainning example )，而且，每個元素裡必定會含有輸入( Input )與輸出( Output )。 \(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\) 是訓練範例中會給的資訊。 \(+1 \; or \; -1\) 為 \(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\) 的已知輸出( Target value )。 而我們的目標就是將 \(( w_1, w_2, w_3, \ldots , w_{n-1}, w_n )\) 訓練出來。 解決的演算法有很多，在這邊只討論其中兩個： The perception trainnin rule Gradient decent ( or call the delta rule ) Perceptron Training Rule \(t = c(x_1, x_2, x_3, ..., x_n )\) 是我們已知道的結果( 1 or -1 )。 \(o：\)對於訓練資料$ (x_1, x_2, x_3, …, x_n ) $以感知器( Perceptron )測試後出來的結果( 1 or -1 )。 ＜Note＞：Here o is the output of Perceptron, not the target value. 所以 $ ( t - o ) $ 為此時感知器( Perceptron )的誤差，然後藉由我們設定的 \(\eta\) 函式判斷要對目前的 \(w\) 修正多少值。 演算法 Initialize weights (w0, w1, w2, x3, …,wn ) to random values Loop through training examples： \(w_i \leftarrow w_i + \Delta w_i\) Where \(\Delta w_i = \eta (t-o) \cdot x_i\) and \(\eta\) is a learning rate (small positive value, e.g., 0.1) Given training data set \[ D = \{ ( \vec{x}, t ) \} \] 123456789//Initialize all weights w_i to random valuesw[] &lt;- random valuesWHILE not all examples correctly predicted DO FOR each training example x = (x_1, x_2, x_3, ..., x_n ) in D Compute current output o ( x_1, x_2, x_3, ..., x_n ) FOR i = 0 to n // always let x_0=1 w_i w_i + eta(t - o) * x_i ＜Note＞ If (t-o) = 0, no change in weight. 輪過一遍所有訓練資料，稱之為一個時代( Epoch )，若一個時代過後還有 \(w_i\) 是錯誤的就繼續修改 \(w_i\) ，直到某個時代所有的 $ w_i $ 可以讓 $ x_i $ 輸出正確。 ＜注意＞：如果訓練資料是線性可分離( XOR就不可線性分離 )，且\(\eta\)是小於1的很小的值，那麼一定最後可以在有限的世代找到最後的感知器( Perceptron )。 倘若今天的資料是無法被線性分離的改如何處理？ - Approach 1: 建立一個演算法可以努力找到逼近值。 E.g. gradient descent method ( 梯度下降法 ) - Approach 2: 建立不同架構或多層( Multilayer networks )結構的神經網路以突破限制。 Gradient Descent Youtube - Gradient Decent 介紹 我們需要在 \((n+1)\) 維的假說向量空間( Hypotheses Space )中搜索最合適( Best fit )的權值向量，我們需要有一定的規則指導我們的搜索，採用沿著梯度反方向往下走的方法，就稱為「梯度下降法」(Gradient Descent)。這種方法可以說是一種「貪婪演算法」(Greedy Algorithm)，因為它每次都朝著最陡的方向走去，企圖得到最大的下降幅度。即使訓練資料是不可線性分離的( Not lineary separable )，最後這個演算法還是會收斂在極趨近於目標想法的銓重向量停止。 ＜注意＞： Least square為最常用來檢測誤差的方法。 為了要計算梯度，我們不能採用不可微分的 sign() 步階函數，因為這樣就不能用微積分的方式計算出梯度了，而必須改用可以微分的連續函數 sigmoid()，這樣才能夠透過微分計算出梯度。 \[ E(w) = \frac{1}{2} \sum_{d \in D} ( t_d - o_d ) \] 上面公式中\(D\)代表了所有的輸入案例( 或者說是樣本 )，\(d\)代表了一個樣本實例，\(o_d\)表示感知器的輸出，\(t_d\)代表我們預想的輸出。 首先，我們先看看權重( Weight vector )向量 \(w\) 的梯度( Gradient )為何： \[ \bigtriangledown E( w ) = \frac{\partial E}{\partial w} = ( \frac{\partial E}{\partial w_0}, \frac{\partial E}{\partial w_1}, \ldots, \frac{\partial E}{\partial w_n} ) \] ＜注意＞： 梯度 是一個裡面所有元素為對 \(E\) 以對每個 \(w_i\) 偏微分的向量。且這個向量指向的地方為最上坡之處。( 如下圖紅色處顯示，而下方黑色箭頭則表示該梯度投影下來所對應的方向 ) gradient 所以 Gradient Descent 就是該點梯度的 反方向 ，也就是最下坡的方向，\(i.e. \; -\bigtriangledown E(w)\)。 這樣目標就明確了，欲在假說空間找到一組權值 \(w\) 讓這個誤差的值最小，顯然我們用誤差對權值求導將是一個很好的選擇，導數的意義是提供了一個方向，沿著這個方向改變權值，將會讓總的誤差變大，更形象的叫它為梯度。 既然梯度確定了E最陡峭的上升的方向，那麼梯度下降的訓練法則是： \[ \vec{w_i} \leftarrow \vec{w_i} + \Delta \vec{w_i}, \quad where \; \Delta \vec{w_i} = \eta \frac{\partial E}{\partial w_i} \] gradientgraph \(E.x.\) Example: two weights: \(w = (w_0, w_1)\) Error surface \(E\) is parabolic (by definition) Single global minimum Arrow: negated gradient at one point Steepest descent along the surface examplegradient For the least square error function, gradient is easy to calculate: \[ \bigtriangledown E( w ) = \frac{\partial E}{\partial w} = \frac{1}{2} \cdot \frac{\partial \sum_{d \in D} (t_d - o_d)^2}{\partial w_i} = \frac{1}{2} \sum_{d \in D}\frac{\partial (t_d - o_d)^2}{\partial w_i} \] \[ \Rightarrow \frac{1}{2} \cdot \sum_{d \in D} (2 \cdot (t_d - o_d)\frac{\partial( t_d - o_d )}{\partial w_i}) = \sum_{d\in D}((t_d - o_d)\frac{\partial(t_d - w\cdot x_d)}{\partial w_i}) \] \[ \Rightarrow \sum_{d\in D} ((t_d - o_d)(-x_{id})) \] 依上述，公式就可以簡化成： \[ \Delta w_i = -\eta \frac{\partial E}{\partial w_i} \] \[ and \] \[ \frac{\partial E}{\partial w_i} = \sum_{d \in D}((t_d - o_d)(-x_{id})) \] 最後公式變成： gradientdecentfinalformula 參考 Mr’ opengate - AI - Ch16 機器學習(4), 類神經網路 Neural network Wikipedia - 人工神經網路 基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning 實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning 什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Artificial Neural Networks</tag>
        <tag>Gradient Decent</tag>
        <tag>Perceptron trainning rule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervised learning 監督式學習 - Concept Learning 概念學習]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F20%2FSupervised-learning-%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92-br-Concept-Learning-%E6%A6%82%E5%BF%B5%E5%AD%B8%E7%BF%92%2F</url>
    <content type="text"><![CDATA[Supervised learning 監督式學習 - Concept Learning 概念學習 machinelearningconcept 機器學習簡介( 節錄自 Mr’ OpenGate ) 機器學習是近20多年興起的一門多領域交叉學科，涉及機率論、統計學、逼近論、凸分析、計算複雜性理論等多門學科。機器學習理論主要是設計和分析一些讓計算機可以自動「學習」的演算法。機器學習算法是一類從資料中自動分析獲得規律，並利用規律對未知資料進行預測的算法。 機器學習已廣泛應用於數據挖掘、計算機視覺、自然語言處理、生物特徵識別、搜尋引擎、醫學診斷、檢測信用卡欺詐、證券市場分析、DNA序列測序、語音和手寫識別、戰略遊戲和機器人等領域。 ＜定義＞ 機器學習定義如下 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. \(Ex.\) T(任務)：將郵件分類為垃圾或非垃圾。 E(經驗)：觀察目前信箱的信是把哪些種類的郵件標記為垃圾，而哪些是非垃圾。 P(效能)：被正確分類成垃圾或非垃圾的郵件的數量。 supervisedlearningworkflow 一種歸納的方式 從已知的現象訓練機器判斷常態的結果，而已知的現象只有是非之結論。(所以用這個方法訓練出來的智能只能判斷對錯) 所以以這種方法訓練的智能我們可以看待它是一個布林函數(Boolean-valued Funciotn)。 輸入 - 欲判斷的狀態 (Attributes)。 輸出 - 對(TURE)、錯(FALSE)。 learningfunction 環境狀態( Attribute )、學習目標( Target Concept ) Example from book：Enjoy sport conceptlearningenjoysportdata 六個會影響的環境狀態 ( Attribute ) 四個案例 ( Instance ) 學習目標：判斷當時是否很享受運動。\(EnjoySport = \{Yes, No\}\) 環境狀態( Attribute ) 每個事件(instance)發生時會引響結果的基本元素。 倘若現在有一事件會被影響的環境狀態為 \(N\) 個。 每個環境狀態可能出現的狀態個數為 \(n_i\) 。(第 \(i\) 個環境狀態) (Nominal values; symbolic values; Discretized values)(? 待了解) 案例( Instance ) - 已知結果的一群環境狀態 令 \(x\) 為已知結果的一群環境狀態。 那我們稱所有可能產生的案例為一個空間(Space)並稱它 \(X\)。 若 \(M\) 等於此空間 \(X\) 的大小，則 $ M = n_1 n_2 n_{N-1} n_N$。 我們其實可以將 \(M\) 視為此環境狀態所有組合的方法數。 學習目標( Target Concept ) 要學到的想法(在這裡我們給機器訓練的想法也可視為一個函式)。 \(c(x)=1 \qquad if \; EnjoySport=Yes\) \(c(x)=0 \qquad if \; EnjoySport=No\) \(c\) 是一個定義再案例空間(Instance Space)的布林函數。 \(c:X \rightarrow \left\{ 0, 1 \right\}\) 訓練集合 “\(D\)” 所有已知想法的案例集合 \(Ex.\) \[ &lt;x_1, c(x_1)&gt;, &lt;x_2, c(x_2)&gt; \ldots &lt;x_m, c(x_m)&gt; \] 假說( Hypotheses ) - 在這裡我們標記為 \(H\) 定義：所有環境狀態( Attributes )之限制( Constraints ) 的交集( Conjunction )。 限制( Constraints )的種類 Specific value ( 針對值 ) \(\qquad e.g. \; ( sky = sunny )\) Don’t care value ( 不在意值 ) \(\qquad e.g. \; ( sky = &quot;？&quot; )\) No value allow ( 無值 ) \(\qquad e.g. \; ( sky = &quot;\phi&quot; )\) 若今天有一案例( Instance )符合了我們的假說，也就是說它每個環境狀態( Attributes )全部都不逾越我們假說中的所有限制( Constraints )。 \(Ex.\) \[ h \leftarrow &lt; Sunny, Warm, ?, Strong, ?, ? &gt; \] 假說空間( Hypotheses Space )的大小 語意上來說( Syntactically distinct number ) \[ M_H = ( n_1 + 2 ) \cdot ( n_2 + 2 ) \cdot \ldots \cdot ( n_{N-1} + 2 ) \cdot ( n_{N} + 2 ) \] \[ ( Two \; more \; &quot;values&quot; \; have \; been \; added, &quot;?&quot; and &quot;\phi&quot; ) \] 實際上來說( Semantically distinct number ) \[ M_H = 1+ ( n_1 + 1 ) \cdot ( n_2 + 1 ) \cdot \ldots \cdot ( n_{N-1} + 1 ) \cdot ( n_{N} + 1 ) \] 因為如果該假說的限制交集裡，有一個以上的“”存在於集合中，代表所有的案例( Instances )絕對都不可能不逾越我們的假說，全部的案例都會判定為錯誤(False)。 小節論 \(c:EnjoySport : X \rightarrow \{ 0, 1 \}\) 是我們的學習目標( Target Concept )。 六個環境狀態( Attributes )： Sky ( 可能的變數有三種 ) \[\{ Sunny, Cloudy, Rainy \}\] Airtamp ( 可能的變數有兩種 ) \[\{ Warm, Cold \}\] Humidity ( 可能的變數有兩種 ) \[\{ Normal, High \}\] Wind ( 可能的變數有兩種 ) \[\{ Strong, Light \}\] Water ( 可能的變數有兩種 ) \[\{ Cold, Warm \}\] Forecast ( 可能的變數有兩種 ) \[\{ Same, Change\}\] 案例空間的大小 \(= 3 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 = 96\) 假說空間的大小 \(= 1 + ( 4 \cdot 3 \cdot 3 \cdot 3 \cdot 3 \cdot 3 ) = 973\) ( 實際上 ) 現在知道目前的假說空間大小後，就要開始找到符合我們期望( Target )的假說( Hypotheses )，那要從何先下手呢？首先，我們可以先從現有的訓練資料使用，其中，我們還可以了解一個概念－－－Inductive learning hypothesis，意思是說，我們今天使用訓練的資訊來找到一個最靠近的假說時，我們也可以找到一些潛在的的規則包含在我們找到的假說之中，其中會有我們從為訓練過的案例( Instance )在內。 ＜注意＞：在實務上來說，有可能訓練的難度會急遽上升，有可能我們的假說空間會超級大，甚至於無限大也有可能，所以要一個個要從所有的假說找到我們需要的是不太可能的，那怎麼辦呢？我們可以利用假說空間的一個特性－－－Partial Ordering，也就是說，這個空間裡的元素，是可以依照一個順序大小排列的。 假說空間的廣至收斂General-to-Specific Ordering over Hypotheses 首先定義幾個名詞，我們有： - 案例( Instance )：\(x\) - 假說( Hypothesis )：\(h\) - 若今天 \(h(x) = 1\) ，稱之 Positive ( True ) Outcome。 由廣至收斂，定義若 \(H_1 \geq_g H_2\)，則可以說 \(H_1\) 比 \(H_2\)還要更廣( General )，舉例： \[ \{ Sunny, ?, ?, ?, ?, ? \} \geq_g \{ Sunny, ?, ?, Strong, ?, ? \} \] GtoSprap Find S Algorithm 將假說 \(h\) 初始化為假說空間 \(H\) 中的最特殊假說 ${ , , , , , } $ 對每個正例 \(x\) ( ＜注意＞我們只使用正例( Positive Outcome )，不用反例！ ) 對 \(h\) 的每個環境狀態( Attribute )進行約束 如果 \(x\) 的該環境狀態滿足 \(h\) 對應的環境狀態，那麼不做任何處理。 否則將 \(h\) 中該環境狀態一般化( Generalize ) 以滿足 \(x\) 的環境狀態。 重複直到所有正例都被尋遍。 輸出最後唯一的假說 \(h\) ，而這個假說正是我們使用訓練資料中的正例所能訓練出最收斂的假說。 findsalgorithm Version Space Definition: Consistent Hypotheses( 認同假說 ) 若有假說 \(h\) 以訓練集合所有的案例進行測試，輸出結果和我們的想法一致，就可以聲明假說 \(h\) 為認同假說( Consistent Hypotheses )。( 下方為原始定義 ) A hypothesis \(h\) is consistent with a set of training examples \(D\) of target concept \(c\) if and only if \(h(x) = c(x)\) for each training example \(&lt;x, c(x)&gt;\) in \(D\). \[ Consistent (h, D) \equiv ( \; \forall &lt;x, c(x ) \in D \;) h(x) = c(x)) \] Definition: Version Space ( 候選空間 ) 候選空間就是對於該測試的資料集，所有的認同假說所組合的空間，因為每個假說都可以符合目前的訓練資料的期望，所以每個假說都等待我們再進一步驗證。( 下方為原始定義 ) The version space \(VS_{H,D}\) , with respect to hypothesis space \(H\) and training examples \(D\), is the subset of hypotheses from \(H\) consistent with all training examples in \(D\). \[ VS_{H,D} \equiv \{ h \in H \; | \; Consistent (h, D) \} \] versionspacegraph Version space for a “rectangle” hypothesis language in two dimensions. Green pluses are positive examples, and red circles are negative examples. GB is the maximally general positive hypothesis boundary, and SB is the maximally specific positive hypothesis boundary. The intermediate (thin) rectangles represent the hypotheses in the version space. Definition: General Boundary General boundary \(G\) of version space \(VS_{H,D}\) : set of most general members Definition: Specific Boundary Specific boundary \(S\) of version space \(VS_{H,D}\) : set of most specific members Version Space Every member of the version space lies between \(S\) and \(G\) \[ VS_{H,D} \equiv \{ h \in H \; | \; (\exists s \in S ) (\exists g \in G ) (g \geq_g h \; \geq_g s) \} \] \[ where \geq_g \equiv more \; general \; than \; or \; equal \; to \] The List-Then-Elimination Algorithm列表消除演算法 起始化： 候選空間( Version Space ) \(\leftarrow(assign)\) 所有在假說空間的假說。 對每個訓練案例\(&lt;x, c(x)&gt;\) 從候選空間消除所有 \(h(x) \neq c(x)\) 的假說 \(h\)。 對所有的訓練案例檢驗過，最後輸出候選空見剩下的假說列表。 優點 保證最後的假說列表裡的所有假說必定和訓練案例的期望相符( Consistent )。 缺點 若今天假說空間是無窮大，那這個方法就不能使用。 要將該假說空間的所有假說窮舉於列表之中。 Candidate-Elimination Algorithm候選消除演算法 ＜前情提要＞：候選空間( Version Space )可以由 Most specific boundaries 與 Most general boundaries 界定出來。 - 正例可以將 Specific boundary 變的更一般化( General )。 Positive examples force specific boundary to become more general. - 反例可以將 General boundary 變的更收斂( Specific )。 Negative examples force general boundary to become more specific. 最後，這個界定出來的假說集合可以符合所有的訓練資料。 In the end, all hypotheses which satisfy training data remain. 起始化 G \(\leftarrow\) 一組在假說空間 \(H\) 最一般化的環境因素。標記為：\(&lt;?, \ldots, ?&gt;\) S \(\leftarrow\) 一組在假說空間 \(H\) 最嚴苛的環境因素。標記為：\(&lt;\phi, \ldots, \phi&gt;\) 對於每個訓練案例 \(d\)，進行以下操作： 若 \(d\) 為一正例： 從 \(G\) 中移除所有與 \(d\) 不一致的假說。 對 \(S\) 中每個對 \(s\) 不一致的假說\(s\)： 將 \(s\) 從 \(S\) 之中移去。 把 \(s\) 的所有的極小泛化假說 \(h\) 加入到S中，其中 \(h\) 滿足 \(h\)與\(d\)一致，且\(G\)的其中一個元素必比起 \(h\) 更泛化。 從\(S\)中移去所有符合這樣的假說：它比S中另一假設更泛化。 若 \(d\) 為一反例： 從 \(S\) 中移去所有 \(d\) 不一致的假說。 對 \(G\) 中每個與 \(d\) 不一致的假設 \(g\)： 從 \(G\) 中移去 \(g\) 。 把 \(g\) 的所有的極小特化式 \(h\) 加入到 \(G\) 中，其中 \(h\) 滿足 \(h\) 與 \(d\) 一致，而且 \(S\) 的某個成員比 \(h\) 更收斂。 從 \(G\) 中移去所有符合這樣的假說：它比 \(G\) 中另一假說更特殊。 範例 - \(EnjoySport\) 起始化 Specific boundary to: \(S_0 = \{(Ø,Ø,Ø,Ø,Ø,Ø)\}\) General boundary to: \(G_0 = \{(?,?,?,?,?,?)\}\) 1’st instance: (Sunny,Warm,Normal,Strong,Warm,Same) = Yes Positive example generalizes Specific boundary \(S_1 = \{ (Sunny,Warm,Normal,Strong,Warm,Same)\}\) \(G_1 = \{ (?,?,?,?,?,?)\}\) 2’nd instance: (Sunny,Warm,High,Strong,Warm,Same) = Yes Positive example generalizes Specific boundary \(S_2 = \{(Sunny,Warm,?,Strong,Warm,Same)\}\) \(G_2 = \{ (?,?,?,?,?,?)\}\) 3’rd instance: (Rainy,Cold,High,Strong,Warm,Change) = No Negative example specializes General boundary \(S_3 = \{ (Sunny,Warm,?,Strong,Warm,Same) \}\) \(G_3 = \{(Sunny,?,?,?,?,?), \quad O.K.\) \((Cloudy,?,?,?,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,Warm,?,?,?,?), \quad O.K.\) \((?,?,Normal,?,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,Light,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,?,Cool,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,?,?,Same)\} \quad O.K.\) \(\Rightarrow G_3 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?), (?,?,?,?,?,Same)\}\) 4’th instance: (Sunny,Warm,High,Strong,Cool,Change) = Yes Positive example generalizes Specific boundary \(S_4 = \{ (Sunny,Warm,?,Strong,?,?) \}\) \(G_4 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?) \}\) Final version space is all hypotheses, h such that: \[ g \geq_ g h \; \geq_g s \] candidate-eliminationalgorithm candidate-eliminationalgorithm2 What query should the learner make next? How should these be classified? \[ &lt;Sunny, Warm, Normal, Strong, Cool, Change&gt; \] \[ &lt;Rainy, Cold, Normal, Light, Warm, Same&gt; \] \[ &lt;Sunny, Warm, Normal, Light, Warm, Same&gt; \] Inductive Bias 歸納偏置 ( 未完待補 ) 需要某些的預先設定( 偏見 )。 參考 Mr’ OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning 《机器学习》第2章中find-s算法的python实现 WEKIPEDIA - Version space learning robert_ai - ML一（概念学习和一般到特殊序）]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Concept Learning</tag>
        <tag>Supervised Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[機器學習地圖]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F20%2F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%9C%B0%E5%9C%96%2F</url>
    <content type="text"><![CDATA[機器學習地圖 類別 監督學習 (Supervised learning)：從給定的訓練數據集中學習出一個模式（函數 / learning model），當新的數據到來時，可以根據這個模式預測結果。監督學習的訓練集要求是包括輸入和輸出，也可以說是特徵和目標。訓練集中的目標是由「人」標註的。常見的監督學習算法包括回歸分析和統計分類( Classify )。 無監督學習 (unsupervised learning)：與監督學習相比，訓練集沒有人為標註的結果。常見的無監督學習算法有聚類( Cluster )。 半監督學習 (Semi-supervised learning)：介於監督學習與無監督學習之間。 增強學習 (reinforcement learning)：通過觀察來學習做成如何的動作。每個動作都會對環境有所影響，學習對象根據觀察到的周圍環境的反饋( 獎勵 )來做出判斷。 機器學習演算法種類 構造條件機率：回歸分析和統計分類 人工神經網絡 決策樹 高斯過程回歸 線性判別分析 最近鄰居法 感知器 徑向基函數核 支持向量機 通過再生模型構造機率密度函數： 最大期望算法 graphical model：包括貝葉斯網和Markov隨機場 Generative Topographic Mapping 近似推斷技術： 馬爾可夫鏈 蒙特卡羅方法 變分法 最優化：大多數以上方法，直接或者間接使用最優化算法。 machinelearningmap kindofmachinelearning 參考 Mr’ OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decision Tree Learning]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F18%2FDecision-Tree-Learning%2F</url>
    <content type="text"><![CDATA[Decision Tree Learning 決策樹學習 簡介 最受歡迎的歸納推理演算法( inductive inference algorithm )。 廣泛且實務的方法。 對於干擾值( Noise )相當敏感。 可用來學習如何以聯集( Disjunctive )表示限制集( Constraints )。 ( Concept Learning 以交集( Conjunctive )表示 ) 呈現的方式相當簡單。 樹狀結構( Tree Structure )、若則表示式( If-Then rules ) \(Ex.\) Play Tennis 範例訓練資料( Training Example ) decisiontreelearning_training example 決策樹( Decision Tree ) decisiontreelearning_exampletree 決策樹( Decision Tree )的介紹 決策樹表示法( Decision Tree Representation ) 每個內節點 Internal node ( 包括根結點 Root node )代表對一個環境狀態( Attribute )檢驗。 而分支( Branch )出來的意義我們可以視為是該環境狀態( Attribute )的一種可能值( Attribute value )。 每個葉節點 Leaf node 給予一個適當的分類結果( Classification )。 我們將每個案例( Instances )分類到一個離散的類別( Categories )之中。 藉由決策樹由根結點至葉節點找到該類別。 決策樹引導的假說( Hypotheses ) 先 AND 再 OR ( 原文：Disjunctions (OR’s) of conjunctions (AND’s) )。 經由根結點往葉節點走可視為是一種對於該環境狀態限制的交集( Conjunction of constraints on attributes )。 而連上兄弟節點( Sibling )的兩個邊( Edges )可視為是一種對於該環境狀態限制的聯集( Separate branches are disjunctions )。 \(Ex \; ( Cont. )\) (Outlook=Sunny and Humidity=Normal) or (Outlook=Overcast) or (Outlook=Rain and Wind=Weak) 注意！ 每個用來訓練的案例 ( Instances )都必須要以「因素-結果」( Attribute - value pairs )的方式給予訓練。 目標訓練函式 ( Target function )的值域是離散的值 ( Discrete value )。 這種方法最後呈現的假說 ( Hypotheses )有可能是一些環境狀態限制( Constraints on attributes )的聯集( Disjunctive )。 極有可能會被不乾淨的資料( Noise )擾亂了學習。 應用於： 醫療或是設備的診斷。 信用額度分析( 銀行 )。 決策樹的種類 世界上有許多有特殊的決策樹演算法( decision-tree algorithms )，比較著名的有： - ID3 (Iterative Dichotomiser 3) - C4.5, C5.0 (successor of ID3) - CART (Classification And Regression Tree) - CHAID (CHi-squared Automatic Interaction Detector). - MARS: extends decision trees to handle numerical data better. 注意 ID3 is the algorithm discussed in textbook.( 在書本中有更詳細的介紹 ) Simple, but representative. ( 簡單但representative? ) Source code publicly available. ( 程式碼是開放的 ) ID3演算法 概述：Top-down, greedy search through space of possible decision trees. ( 在所有可以出現的決策樹中用貪心法由上而下找到較佳的那棵樹。 ) ID3在建構決策樹過程中，以資訊獲利(Information Gain)為準則，並選擇最大的資訊獲利值作為分類屬性。這個算法是建立在奧卡姆剃刀的基礎上：越是小型的決策樹越優於大的決策樹。儘管如此，該算法也不是總是生成最小的樹形結構，而是一個啟發式算法。另外，C4.5算法是ID3的升級版。 Decision trees represent hypotheses, so this is a search through hypothesis space. ( 決策樹亦也代表是一種假說，所以這個演算法也可以說是在所有的假說中找到一個較佳的假說。 ) 那個演算法該如何起手呢？ 決定甚麼環境因素( Attribute )應該放在根結點( Root node )？ 接著由上而下( Top-down )的建構決策樹，對每個後繼的節點( Successive node )使出一樣的決策手段選出該節點應該置入何種環境因素( Attribute )。 注意！千萬不要由下往上參考之前選過的值，因為我們以貪心法則，所以目前的最佳解決不可能出現在之前選過的環境因素( Attribute )之中，或是受其干擾。 ( Never backtracks to reconsider earlier choices. ) 同上述，在每次的選擇之中，由於我們認知這種情況適用貪心法( Greedy Method )，所以我們每次環境因素( Attribute )的選擇都朝向我們最後最佳的假說靠近。 虛擬碼( Pseudo Code ) 12341. 使用屬性計算與之相關的樣本熵值2. 選取其中熵值最小的屬性(資訊獲利最大)3. 生成包含該屬性的節點4. 遞迴直到終止 decisiontreelearning_builddecisiontree_algorithm decisiontreelearning_howtochoosenode ＜討論＞ ID3演算法的終極目標，就是要將決策樹中每個節點都擺上最優的環境因素( Attributes )。 \(Question.\) 到底以甚麼條件決定甚麼因素要擺放於哪個節點？ \(Answer.\) 資訊獎賞 or 資訊獲利( Information gain )。 - 資訊獲利( Information gain ) 統計該價值以檢視該環境因素置於何處來分類我們的資料，我們使用熵( entropy 又稱“亂度” )來定義這邊的資訊獲利( Information gain )。( 原文：Statistical quantity measuring how well an attribute classifies the data. Use entropy to define information gain. ) ID3 和 C4.5 - Information gain ( 資訊獲利 ) 與 Gain ratio 定義 關心其中一個環境因素( Attribute )\(A\) 的資訊獲利( Information gain )我們標記為 \(Gain( S, A )\)，且我們關心的目標樣本群體為 \(S\)，其中： \[Gain( S, A ) = Entropy( S ) - \sum_{ v \in Values(A) } ( \frac{S_v}{S}Entropy(S_v) )\] - \(v\) ranges over values of \(A\) - \(S_v\): members of \(S\) with \(A = v\) - \(1^{st}\) term: the entropy of \(S\) - \(2^{nd}\) term: expected value of entropy after partitioning with \(A\) Example： PlayTennies 四個環境變因 Outlook = {Sunny, Overcast, Rain} Temperature = {Hot, Mild, Cool} Humidity = {High, Normal} Wind = {Weak, Strong} 欲看討的結果 - 開心或是不開心( Target Attributes - Binary ) PlayTennis = {Yes, No} 今天有14組訓練資料 9筆的結果是開心的 ( Positive ) 5筆的結果是不開心的( Negative ) 訓練資料表 decisiontreelearning_trainningdataform Step 1. 計算整體的亂度( Entropy ) \(N_\oplus = 9, N_\ominus = 5, N_{Total} = 14\) \(Entropy( S ) = -\frac{9}{14} \cdot \lg (\frac{9}{14}) - \frac{5}{14} \cdot \lg ( \frac{5}{14} ) = 0.940\) Step2. 不斷計算資訊獲利( 找亂度比較低attribute的 )，選擇最大值當作根結點 Outlook Outlook = Sunny \[N_\oplus = 2, N_\ominus = 3, N_{Sunny} = 5\] \[Entropy(S_{Sunny}) = -(\frac{2}{5})\cdot \log_2(\frac{2}{5}) - (\frac{3}{5}) \cdot \log_2(\frac{3}{5}) = 0.971\] Outlook = Overcast \[N_\oplus = 4, N_\ominus = 0, N_{Overcast} = 4\] \[Entropy(S_{Overcast}) = -(\frac{4}{4})\cdot \log_2(\frac{4}{4}) - (\frac{0}{4}) \cdot \log_2(\frac{0}{4}) = 0.0\] Outlook = Rain \[N_\oplus = 3, N_\ominus = 2, N_{Rain} = 5\] \[Entropy(S_{Rain}) = -(\frac{3}{5})\cdot \log_2(\frac{3}{5}) - (\frac{2}{5}) \cdot \log_2(\frac{2}{5}) = 0.971\] 計算環境因素的 Outlook 之資訊獲利 \[Gain(S, Outlook) = Entropy(S) - (N_{Sunny} / N_{total}) * Entropy(S_{Sunny})\] \[ - (N_{Overcast} / N_{total}) * Entropy(S_{Overcast})\] \[ - (N_{Rain} / N_{total} ) * Entropy(S_{Rain})\] \[\Rightarrow 0.940 - (5/14) \cdot 0.971 - (4/14) \cdot 0.00 - (5/14) \cdot 0.971 = 0.246\] Temperature Repeat process over { Hot, Mild, Cool } \[ Gain( S, Temperature ) = 0.029 \] Humidity Repeat process over { High, Normal } \[ Gain( S, Humidity ) = 0.151 \] Wind Repeat process over { Weak, Strong } \[ Gain( S, Wind ) = 0.048 \] 再來，我們要找到最佳的資訊獲利( Information gain )，其中： \[Gain(S, Outlook) = 0.246\] \[ Gain( S, Temperature ) = 0.029 \] \[ Gain( S, Humidity ) = 0.151 \] \[ Gain( S, Wind ) = 0.048 \] 從亂度的點看來，似乎Outlook的亂度最低( 與宇亂度相減後剩餘比較多資訊獲利 )，所以我們選擇Outlook作為我們根結點( root node )，如下圖： decisiontreelearning_choosenode 選擇了Outlook做為決策樹的根結點後，緊接著，我們可以將三種不同的Outlook作為分支，其中特別的是，Overcast狀態之中( 上圖中間綠色部分 )，全部皆為開心狀態( Positive outcome )，所以可以直接決定Overcast輸出為開心( Positive )。 Step 2. Conti. - 選擇下一個節點( 子樹的根結點 ) ( 從何子節點開始建子樹？ I don’t know yet. ) Same steps as earlier but only examples sorted to the node are used in Gain computations.( 無法理解 ) 選一個點( 隨機？ )繼續建子樹 Outlook = Sunny \[Gain(S_{Sunny}, Humidity) = 0.97 - (3/5) \cdot 0 - (2/5) \cdot 0 = 0.97 bits\] \[Gain(S_{Sunny}, Temperature) = 0.97 - (2/5) \cdot 0 - (2/5) \cdot 1 - (1/5) \cdot 0 = 0.57 bits\] \[Gain(S_{Sunny}, Wind) = 0.97 - (2/5) \cdot 1 - (3/5) \cdot 0.918 = 0.019 bits\] 由上式可以看出來Humidity的亂度最小，所以選擇之為此子樹的根。 Final Decision Tree decisiontreelearning_finaldecisiontree 熵、亂度 (Entropy) 介紹 在資訊理論中，熵被用來衡量一個隨機變數出現的期望值(機率與統計)。它代表了在被接收之前，訊號傳輸過程中損失的資訊量，又被稱為資訊熵。熵是對不確定性的測量。在資訊界，熵越高則能傳輸越多的資訊( 資訊越多意味著有更多的可能性 )，熵越低則意味著傳輸的資訊越少( 資訊越少意味著有更少的可能性 )。 如果有一枚理想的硬幣，其出現正面和反面的機會相等，則拋硬幣事件的熵等於其能夠達到的最大值。我們無法知道下一個硬幣拋擲的結果是什麼，因此每一次拋硬幣都是不可預測的。( 越是不可預測的結果 \(\rightarrow\) 亂度越大，而這種結果，正是造成人類選擇障礙的原因，所以我們希望熵越低越好，我們可以立即做出判斷 ) \(Ex1.\) 使用一枚正常硬幣進行拋擲，這個事件的熵是一位元，若進行n次獨立實驗，則熵為\(n\)，因為可以用長度為 \(n\) 的位元流表示。但是如果一枚硬幣的兩面完全相同，那個這個系列拋硬幣事件的熵等於零，因為結果能被準確預測。 \(Ex2.\) \(Let \; y \; be \; a \; Boolean \; function, and \; let \; P \; denote \; Probability.\) What is the most pure (亂度低) probability distribution? \[P(y = 0) = 1, P(y = 1) = 0\] \[P(y = 0) = 0, P(y = 1) = 1\] What is the most impure (亂度高) probability distribution? \[P(y = 0) = 0.5, P(y = 1) = 0.5\] 意同於最大的亂度。 定義 首先，我們可以先從簡單的看討當目前的結果最多只有兩種情況，如拋硬幣，最多只有正面或是反面，下圖\(x\)軸\(P_\oplus\)代表擲出正面的機率函數，而\(y\)軸則是對應的熵值，而\(P_\ominus\)的機率軸則是會隨著\(P_\oplus\)下降而上升( 兩者互補 )，但是對應到的熵值會一樣大。 decisiontreelearning_entropygraph \(S\) is a sample of training examples( 隨機變量 ). 當今天的結果只有正與反 ( 與硬幣一樣 )時，觀察目前的隨機變量 - 我們令： - \(P_\oplus\) ( 就目前隨機變數產生的機率 ) is the portion of the positive examples ( 正面 ) in \(S\). - \(P_\ominus\) ( 就目前隨機變數產生的機率 ) is the portion of the negative examples ( 反面 ) in \(S\). Entropy ( 熵 ) measures the impurity ( 亂度 ) of \(S\). 我們先定義熵值 ( Entropy ) 如下： \[ Entropy( S ) = E( I( S ) ) = E(- \ln ( P ( S ) ) ) \] 其中，\(E\)為期望函數，\(I( S )\)是 \(S\) 的資訊量（又稱為資訊本體），\(I( S )\)也是一個隨機變數。 所以在取硬幣的樣本( \(S\) )完後，我們可以將熵值寫成： \[ Entropy( S ) = \sum_{i = 1}^{2} P(S_i)I(S_i)\] \[ \Rightarrow -\sum_{i = 1}^{2} P(S_i)\log_{2} P(S_i) \] \[ \Rightarrow -P_{\oplus}\log_2 P_{\oplus} - P_{\ominus}\log_2 P_{\ominus}\] ＜Note＞ \[\sum_{i = 1}^N P_i = 1 \; and \; 0 \leq P_i \leq 1 \] 推廣至一般式 decisiontreelearning_generalentropygraph 當取自有限的樣本時，熵的公式可以表示為： \[H(X) = \sum _{i} P(x_i) \, I(x_i)=-\sum_i P(x_i)\log _b P(x_i)\] 在這裏 \(b\) 通常是\(2\),自然常數 \(e\)，或是\(10\)。當\(b = 2\)，熵的單位是\(bit\)；當\(b = e\)，熵的單位是\(nat\)；而當\(b = 10\),熵的單位是\(Hart\)。 ＜Note＞ 定義當\(P_i = 0\)時，對於一些 \(i\) 值，對應的被加數 \(0 \log_b 0\) 的值將會是 \(0\)，這與極限一致。 \[ \Rightarrow \lim_{p\to0+} ( p\log p ) = 0 \] CART (Classification and Regression Tree) 見 Mr’ opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree 決策樹學習的常見問題 避免過度適配資料( Prevent Overfitting ) 首先，相較於很冗長的樹，在機器學習中其實比較偏向於比較矮的樹，然而，為何？我們可以由Occam’s Razor ( 奧坎剃刀 )得知，若有兩個假說同時都能解釋該現象，我們偏向於比較沒那麼嚴個的假說( 可以表達比較廣的概念 )。過度配適是指模型對於範例的過度訓練，導致模型記住的不是訓練資料的一般特性，反而是訓練資料的局部特性。對測試樣本的分類將會變得很不精確。 ＜注意＞通常過度適配發生在訓練範例含有雜訊和離異值時，但當訓練數據沒有雜訊時，過度適配也有可能發生，特別是當訓練範例的數量太少，使得某一些屬性「恰巧」可以很好地分割目前的訓練範例，但卻與實際的狀況並無太多關係。 decisiontreelearning_overfitting1 decisiontreelearning_overfitting2 解決方案：修剪決策樹移除不可信賴的分支 事前修剪 (Prepruning) : 透過決策樹不再增長的方式來達到修剪的目的。選擇一個合適的臨界值往往很困難。 事後修剪 (Postpruning) : 子樹置換 (Subtree Replacement)：選擇某個子樹，並用單個樹葉來置換它。 子樹提升 (Subtree Raising)： decisiontreelearning_subtreeraising 合併連續值屬性 透過動態地定義新的離散值屬性來實現，即先把連續值屬性的值域分割為離散的區間集合，或設定門檻值以進行二分法。 屬性選擇指標的其他度量標準 訊息獲利 : 趨向於包含多個值的屬性 獲利比率 : 會產生不平均的分割，也就是分割的一邊會非常小於另一邊 吉尼係數 : 傾向於包含多個值的屬性，當類別個數很多時會有困難，傾向那些會導致平衡切割並且兩邊均為純粹的測試 ＜尚有其他的度量標準，也都各有利弊＞ 例題 A data set has 4 Boolean variables. What is the maximum number of leaves in a decision tree? \(2^4\) To each leaf in the decision, the number of corresponding rule is 1 If a decision tree achieves 100% accuracy on the training set, then it will also get 100% accuracy on the test set? No Using information gain to pick attributes, decision tree learning can be considered A* search algorithm. No A decision tree can describe any Boolean function? Yes 補充 C4.5 演算法 C4.5演算法利用屬性的獲利比率(Gain Ratio)克服問題，獲利比率是資訊獲利正規化後的結果。求算某屬性A的獲利比率時除資訊獲 利外，尚需計算該屬性的分割資訊值(Split Information) : SplitInfoA(S)=∑t∈T|Sj||S|×log2|Sj||S| C4.5的改善：對連續屬性的處理 改善ID3傾向選擇擁有許多不同數值但不具意義的屬性：之所以使用獲利比率(Gain Ratio)，是因為ID3演算法所使用的資訊獲利會傾向選擇擁有許多不同數值的屬性，例如：若依學生學號(獨一無二的屬性)進行分割，會產生出許多分支，且每一個分支都是很單一的結果，其資訊獲利會最大。但這個屬性對於建立決策樹是沒有意義的。 C5.0 演算法 C5.0 是 C4.5的商業改進版，可應用於海量資料集合上之分類。主要在執行準確度和記憶體耗用方面做了改進。因其採用Boosting方式來提高模型準確率，且佔用系統資源與記憶體較少，所以計算速度較快。其所使用的演算法沒有被公開。 C5.0 的優點： C5.0模型在面對遺漏值時非常穩定。 C5.0模型不需要很長的訓練次數。 C5.0模型比較其他類型的模型易於理解。 C5.0的增強技術提高分類的精度。 參考 Mr’ opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree Wiki - 熵 - 資訊理論 奧坎剃刀]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Decision Tree Lrearning</tag>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有關字串的名詞解釋]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F21%2F%E6%9C%89%E9%97%9C%E5%AD%97%E4%B8%B2%E7%9A%84%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B%2F</url>
    <content type="text"><![CDATA[字元 (character)： 孤單的一個符號。’7’,’1’, ’ 阿’, ’2’, ’ a’, ’ X’ 2. 字元集 (Alphabet)： 由字元組成的集合，通常會用\(\sum\)表示。 3. 字串 (String)： 由字元集中的字元構成的序列。”7122” 4. 子字串 (Substring)： 字串中的一段連續字元。”71” in ”7122” 5. 子序列 (Subsequence)： 字串中不需連續的一斷字元。”72” in ”7122” 6. 前綴 (Prefix)： 一個子字串包含第一個字元。”7”, ”71”, ”712”, ”7122” in ”7122”，在這裡所有文章我會命名為前總和，方便閱讀。 7. 後綴 (Suffix)： 一個子字串包含最後一個字元。”2”, ”22”, ”122”, ”7122” in ”7122”，，在這裡所有文章我會命名為後總和，方便閱讀。 8. 字典序 (Alphabetical Order)： 定義字串間的大小。先定義字元間的大小：\[’\,’ &lt; ’a’ &lt; ’b’ &lt; ’c’ &lt; ’d’ &lt; …&lt; ’z’\]通常就是照著 ASCII 碼的編排順序，要注意的是 空字元 比其他字元都小 接下來從第一個位置一位一位比對，由左而右比對方小的就是比較小的字串。 9. 後綴數組 (Suffix Array)： 將一個字串的所有後綴(後總和) ，照字典序排序後，所得的名次陣列。\[Sa[i]: 第i個後綴\] 10. 排名數組 (Rank Array)： 為後綴數組的逆數組。\[Ra[i]: 第 i 個後綴是*第幾名*\] 11. 最長共同前綴 (Longest Common Prefix)： 兩個字串，從第一位一位一位比對，直到不一樣就停止 \(ex:\) ’712221212’ 和’712222222’ 的LCP(最長共同前綴)：’71222’。 12. lcp(I, J)： 對於一個字串，他的第 I 個後綴和第 J 個後綴的 LCP 有多長 13. LCP(I, J)： 對於一個字串，他的第 I 名後綴與第 J 名後綴的 LCP 有多長 14. height[i]： 對於一個字串，LCP(i − 1, i) 15. h[i]： 對於一個字串，LCP(Ra[i] − 1, Ra[i]) # 參考 建國中學 2012 年資訊能力競賽培訓講義 - 08]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z - algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F19%2FZ-algorithm%2F</url>
    <content type="text"><![CDATA[這個演算法可以線性時間在一段文本(text) 裡面找到所有我們欲求的段落(pattern)。 今天，當我們的文本(text)的長度為 \(n\) 且欲求的段落(pattern)為 \(m\)時 ，搜尋只需要線性長度的時間 \(O(m+n)\) 即可，雖然這個演算法需要的空間(space complexity)與時間複雜度(time complexity)都與KMP algorithm一致，但是這個演算法比起KMP algoritjm還要容易了解。 KMP algorithm：每個前綴與其後綴的次長共同前綴（最長的後綴） Z algorithm：每個後綴與母字串的最長共同前綴（單純的長度） 首先，我們需要一個 \(Z\)陣列(\(Z\) array) \(Z\)陣列 當我們將欲檢索的文本存為一個字串 $ str[0 \ldots n-1] $ 時，同時也建立一個與字串一樣長的\(Z\)陣列。 在\(Z\)陣列中，第 \(i\) 元素紀錄「最長共同前總和 (Longest Common Prefix)的長度」，而 LCP 的長度 是由「從 \(i\) 開始的後總和 (Postfix)」與「該文本」共同決定。 ( 注意： \(Z[0]\) 毫無意義可言，因為從第0個開始的後總和(Postfix) 必與原本的文本字串相同。 ) 大致上我們可以看成如下的函式： Z演算法的表示法 \(Ex.\) 123Index 0 1 2 3 4 5 6 7 8 9 10 11 Text a a b c a a b x a a a zZ values 1 0 0 3 1 0 0 2 2 1 0 \(More\) \(ex.\) 12345678str = &quot;aaaaaa&quot;Z[] = &#123;x, 5, 4, 3, 2, 1&#125;str = &quot;aabaacd&quot;Z[] = &#123;x, 1, 0, 2, 1, 0, 0&#125;str = &quot;abababab&quot;Z[] = &#123;x, 0, 6, 0, 4, 0, 2, 0&#125; \(Z\) 陣列如何幫助演算法加速? 這個演算法的想法是將段落(pattern)與文本字串(text string)連接起來，若視段落(pattern)為「P」，視文本字串(text string)為「T」，並加上一個從未在段落與文本中出現過的字元「\$」再產生出如「P$T」的字串。 最後，我們再產生一個屬於「P$T」的 Z陣列，在 Z陣列之中，若該 Z值等於段落(pattern)的長度，段落出現在該處。 12345678910Example:Pattern P = &quot;aab&quot;, Text T = &quot;baabaa&quot;The concatenated string is&quot;a, a, b, $, b, a, a ,b ,a, a&quot;.Z array for above concatenated string is &#123;x, 1, 0, 0, 0, 3, 1, 0, 2, 1&#125;. ^Since length of pattern is 3, the value 3 in Z array indicates presence of pattern. 如何建立 \(Z\)陣列 最簡單的就是使用兩個迴圈，外層迴圈將整個「P$T」跑過一遍，內層迴圈則是看看到底 i 位置的後總和與「P$T」的LCP長度為何。 \(Time\) \(complexity:\) \[O(n^2)\] 我們當然可以使用另一種方法讓建立陣列的時間複雜度降低。 此演算法的關鍵在於要維護一個區間\([L \ldots R]\)，\(R\) 的位置代表由 \(L\) 處之後可以和整個字串最長的前總和重疊到的最後一個位置( 換句話說：\([L \ldots R]\)是整個字串的前綴子字串 )，若完全不重疊，則 \(L\) 與 \(R\)相等。 步驟 (\(i\) 為當前位置) 若 \(i &gt; R\) ，就代表當前 \(i\) 沒有經過任何「P$S」的前綴子字串，所以重置 \(L\) 與 \(R\) 的位置(\(L = i, R = i\))，經由比對「P$S」的前綴與 \(i\) 之後的前綴，並找出最長的子字串(\(R\) 的位置)，計算新的 \(L\) 與 \(R\) 的位置，也一併將 \(Z[i]\)值算出來(\(= R - L + 1\))。 若 \(i \leq R\) ，令 \(K = i - L\) ，再來我們知道 \(Z[i] \geq min(Z[K], R-i+1)\) 因為\(String[i \ldots]\)與\(String[K\ldots]\)共同前\(R-i+1\)個字元必然為[P$T]的前綴子字串。現在有兩種情形會發生： case1： 若\(Z[K] &lt; R-i+1\) ，代表沒有任何「P$S」的前綴子字串 從 \(i\) 位置開始(否則 \(Z[K]\) 的值會更大)，所以也意味著\(Z[i] = Z[K]\)，還有區間\([L\ldots R]\)不變。 case2： 若\(Z[K] \geq R-i+1\)，代表\(String[i \ldots]\)可以和\(String[0\ldots]\) 繼續比對相同的字元，也就意味有可能拓展\([L \ldots R]\) 區間，因此，我們會設 \(L = i\) ，接著從 \(R\) 之後開始繼續比對「P$S」的前綴子字串，最後我們會得到新的\(R\)，並更新\([L \ldots R]\) 區間與計算 \(Z[i]\) \(( = R - L + 1)\)。 想要了解上述的演算法可以經由這個連結觀看動畫。 小視窗 Z演算法的子問題 如果一個位置 \(i\) 位於之前比過的那段 \([L, R]\) 當中，他是否跟 \(Z[i − L]\) 相同呢？我們可以分成三種情形： 1. 要比的後綴根本不在以前比過的範圍\([L, R]\)內 → 就去比吧！ 2. 要比的後綴在以前比過的範圍\([L, R]\)但長度未知 → 還是去比吧！ 3. 要比的後綴在以前比過的範圍\([L, R]\)但長度已知 → 直接記錄囉！ 程式碼實作 台大資工PPT by nkng 12345678910void z_build(const char *S, int *Z) &#123; Z[0] = 0; int bst = 0; for(int i = 1; S[i]; i++) &#123; if(Z[bst] + bst &lt; i) Z[i] = 0; else Z[i] = min(Z[bst]+bst-i, Z[i-bst]); while(S[Z[i]] == S[i+Z[i]]) Z[i]++; if(Z[i] + i &gt; Z[bst] + bst) bst = i; &#125;&#125; Z algorithm - GeeksforGeeks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// A C++ program that implements Z algorithm for pattern searching#include&lt;iostream&gt;using namespace std; void getZarr(string str, int Z[]); // prints all occurrences of pattern in text using Z algovoid search(string text, string pattern)&#123; // Create concatenated string "P$T" string concat = pattern + "$" + text; int l = concat.length(); // Construct Z array int Z[l]; getZarr(concat, Z); // now looping through Z array for matching condition for (int i = 0; i &lt; l; ++i) &#123; // if Z[i] (matched region) is equal to pattern // length we got the pattern if (Z[i] == pattern.length()) cout &lt;&lt; "Pattern found at index " &lt;&lt; i - pattern.length() -1 &lt;&lt; endl; &#125;&#125; // Fills Z array for given string str[]void getZarr(string str, int Z[])&#123; int n = str.length(); int L, R, k; // [L,R] make a window which matches with prefix of s L = R = 0; for (int i = 1; i &lt; n; ++i) &#123; // if i&gt;R nothing matches so we will calculate. // Z[i] using naive way. if (i &gt; R) &#123; L = R = i; // R-L = 0 in starting, so it will start // checking from 0'th index. For example, // for "ababab" and i = 1, the value of R // remains 0 and Z[i] becomes 0. For string // "aaaaaa" and i = 1, Z[i] and R become 5 while (R&lt;n &amp;&amp; str[R-L] == str[R]) R++; Z[i] = R-L; R--; &#125; else &#123; // k = i-L so k corresponds to number which // matches in [L,R] interval. k = i-L; // if Z[k] is less than remaining interval // then Z[i] will be equal to Z[k]. // For example, str = "ababab", i = 3, R = 5 // and L = 2 if (Z[k] &lt; R-i+1) Z[i] = Z[k]; // For example str = "aaaaaa" and i = 2, R is 5, // L is 0 else &#123; // else start from R and check manually L = i; while (R&lt;n &amp;&amp; str[R-L] == str[R]) R++; Z[i] = R-L; R--; &#125; &#125; &#125;&#125; // Driver programint main()&#123; string text = "GEEKS FOR GEEKS"; string pattern = "GEEK"; search(text, pattern); return 0;&#125; 建國中學 2012 年資訊能力競賽培訓講義 - 08 123456789101112void Z_maker( int z[], char s[], int n )&#123; z[0] = n; int L = 0, R = 0, i, x; for( i = 1 ; i &lt; n ; i++ )&#123; if( R &lt; i || z[i-L] &gt;= R-i+1 )&#123; R &lt; i ? x = i : x = R+1; while( x &lt; n &amp;&amp; s[x] == s[x-i] ) x++; z[i] = x-i; if( i &lt; x )&#123; L = i; R = x-1; &#125; &#125; else z[i] = z[i-L]; &#125;&#125; Z algorithm - codeforces 12345678910111213141516int L = 0, R = 0;for (int i = 1; i &lt; n; i++) &#123; if (i &gt; R) &#123; L = R = i; while (R &lt; n &amp;&amp; s[R-L] == s[R]) R++; z[i] = R-L; R--; &#125; else &#123; int k = i-L; if (z[k] &lt; R-i+1) z[i] = z[k]; else &#123; L = i; while (R &lt; n &amp;&amp; s[R-L] == s[R]) R++; z[i] = R-L; R--; &#125; &#125;&#125; Z algorithm1 - 日月卦長的模板庫 123456789inline void z_alg1(char *s,int len,int *z)&#123; int l=0,r=0; z[0]=len; for(int i=1;i&lt;len;++i)&#123; z[i]=r&gt;i?min(r-i+1,z[z[l]-(r-i+1)]):0; while(i+z[i]&lt;len&amp;&amp;s[z[i]]==s[i+z[i]])++z[i]; if(i+z[i]-1&gt;r)r=i+z[i]-1,l=i; &#125;&#125; Z algorithm2 - 日月卦長的模板庫 123456789inline void z_alg2(char *s,int len,int *z)&#123; int l=0,r=0; z[0]=len; for(int i=1;i&lt;len;++i)&#123; z[i]=i&gt;r?0:(i-l+z[i-l]&lt;z[l]?z[i-l]:r-i+1); while(i+z[i]&lt;len&amp;&amp;s[i+z[i]]==s[z[i]])++z[i]; if(i+z[i]-1&gt;r)r=i+z[i]-1,l=i; &#125;&#125; 培訓-4 字串- tioj 12345678910void z_build(const char* S,int *z)&#123; z[0]=0; int bst=0; for(int i=1;S[i];i++)&#123; if(z[bst]+bst&lt;i) z[i]=0; else z[i]=std::min(z[bst]+bst−i,z[i−bst]); while(S[z[i]]==S[i+z[i]]) z[i]++; if(z[i]+i&gt;z[bst]+bst) bst=i; &#125;&#125; 例題 TIOJ 1725_Z algorithm_Massacre at Camp Happy 參考 Z algorithm - GeeksforGeeks 建國中學 2012 年資訊能力競賽培訓講義 - 08 培訓-4 字串- tioj 台大資工講義 by nkng Z algorithm - codeforces Gusfield algorithm - momo funny codes Z algorithm - 日月卦長的模板庫 待補充 KMP 字串比對演算法 http://mropengate.blogspot.tw/2016/01/leetcode-kmpimplement-strstr.html]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Substring</tag>
        <tag>Z Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰勒級數]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F16%2F%E6%B3%B0%E5%8B%92%E7%B4%9A%E6%95%B8%2F</url>
    <content type="text"><![CDATA[在數學中，泰勒級數（英語：Taylor series）用無限項連加式——級數來表示一個函數，這些相加的項由函數在某一點的導數求得。泰勒級數是以於1715年發表了泰勒公式的英國數學家布魯克·泰勒（Sir Brook Taylor）來命名的。通過函數在自變量零點的導數求得的泰勒級數又叫做麥克勞林級數，以蘇格蘭數學家科林·麥克勞林的名字命名。 拉格朗日在1797年之前，最先提出帶有餘項的現在形式的泰勒定理。實際應用中，泰勒級數需要截斷，只取有限項，可以用泰勒定理估算這種近似的誤差。一個函數的有限項的泰勒級數叫做泰勒多項式。一個函數的泰勒級數是其泰勒多項式的極限（如果存在極限）。即使泰勒級數在每點都收斂，函數與其泰勒級數也可能不相等。開區間（或複平面開片）上，與自身泰勒級數相等的函數稱為解析函數。 定義 在數學上，一個在實數或複數 \(a\) 在 鄰域上的無窮可微實變函數或複變函數 \(f(x)\) 的泰勒級數是如下的冪級數 (若與原函式相等時為解析函數)： \[ f(x) \simeq \sum_{n=0}^{\infty }{\frac {f^{(n)}(a)}{n!}}(x-a)^{n} \] 而 \(f^{(n)}(a)\)表示函數 \(f\) 在點 $ a$ 處的 $ n$ 階導數。如果 \(a=0\) ，那麼這個級數也可以被稱為麥克勞林級數。 而多項式函數 \(f(x)\) 在 \(x = a\) 時，\(n\) 階的泰勒展開式 \(P_{n}(x)\) 是： \[ P_{n}(x) = \sum_{i = 0}^{n} \frac{ f^{(i)}(a) }{ i! }\cdot \left(x-a \right)^{i} \] 解析函數 Read more-1 (wiki)，Read more-2 (wiki) 如果泰勒級數對於區間 \((a-r,a+r)\)中的所有 \(x\) 都收斂並且級數的和等於 \(f(x)\) ，那麼我們就稱函數 \(f(x)\) 為解析的（analytic）。若且唯若一個函數可以表示成為冪級數的形式時，它才是解析的。為了檢查級數是否收斂於 \(f(x)\)，通常採用泰勒定理估計級數的餘項 (數值方法)。上面給出的冪級數展開式中的係數正好是泰勒級數中的係數。 泰勒級數的重要性體現在以下三個方面： 冪級數的求導和積分可以逐項進行，因此求和函數相對比較容易。 一個解析函數可被延伸為一個定義在複平面上的一個開片上的解析函數，並使得複分析這種手法可行。 泰勒級數可以用來近似計算函數的值。 對定值 x 而言，函數的精準度會隨著多項式的次數 n 的增加而增加。 對一個固定次數的多項式而言， 確度隨著 x 離開 x=0 處而遞減。 泰勒級數列表(常用) 注意：核函數 $ x$ 為 複數 時它們依然成立！ 幾何級數(等比數列) \[ \frac {1}{1-x} = \sum_{n=0}^{\infty }x^{n}\quad \forall x:\left|x\right|&lt;1 \] 二項式定理 \[ (1+x)^{\alpha }=\sum_{n=0}^{\infty }C^\alpha_n \cdot x^{n}\quad \forall x:\left|x\right|&lt;1,\forall \alpha \in \mathbb{C} \] 指數函數 \[ e^{x}=\sum_{n=0}^{\infty }{\frac {x^{n}}{n!}}\quad \forall x \] \(f(x) = e^x\) 在 \(x = 0\) 的泰勒展開式。 當\(n = 1\)時，\(P_{1}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1\) 當\(n = 2\)時，\(P_{2}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2\) 當\(n = 3\)時，\(P_{3}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2 + \frac{\left( e^0\right)^{(3)}}{3!}\cdot\left( x - 0 \right)^3\) \(...\) 自然對數 \[ \ln(1+x)=\sum_{n=1}^{\infty }{\frac {(-1)^{n+1}}{n}}x^{n}\quad \forall x\in (-1,1] \] 牛頓插值公式的淵源 Read more-1(wiki)，Read more-2(wiki) 牛頓插值公式也叫做牛頓級數，由「牛頓 前向 差分方程」的項組成，得名於伊薩克·牛頓爵士。一般稱其為連續「泰勒展開」的離散對應。 差分 差分，又名差分函數或差分運算，是數學中的一個概念。它將原函數 \(f(x)\) 映射到 \(f(x+a)-f(x+b)\) 。差分運算，相應於微分運算，是微積分中重要的一個概念。 定義 前向差分的定義為： \[ \Delta_{h}^{1}[f](x) = f(x + h) - f(x) \] \[ \Delta_{h}^{n}[f](x) = \Delta_{h}^{n-1}[f](x + h) - \Delta_{h}^{n-1}[f](x) \] $, where $ $ h =$ $ “x”$ \(一步的間距，若無下標h，那間距h = 1。\) 前向差分 函數的前向差分通常簡稱為函數的差分。對於函數 \(f(x)\) ，如果在等距節點： \[ x_{k}=x_{0}+kh,(k=0,1,...,n) \] \[ \Delta f(x_{k})=f(x_{k+1})-f(x_{k}) \] 則稱 \(\Delta f(x)\)，函數在每個小區間上的增量 \(y_{k+1}-y_{k}\) 為 \(f(x)\) 一階差分。 後向差分 對於函數 \(f(x_{k})\)，如果： \[ \nabla f(x_{k})=f(x_{k})-f(x_{k-1}) \] 則稱 \(\nabla f(x_{k})\) 為 \(f(x)\) 的一階逆向差分。]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Taylor Series</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指對數]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F15%2F%E6%8C%87%E5%B0%8D%E6%95%B8%2F</url>
    <content type="text"><![CDATA[“\(e^{x}\)” 緣起 首先，要先從複利的公式開始說明： \[ 一年後的本利和 = \left(1+\frac{年利率}{期數} \right)^{期數} \] 其中期數就是看多久複利一次。一個月複利一次的話期數就是12。 依上述所說，設 1 份借貸有 x 年利率，逐月複利話，則每月增加當前值的 \(\frac{x}{12}\) 倍，每月總值都要乘以 \(1 + \frac{x}{12}\)，一年的總值為 \(\left(1 + \frac{x}{12} \right)^{12}\)，逐日複利的話，就是 \(\left (1+ \frac{x}{365} \right)^{365}\)。設年中時段數可為無限，則有如下最初由歐拉提出的指數函數定義： \[ \\lim_{n \to \infty}\left ( 1 + \frac{x}{n} \right )^{n} \] 然後才真正的導出e這個數字，一開始存1元，如果年利率是100%，如果每分每秒都算利息，那麼一年後會得到的利息大約是2.71828，如果把算利息的區間縮到無限小，也就是期數變成無限大的話，就會得到 \[ \lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n} = e \] 由上式我們則可以得到, \[ \lim_{n \to \infty}\left ( 1 + \frac{x}{n} \right )^{n} = \lim_{n \to \infty} \left ( \left ( 1 + \frac{1}{\frac{n}{x}} \right )^{\frac{n}{x}} \right )^{x} \approx e^{x} \] 其中， \[ \lim_{n \to \infty} \left ( 1 + \frac{1}{\frac{n}{x}} \right )^{\frac{n}{x}} \approx e^{1} = e \] 而這是它寫為 \(e^{x}\) 的原因。 wiki-exponential 所以指數函數有基本的恆等式： \[ e^{x+y} = e^{x} \cdot e^{y} \] \[ \parallel \] \[ \exp\left ( x + y \right ) = \exp\left ( x \right ) \cdot \exp\left ( y \right ) \] 性質 所以，正常指數該有的性質 \(e\) 也都有具備，令 \(\forall x, y\in \mathrm{R}\) ，則： \(e^{0}=1\) \(e^{1}=e\) \(e^{x+y}=e^{x}e^{y}\) \(e^{x \cdot y}=\left(e^{x}\right)^{y}\) \(e^{-x}={1 \over e^{x}}\) 微分 微分的時候需要下面這個式子： \[ \lim_{n \to \infty} \left(1 + \frac{1}{n}\right) =\lim_{n \to \infty}\left(\left(1 + \frac{1}{\frac{n}{1}}\right)^{\frac{n}{1}}\right)^{\frac{1}{n}} \approx \lim_{n \to \infty} e^{\frac{1}{n}} \Rightarrow e^{\Delta x} \approx (1 + \Delta x) \] 其中， \(\lim_{n \to \infty} \left ( 1 + \frac{1}{\frac{n}{1}} \right )^{\frac{n}{1}} \approx e^{1} = e\) 當\(n \to \infty\)時 \(\frac{1}{n}\) 可視為一個很小的量 \(\Delta x\) ，也就是： \[ \lim_{m \to 0} (1 + m ) \approx \lim_{m \to 0} e^{m} \] \[ (1 + 很小 ) \approx e^{很小} \] \[ (1 + \Delta x ) \approx e^{\Delta x} \] 微分推導 \[ \Delta y = e^{x+\Delta x} - e^{x} = e^{\Delta x}\cdot e^{x} - 1\cdot e^{x} = (e^{\Delta x} - 1) e^{x} \] 又因： \[ e^{\Delta x} \approx (1 + \Delta x) \] 所以： \[ \Delta y \approx e^{x}\Delta x \rightarrow dy = e^{x}\cdot dx \] 小結： \[ de^{□} = e^{□}d□ \] \(ex.\) \[ de^{-x^2} = e^{-x^2}\cdot d(-x^2) = (-2x)\cdot e^{-x^2}\cdot dx \] 一般化： $y = a^x \(&lt;br&gt;\)y = e^{} = e^{x} $ (對 \(y\) 作微分)\(\Rightarrow dy= e^{x\cdot\ln{a}} \cdot \left ( x\cdot\ln{a} \right )\)\(\Rightarrow dy=a^x\cdot \ln a \cdot dx\) “\(e^{x}\)” 的反函數 對數函數，就是 \(e^{x}\) 的反函數，也就是 \[ y = \log_{e}{x} = \ln{x} \quad x = e^{y} \] img 定義 尤拉定義自然對數為序列的極限： \[ \ln (x) = \lim_{x\rightarrow \infty} n(x^{\frac{1}{n}}- 1) \] 正式的定義為積分\(\ln (a)\)： \[ \ln (a) = \int_1^a \frac{1}{x} dx \] 對 “\(\ln{x}\)” 做微分 簡單地，我們可以推得： $y = x $ $x = e^y $ $dx = e^y dy \(&lt;br&gt;\)dy = dx = dx $ (移&quot; \(e^{y}\) &quot;項) img Proof \(\ln x = \int_1^x \frac{1}{x} dx\) \(\frac{d}{dx}\ln x = \lim_{h \rightarrow 0} (\frac{\ln(x+h) - \ln x}{h})\) \(\Leftrightarrow \lim_{h \rightarrow 0} (\frac{1}{h}\cdot \ln(\frac{x+h}{x}))\) \(\Leftrightarrow \lim_{h \rightarrow 0} (\ln (1+\frac{h}{x})^{\frac{1}{h}})\) ＜Note＞：\(Let \; u = \frac{h}{x} , h = u\cdot x \rightarrow h \; gose \; to \; 0 \; then \; u \; gose \; to \; 0\) \(\Rightarrow \lim_{u \to 0} (\ln (1+u)^{\frac{1}{u\cdot x}} ) \Rightarrow \lim_{u \to 0} (\ln(1+u)^{\frac{1}{u}^\frac{1}{x}})\) \(\Leftrightarrow \lim_{u \to 0} (\frac{1}{x} \cdot ln (1 + u)^{\frac{1}{u}})\) \(\Leftrightarrow \frac{1}{x} \lim_{u \to 0} (\ln(1+u)^{\frac{1}{u}})\) ＜Note＞：$Let ; n = u ; gose ; to ; 0 ; then ; n ; gose ; to ; $ \(\Rightarrow \frac{1}{x} lim_{n \to \infty} (\ln (1 + \frac{1}{n})^n)\) \(\Leftrightarrow \frac{1}{x} \ln( \lim_{n \to \infty} (1 + \frac{1}{n})^n )\) \(\Leftrightarrow \frac{1}{x} \ln e \Leftrightarrow \frac{1}{x}\) $ _1^x dt $（微積分第一基本定理） \[ \frac{d}{dx} \ln x = \frac{d}{dx} \int_1^x \frac{1}{t} dt \Leftrightarrow \ln x = \int_1^x \frac{1}{t} dt \] 一般化： $y=_a x $ \(\Rightarrow y = \frac{\ln{x}}{\ln{a}}\) \(\Rightarrow dy=\frac{1}{x}\cdot \frac{1}{\ln a} \cdot dx\) &quot; \(f \left( x\right) = x^x\) &quot;的微分 兩側取 “\(\ln\)” \[ \ln \left( f \left( x\right) \right) = x \cdot \ln{x} \] 對兩側微分 \[ \frac{f&#39;(x)}{f(x)} = \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right) \] 對兩側乘上 “\(f(x)\)” \[ f&#39;(x) = \left( \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right) \right) \cdot f(x) \] \[ \Rightarrow f&#39;(x) = \left( \ln{x} + 1 \right) \cdot \left( x^x \right) \] 參考 成大微積分指對數函數的微分(第四週共筆) 維基百科 - e (數學常數) 維基百科 - 指數函數 中華科大 - PART 10：指數與對數微分公式彙整]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Exponent</tag>
        <tag>Logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 文法測試]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F06%2FMathJax-test%2F</url>
    <content type="text"><![CDATA[Admin + MathJax + Pandoc 測試 \[ \lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n} \] \[ \left\{\begin{matrix}a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right. \]]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇測試發文]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F06%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B8%AC%E8%A9%A6%E7%99%BC%E6%96%87%2F</url>
    <content type="text"><![CDATA[H1 H2 H3 H4 H5 H6]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Mark Down</tag>
      </tags>
  </entry>
</search>
