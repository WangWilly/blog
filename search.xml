<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Algorithm - String matching]]></title>
    <url>%2Fwillywangkaa%2F2019%2F02%2F07%2FAlgorithm-String-matching%2F</url>
    <content type="text"><![CDATA[Algorithm - String matching 給兩個字串 T 和 P，找出 T 當中是否有一段字串正好是 P，並且找出其位置 字串搜尋當中，通常將兩字串的象徵符號取做 T 和 P T 意指 Text P 意指 Pattern 可以想作是從長篇文字 T 之中搜索小段文字 P 若 P 在平移 s 個單位後（T [s+1 … s+m] = P [1 … m]，0 ≦ s ≦ n-m） 可以在 T 中該片段被找到 稱為「合法平移」（Valid shift） 無法在 T 中該片段被找到 稱為「非法平移」（Invalid shift） 1549517694185 Algorithm Preprocessing time Matching time Native 0 O( (∣T∣-∣P∣+1) ×∣P∣) Rabin-Karp θ(∣P∣) O( (∣T∣-∣P∣+1) ×∣P∣) Morris-Pratt Automaton O(∣P∣×∣Σ∣) θ(∣T∣) Knuth-Morris-Pratt θ(∣P∣) θ(∣T∣) Naive string matching（窮舉法） 最直覺的算法 挪動 P 以對準 T 的各個位置 逐一比對字元、判斷是否相等 Example 1549518031466 1549518053082 1549518063746 1549518076863 Algorithm 12345678void Nativestrinmatcher(string T,string P) &#123; n = T.length(); m = P.length(); for s = 0 to n-m &#123; if(P[1..m] == T[s+1..s+m]) print("Pattern occurs with shift"+ s); &#125;&#125; 時間複雜度 O( (|T|-|P|+1)×|P| ) O( |T||P| ) 空間複雜度 O(1) Rabin-Karp 演算法 由 Michael O. Rabin 及 Richard M. Karp 在 1987 年發展利用雜湊作字串判斷，帶有數學味道的演算法 一個長度為 m 的模板字串 P 視為一個 d 進制（d = ∣Σ∣）的數字 p 令 \(t_s\) 為 T[s+1…s+m] 轉換後的結果 問題轉換成「是否存在一個 k(0 ≤ k ≤ n − m)，使得 \(p = t_k\)」 p = ∣Σ∣(P[m-1]+(∣Σ∣(P[m-2]+… (∣Σ∣(P[2]+∣Σ∣P[1]) …))) + P[m] \(\Rightarrow p = ｜Σ｜^{m-1}P[1]+｜Σ｜^{m-2}P[2]+\ldots+｜Σ｜^{0}P[m]\) \(t_{s+1} = ｜Σ｜(t_s - ｜Σ｜^{m-1}T[s+1])+T[s+m+1]\) Example Σ = ｛0, 1, …, 9｝，d = ∣Σ∣ = 10 Pattern P[1…m] p 為對應的十進位數字 Text T[1…n] \(t_s\) 為長度為 m 子字串（T[s+1…s+m]，s = 0, 1, …, n-m）中對應的十進位數字 字串 ［3 1 4 1 5 2］ 轉換後為 314,152 \(t_{s+1}\) 與 \(t_s\) 的關係 \(t_{s+1} = 10(t_s - 10^{m-1}T[s+1])+T[s+m+1]\) 所以，上述表示為 T = ［3 1 4 1 5 2］、m = 5、d = 10 \(t_s = t_0 = 31,415\) \(\Rightarrow t_{s+1} = t_1 = 10(31,415-10^{5-1}\cdot3)+2 = 14,152\) 因為 p 以及 \(t_k\) 可能非常大 因此比較時間不能視為常數 通常將其 mod 一個大質數 q 因為如此當 \(p = t_k\) 時，不一定匹配成功，須再作進一步驗證 Spurious hit（假性命中） \(p = t_k\) 但 P[1…m] ≠ T[s+1…s+m] Valid hit（完全命中） \(p = t_k\) 與 P[1…m] = T[s+1…s+m] Example P[1…5] = 31,415 p = 31,415 mod 13 = 7 1549521217587 Algorithm 1234567891011121314151617181920212223242526void Rabinkarpmatcher (T,P,d,q) &#123; n = T.length(); m = T.length(); h = pow(d,m-1) % q; t[0] = 0; p = 0; // Preprocessing for i = 1 to m &#123; p = (d*p + P[i]) % q; t[0] = (d*t_0 + T[i]) % q; &#125; // Matching for s = 0 to n-m &#123; if(p == t[s])&#123; if(P[1..m] == T[s+1..s+m])&#123; print("Pattern occurs with shift"+ s); &#125; &#125; // Next substring if(s &lt; n-m)&#123; t[s+1] = (d*(t[s]-T[s+1]*h)+T[s+m+1]) % q; &#125; &#125;&#125; 時間複雜度 預處理 θ (∣P∣) 比對程序 O( (∣T∣-∣P∣+1)×∣P∣ ) 發生在「Worst case」情況 在多數比對次數少、q 大於 m 的情況為線性複雜度 空間複雜度 O(1) Knuth-Morris-Pratt 演算法 由 Donald Knuth、Vaughan Pratt、J. H. Morris 三人於西元 1977 年共同聯合發表，最差情況為 O(n) 的字串匹配演算法 觀察暴力演算法 存在不必要的工作 從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位 往右挪動 P 之前，當下比對成功的字串片段，可以不必花時間在上面 Example T = [aabzabzabcz] P = [abzabc] （從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位） 1549522985570 （在往右挪動 P 之前，當下比對成功的字串片段「abzab」可以加以利用） 1549523718157 （繼續往右挪動 P，挪動一個位置、挪動兩個位置、…） 1549523787809 觀察上述行為 挪動一個位置 比較『abzab 的後四個字元』與『abzab 的前四個字元』 挪動兩個位置 比較『abzab 的後三個字元』與『abzab 的前三個字元』 因此若預先知道『 abzab 之「次長相同前綴後綴」是 ab』 可大幅挪動 P 從「V」處繼續向右一一比對字元 每當比對失敗，就從當前比對成功的字串片段，取其「次長的相同前綴後綴」大幅挪動 P 1549524105095 「相同前綴後綴」（Prefix-suffix） 1549524327132 「次長相同前綴後綴」 一個字串的「最長相同前綴後綴」為原字串 「最短相同前綴後綴」為空字串 「次長相同前綴後綴」就是第二長的「相同前綴後綴」 1549524493648 窮舉法的過程當中，當前比對成功的字串片段是 P 的前綴 因為無法預測是 P 的哪個前綴 所以預先計算 P 每個前綴的「次長的相同前綴後綴」 衍生出了「Failure function」 步驟 預先計算 P 的每種前綴的「次長相同前綴後綴」 意旨算出 P 的「Failure function」 從左往右依序比對字元 比對成功時 繼續比對下個字元 比對失敗時 從比對成功的字串片段取其「次長的相同前綴後綴」以大幅挪動 P 當全部比對成功搜尋到 P 時 取 P「次長的相同前綴後綴」以大幅挪動 P Algorithm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// pattern[0..m]void GetFailureFunction(string pattern)&#123; for k = 1 to pattern.size &#123; i = failure[k-1]; while( pattern[k] != pattern[i+1] // P[k] != P[ F[...F[k-1]]+1 ] &amp;&amp; i&gt;=0 )&#123; // P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』 i = failure[i]; // 以 F[...F[k-1]] 繼續尋找 &#125; if(pattern[k] == pattern[i+1])&#123; // P[k] == P[ F[...F[k-1]]+1 ] failure[k] = i+1; // F[k] = F[...F[k-1]]+1 &#125; &#125;&#125;void Morris_Pratt(string T, string P) &#123; if P.size &gt; T.size return ERROR; GetFailureFunction(P); // 進行字串搜尋，時間複雜度：O(T) for k = 1 to T.size &#123; s = -1; // 目前 P 字元比對已成功的位置 // 比對 P 的下一個尚未比對位置（s+1） // 若 T[k] != P[s+1]，尋找大幅挪動的步伐數 // 在 P 中找出 P[1..s] == T[k-s..k] 以大幅挪動 P while ( P[s+1] != T[k] // T[k] != P[ F[...F[k-1]]+1 ] &amp;&amp; s &gt;= 0 ) &#123; // P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』 s = failure[s]; // 以 F[...F[k-1]] 繼續尋找 &#125; // T[k] 與 P[s+1] 比對成功 if (P[s+1] == T[k]) &#123; s++; // P 字元比對已成功的位置後移一位 &#125; if (s == P.size-1) &#123; // P 字元比對已成功的位置已移完 print( " P出現的位置" + (s-P.size+1) ); s = failure[s]; // 如果字串結尾不是'\0'的時候，就必須挪動 P // 如果字串結尾是'\0'的時候，就能省略這一行 &#125; &#125;&#125; 時間複雜度分析（均攤分析） 以「Multipop stack」概念作均攤分析，以字元兩兩比對總次數作為時間複雜度 （1）進行字串搜尋的過程中 「Stack」S 的元素 當下比對成功的字串片段 S 一開始 S 長度是零 若字元比對成功 S 增加一字元，視為「Push stack」 若字元比對失敗 大幅挪動 P，S 只剩下「次長的相同前綴後綴」，視為「Multipop」 實際上 S 瞬間大幅變短只需要 O(1) ，時間複雜度遠比「Multipop」小 最多有 T 個字元放入 S（S 增加一字元） 最多有 T 個字元彈出 S（大幅挪動 P，S 只剩下「次長的相同前綴後綴」） \(\Rightarrow\)字元兩兩比對的總次數不超過 2T 次 （2）計算 P 的「Failure function」過程中 原理相同，字元兩兩比對的總次數不超過 2P 次 總時間複雜度 O(∣T∣+∣P∣) Failure function 在比對失敗時會使用之 因為函數的定義域是 Prefix，又稱作 Prefix function 因為此函數的值域是 Border，又稱作 Border function 字串函數 輸入字串的其中一個前綴，輸出該前綴的「次長的相同前綴後綴」 1549524903137 1549529928795 計算「Failure function」 Dynamic Programming 分割問題 P[0…i] 除去尾端字元 P[i] 利用已知 P[0…i-1] 的「次長相同前綴後綴」 得到 P[0…i] 的「次長相同前綴後綴」 F[k]：P[0…k] 之「次長的相同前綴後綴」長度 （1）將 F[0] 初始化為 -1 長度為 1 的子字串，不存在「次長相同前綴後綴」 （2）F[k]：探討 P[1…k-1] 與 P[k] 之間的關係 1549530552160 P[ F[k-1]+1 ] == P[k] 意旨「第 k 個字元」與「P[1…k-1] 之『次長的相同前綴後綴』下一個字元」相等 \(\Rightarrow\) F[k] = F[k-1]+1 1549530722575 對「P[1…k-1] 之『次長的相同前綴後綴』」作探討 1549534207507 P[ F[k-1]+1 ] ≠ P[k] 「第 k 個字元」與「P[1…k-1] 之『次長的相同前綴後綴』下一個字元」相異 若存在 P[ F…[F[k-1]]+1 ] == P[k]，則 F[k] = F…[F[k-1]]+1 1549535284950 若不存在 P[ F…[F[k-1]]+1 ] == P[k]，則 F[k] = -1 1549535607960 上述可以表達為： \(f[k]\left\{\begin{matrix} -1 &amp; if \;k = 0\\ f^m[k-1] +1 &amp; 最小的整數\; m\;使得\; P[f^m[k-1]+1] == P[k] \\ -1 &amp; 不存在整數\; m \;可以使得 P[f^m[k-1]+1] == P[k]\end{matrix}\right.\) Algorithm 1234567891011121314// pattern[0..m]void GetFailureFunction(string pattern)&#123; for k = 1 to pattern.size &#123; i = failure[k-1]; while((pattern[k]!=pattern[i+1]) &amp;&amp; // P[k] != P[ F[...F[k-1]]+1 ] i&gt;=0)&#123; // P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』 i = failure[i]; // 以 F[...F[k-1]] 繼續尋找 &#125; if(pattern[k] == pattern[i+1])&#123; // P[k] == P[ F[...F[k-1]]+1 ] failure[k] = i+1; // F[k] = F[...F[k-1]]+1 &#125; &#125;&#125; Morris-Pratt Automaton 此演算法可以化作自動機，轉化的時間複雜度為 O( ∣P∣×∣Σ∣ ) Σ 為字元集合 化作自動機之後，字串搜尋的過程就變得更簡單了，甚至可以設計成電子迴路 轉化的原理，是針對每個狀態，都找出經由「Failure function」能到達的狀態們，然後建立轉移邊，連到那些狀態們的下一個狀態 1549541112414]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String matching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Theoretical evaluation of overflow techniques]]></title>
    <url>%2Fwillywangkaa%2F2019%2F02%2F02%2FData-structure-Theoretical-evaluation-of-overflow-techniques%2F</url>
    <content type="text"><![CDATA[Data structure - Theoretical evaluation of overflow techniques（未完成） The basic of hashing 資料儲存機制，當資料 x 要在此結構存取時，需經過「Hashing function」求出「Hashing address」（H(x)），再以「Hashing address」視為此資料在此結構的定位點 「Hash table」 「Bucket」 定位點 「Slot」 每個定位點中有多少存儲空間 「Hash table size」 「Bucket」×「Slot」 「Identifier」：識別字；資料區分的編碼 「Identifier density」 T：「Identifier」總數 n：「Identifier」目前正在使用中（目前在「Hash table」中被保存）的數量 B×S：「Hash table」大小 「Identifier density」 = \(\frac{n}{T}\) 「Loading density」 T：「Identifier」總數 n：「Identifier」目前正在使用中（目前在「Hash table」中被保存）的數量 B×S：「Hash table」大小 「Loading density」 = \(\frac{n}{b\times s}\) （通常以 \(\alpha\) 表示） 「Collision」 出現兩個不同的資料 X、Y，經過「Hashing function」計算後，得到相同的「Hashing address」 「Overflow」 當「Collision」發生並且該「Bucket」無「Slot」可儲存 發生「Collision」不一定會造成「Overflow」，但是當每個「Bucket」由一個「Slot」所組成，則發生「Collision」等價於「Overflow」 Analysis of linear probing 又稱為「Open addressing mode」，當 H(x) 發生「Overflow」，則探測 H(x)+1、H(x)+2 …H(x)-1，直到找到尚有空間之「Bucket」或是「Hash table」額滿為止 缺點 容易形成群聚（Clustering）現象，這將會增加未來搜尋資料的探測次數 插入與尋找的探測成本取決於「群聚鍊大小」 平均的「群聚鍊大小」為 \(\frac{n}{m}\) 識別字容易雜湊到群長聚鍊較長的位置 最差的狀態就是所有識別字都雜湊到同一個群聚鍊 每次探測 遇到碰撞的機率：\(\alpha\) （Loading factor） 遇到可用空間的機率：\(1-\alpha\) 探測過程中 恰兩次探測找到可用空間的機率 \(\alpha \times(1-\alpha)\) 恰 K 次探測找到可用空間的機率 \(\alpha^{k-1}(1-\alpha)\) n：「Identifier」目前正在使用中（目前在「Hash table」中被保存）的數量 m：可使用空間量 假設一個「Hash table」T，則 T[0]（Bucket）為空的機率 減去「被占用的機率」 \(1 - \frac nm\) 此機率亦為任何一個「Bucket」為空的機率 假設 T[0]、T[k+1] 皆為空，且 T[1]…T[k] 皆被占用，則機率 恰 k 個識別字被雜湊到 T[0]…T[k] T[0] 在假設中仍為空 機率 $ = (被占用的機率)^k(未使用的機率) \ = (m)^k(1-k{k+1})$ 恰 n-k 個識別字會被雜湊到 T[k+1]…T[m-1] T[k+1] 在假設中仍為空 機率 $ = (被占用的機率)^{n-k}(未使用的機率)$ 探測失敗 \(\frac 12 (1+\frac 1{(1-\alpha)^2}) = \frac 12(1+2\alpha+3\alpha^2+ 4\alpha^3+\ldots)\) 搜尋成功 \(\frac 12(1+\frac 1{1-\alpha}) = 1+\frac 12(\alpha+\alpha^2+\alpha^3+\alpha^4+\ldots)\) Analysis of quadratic probing 「Uniform probing」模型 由 W.W.Peterson 於1957年提出 假設所有的「Identifier」（Key）以非常平均的方式分布於「Hashing table」 假設「Hashing table」的大小為 m 「Identifier」占用的大小為 n 所以有 \(\binom{m}{n}\) 種可能的佔用方式 忽略「Primary clustering」與「Secondary clustering」的影響 初次探測（First prob）與碰撞（Collision）之後的探測皆假設為「隨機探測」 每次的探測各自為獨立事件（Independent event） 每次探測 遇到碰撞的機率：\(\alpha\) （Loading factor） 遇到可用空間的機率：\(1-\alpha\) 探測過程中 恰兩次探測找到可用空間的機率 \(\alpha \times(1-\alpha)\) 恰 K 次探測找到可用空間的機率 \(\alpha^{k-1}(1-\alpha)\) 探測失敗（\(U(\alpha)\)） 觀點一 探測失敗的機率等價於自「恰 1 次探測失敗的機率」累加至「恰無限次探測失敗的機率」 \(U(\alpha) = \sum_{K = 1}^\infty \binom K1\alpha^{K-1}(1-\alpha) = \sum_{K = 1}^\infty K\cdot\alpha^{K-1}(1-\alpha)\) 利用生成函數 \(\Rightarrow (1-\alpha)(\sum_{K = 1}^\infty K\cdot \alpha^{K-1}) = (1-\alpha)\frac{1}{(1-\alpha)^2} = \frac{1}{1-\alpha}\) 觀點二 累加所有「探測失敗的機率」 \(U(\alpha) = 1 + \alpha + \alpha^2 + \alpha^3 + \ldots = \frac{1}{1-\alpha}\) 探測成功（\(S(\alpha)\)） 插入第 k+1 個資料最多需要探測 \(\frac{1}{1-\frac{j}{m}}\) 插入 n 筆資料探測成功的平均次數為 \(S(\alpha) = \frac{1}{n}\sum_{k = 0}^{n-1}\frac{1}{1-\frac km} = \frac{m}{n}\sum_{k = 0}^{n-1}\frac{1}{m-k}\\ \Rightarrow \frac{1}{\alpha}(\sum_{k = 1}^m\frac 1k - \sum_{k = 1}^{m-n}\frac 1k)\\ \Rightarrow \frac 1\alpha (H_m - H_{m-n}) \\ \leq \frac{1}{\alpha}(\ln m - \ln(m-n)) \\ = \frac1\alpha (\ln\frac{m}{m-n}) = \frac 1\alpha(\ln\frac1{1-\alpha})\) Analysis of chaining 每個串列 預期大小：\(\alpha\) （Loading factor） 探測失敗（\(U(\alpha)\)） 等價於預期串列大小 \(U(\alpha) = \alpha\) 探測成功 當第 n 個識別字要插入到「Hash table」時 每個串列的預期大小為 \(\frac{n-1}{m}\)]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - System security]]></title>
    <url>%2Fwillywangkaa%2F2019%2F02%2F02%2FOperating-System-System-security%2F</url>
    <content type="text"><![CDATA[System security 提供「安全功能」與「安全服務」 針對各種常用作業系統，進行相關配置，以正確對付、防禦各種入侵 保證網路作業系統提供的網路服務得到安全配置 病毒（Virus） 藉由用存取控制（Access control）的機制來保護資訊的安全，防止非法使用者的入侵與蓄意破壞 特徵 A fragment of code embedded in a legitimate program 依附在別的程式上 會自行複製、感染、傳播、發作 「UNIX」與「Multiuser」作業系統不易受到病毒影響，因為「可執行檔」的寫入被系統保護 啟動磁區病毒 早期的病毒類型，感染開機磁片中「Boot」程式或硬碟分割表以取得控制權限 檔案型病毒 寄生於執行檔後，會再自主感染其他執行檔 「常駐型」：會常駐在記憶體中，當其他程式執行時會進一步執行感染動作 「非常駐型」：感染磁碟機中找出尚未被感染的程式加以感染 巨集病毒 裡用軟體本身提供的巨集功能設計出的病毒 Microsoft word 的 VBA 巨集 電腦蠕蟲 A process that use spawn mechanism（孕育機制） to duplicate itself 不須依附在別的程式內 可能不用使用者操作也會自我複製執行 未必破壞被感染的系統 執行垃圾程式碼以發動「分散式阻斷服務攻擊」（DDos） 採用垃圾郵件、漏洞傳播，如：莫里斯蠕蟲 特洛伊木馬 A code segment that misuses its environment 病毒依附在一般程式碼 滿足特定條件後便將使用者資料傳出，未達條件不進行任何動作 「Spyware」：常伴隨著商業軟體，施行網頁綁架與廣告騷擾 Autorun病毒 利用 USB 當作媒介，會自動執行程式侵入電腦 千面人病毒 每繁殖一次會以不同病毒碼傳染到別處，每一個中毒的檔案所含的病毒程式碼皆不同 攻擊手段 Dumpster diving 攻擊者翻找目標系統文件、檔案、垃圾資料與殘存資訊，試圖找到密碼與其他有用的資訊 Trap door The designer of a program or system might leave a hole in the software that only is capable of use 隱藏在程式中的秘密功能 Logic bomb A program that initiates a security incident only under certain circumstances 難以查出問題所在 正常情況不發生，當發生特定條件時會發生錯誤 Stack overflow / Buffer overflow Attacker sends more data than the program expected 溢位（Overflow）後將原本「Stack」中的「Return address」改成惡意程式的位置 避免方法 Use static code analysis to look for memory writes that go beyond array boundaries Randomize the base address of program libraries/stack in the memory 使用安全的函數（strcpy()→strncpy()） 使用高階程式語言 Java、Python Port scanning Is not a attacker but rather a means for a cracker to detect a system’s vulnerabilities to attacker 首先搜尋目標網路上所有可以接觸到的主機，然後查出主機上開啟了哪些通訊埠，並且進一步偵測出目標主機上所執行的作業系統類型及版本（OS fingerprinting），最後刺探出目標主機上正在執行或待命的網路服務與目標主機的 IP 位址之間的關係 Port scanning （通訊埠端口掃描） 駭客會傳送一連串的特殊訊息去測試此主機上有執行哪些網路服務，如 HTTP 使用 Port 80，透過「Port Scanning」得知哪些通訊埠是開啟的，讓駭客知道主機上目前所執行的網路服務類型 Network Scanning（網路架構掃描） 若能得知目標網路內有哪些主機是可以接觸到、啟動（active）的，能夠縮小攻擊範圍並知道哪些主機可以成為被攻擊目標 Vulnerability Scanning（弱點掃描） 偵測及發現目標網路內被掃描的主機上所存在的弱點與漏洞，以便未來進行入侵攻擊 Denial of service（Dos） Dos attacks are aimed not at gaining information or stealing resources but rather at disrupting legitimate use of a system or facility DDos 利用多台殭屍系統（Zombies）同時對目標伺服器發出大量請求以癱瘓服務 Symmetric encryption and asymmetric encryption Symmetric encryption Same key is used to encrypt and to decrypt Data encrypt standard（DES） 64 bit block cypher 每次加密操作只處理 64-bit 資料，稱為「Block」 56 bit key length Triple DES C：Cypher；密文 M：Plaintext；明文 使用「金鑰包」包含三個 DES 金鑰 \(K_1、K_2、K_3\) 均為 56-bits 加密：使用 \(K_1\) 的金鑰進行 DES 加密，在用 \(K_2\) 的金鑰進行 DES「解密」，最後使用 \(K_3\) 進行 DES 加密，『\(C = E_{K_3}(D_{K_2}(E_{K_1}(M)))\)』 解密：使用 \(K_3\) 的金鑰進行 DES 解密，在用 \(K_2\) 的金鑰進行 DES「加密」，最後使用 \(K_1\) 進行 DES 解密，『\(M = D_{K_1}(E_{K_2}(D_{K_1}(C)))\)』 金鑰選項（\(K_1、K_2、K_3\)） 金鑰選項1：三個金鑰獨立 強度最高，擁有 3×56 = 168 個獨立金鑰位元（Bit） 金鑰選項2：\(K_1、K_2\) 獨立、\(K_3 = K_1\) 安全性稍低，擁有 2×56 = 112 個獨立金鑰位元（Bit），但可以防禦「中途相遇攻擊」 金鑰選項3：\(K_1 = K_2 = K_3\) 等同於普通 DES（因為會互相抵銷），擁有 56 個獨立金鑰位元（Bit） Advanced encryption standard（AES） 在密碼學中又稱「Rijndael加密法」，是美國聯邦政府採用的一種區段加密標準，用來替代原先的DES 嚴格地說，AES 和 Rijndael 加密法並不完全一樣（雖然在實際應用中兩者可以互換），因為Rijndael加密法可以支援更大範圍的區段和金鑰長度 AES 的區段（Block cypher）長度固定為128-bit 金鑰長度（Key length）則可以是 128、192、256-bit 而Rijndael使用的金鑰和區段長度均可以是128、192、256-bit 加密過程中使用的金鑰是由「Rijndael金鑰生成法」產生 RSA 比 DES 和其它對稱演算法要慢得多；實際上「傳送方」會使用一種對稱演算法來加密他的資訊，然後用 RSA 來加密他的比較短的對稱密碼，然後將用 RSA 加密的對稱密碼和用對稱演算法加密的訊息送給「接收方」 C：Cypher；密文 M：Plaintext；明文 \(K_{as}\)：AES 金鑰 \(K_{bs}、K_{bp}\)：RSA 私鑰與公鑰（接收方） 加密 利用「AES 金鑰」對明文（M）加密 再使用「RSA 公鑰」對「AES 金鑰」加密 將上述兩者一併傳給接收方 \(\Rightarrow E_{K_{as}}(M)｜E_{K_{bp}}(K_{as})\) 解密 用「RSA 私鑰」解密出「AES 金鑰」 再使用「AES 金鑰」解密出明文 爾後雙方傳遞資料只需使用「AES 金鑰」加密明文即可 \(\Rightarrow D_{K_{bs}}(E_{K_{bp}}(K_{as})) = K_{as} \\ D_{K_{as}}(E_{K_{as}}(M)) = M\) Rivest cypher 4（RC4） 是密鑰長度可變的一種「串流流加密算法」，也屬於對稱加密算法，RC4 是有線等效加密（WEP）中採用的加密算法，也曾經是「Transport layer security（TLS）」可採用的算法之一 RC4 由偽隨機數生成器（Pseudo-random bit generator）和異或運算（XOR）組成 RC4的密鑰長度可變 40 ~ 2048 bit RC4一個字節一個字節（Byte）地加解密 給定一個密鑰，偽隨機數生成器接受密鑰並產生一個「S盒」 S盒用來加密數據，而且在加密過程中S盒會變化 快速但是安全性低 Asymmetric encryption Rivest–Shamir–Adleman（RSA） 「接收方」生成一對公鑰、私鑰 找出兩個極大質數 p、q 計算 N = p×q 同時算得 \(r = \phi (N) = (p-1)\times(q-1)\) 求出整數 e其滿足 gcd(e,r) = 1 且 e &lt; r 求出整數 d其滿足 e﹡d ≡ 1 (mod r) \(e\cdot d-1 = k\cdot r, k \in Z\) 最後得到公鑰：(N, e)、私鑰：(N, d) 「接收方」公開其公鑰給欲傳遞訊息的「傳遞方」 「傳遞方」使用公鑰將明文加密 將明文（M）轉換成一整數（m） f：M→m \(C \equiv m^e (\mod N)\)，C 為密文 「傳遞方」將密文傳送給「接收方」使用私鑰將其密文解密 \(m \equiv C^d (\mod N)\) 將整數（m）轉換明文（M） f’：m→M 由尤拉公式可以得知 模反元素必存在 \(a\times?\equiv1(\mod n)\\ \Rightarrow a\times a^{\phi(n)-1} = a^{\phi(n)} \equiv 1(\mod n)\) 私鑰解密證明（\(C^d \equiv M(\mod n)\)） 根據加密原則 \(M^e \equiv C (\mod n)\) 則 $C = M^e - kn, k Z $ 將 C 帶入解密規則 \((M^e - kn)^d \equiv M(\mod n), k \in Z \\ \Rightarrow (M^e)^d \equiv M(\mod n)\) 因為 \(e \cdot d \equiv 1(\mod \phi(n))\) ，則 \(e\cdot d = h\phi(n)+1, h\in Z\) 則 \(M^{h\phi(n)+1} \equiv M (\mod n)\) Authentication Constraining the set of potential sender of a message and is also useful for proving that a message has not been modified Message authentication code（MAC） 特定演算法後產生的一小段資訊附加在原始訊息後傳送，以確認「某段訊息的完整性」與「傳送者的身分驗證」 MAC 資訊鑑別碼（MAC）不能提供對資訊的保密，若要同時實現保密認證，同時需要對資訊進行加密 以 RSA 為一個訊息署名 「傳送者」為原始訊息計算一個雜湊值（Message digest） 用「傳送者」的私鑰「加密」這個雜湊值即為一個「署名文」 將原始訊息與「署名文」一併傳給「接收方」 這個訊息只有用「傳送者」的公鑰才能解密 「接收者」獲得「署名文」後使用「傳送者」的公鑰「解密」得到雜湊值 將雜湊值與「接受者」自己為這個訊息計算的雜湊值比較 假如兩者相符，則此訊息在傳播路徑上沒有被篡改過 第三方攻擊 和其它加密過程一樣，對RSA來說分配公鑰的過程是非常重要的，分配公鑰的過程必須能夠抵擋中間人攻擊 「竊聽者」交給 A 一個公鑰使 A 相信這是 B 的公鑰，則「竊聽者」可以截下 A 傳遞給 B 的資訊 「竊聽者」亦將自己的公鑰傳給 B 使 B 以為這是 A 的公鑰，則「竊聽者」可以將所有 B 遞移給 A 的訊息截下來，將這個訊息用自己的私鑰解密，然後將這個訊息再用 A 的公鑰加密後傳給 A 理論上 A 和 B 都不會發現訊息被竊聽，所以今天一般用可靠的第三方機構簽發憑證來防止這樣的攻擊]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Pseudo polynomial time complexity]]></title>
    <url>%2Fwillywangkaa%2F2019%2F01%2F26%2FAlgorithm-Pseudo-polynomial-time-complexity%2F</url>
    <content type="text"><![CDATA[Pseudo polynomial time complexity 如果一個演算法的傳統時間複雜度位於多項式時間，而標準時間複雜度不在多項式時間 則我們稱這個演算法位於偽多項式時間，以下探討 多項式時間複雜度是甚麼？ \(O(n^k), k \;is\; constant\) Selection sort \(O(n^2)\)，為「Polynomial time」 Travel salesman problem Brutal force：\(O(n\cdot n!)\)，為「Non polynomial time」 通常認為輸入變數 n 代表數據規模 Selection sort n 代表欲排序的數據組元素個數 Travel salesman problem n 表示圖中節點的數量 但是上述的數據規模，為直觀的定義並不夠嚴謹，所以需要標準化輸入的數據規模 輸入的數據規模 保存輸入數據所需的 Bit 位數 針對排序的輸入 n 個「32-bit 整數」數組 其數據規模為 32×n，n 為數組中的元素個數 針對圖論的輸入 n 個點、m 個邊 其數據規模為 \(\Omega(n+m)\) 「Polynomial time complexity」的標準定義： 在輸入數據規模為 x 的清況下，存在一個演算法能在 \(O(x^k)\) （k 為一常數）的時間複雜度能解決問題 所以，再來討論剛才的時間複雜度 Selection sort 輸入 n 個「32-bit 整數」數組 其數據規模為 32×n，n 為數組中的元素個數 時間複雜度 \(x = 32n\) 傳統的時間複雜度為 \(O(n^2)\) 則 \(n = \frac{1}{32}x \Rightarrow O(\frac{1}{1024}x^2) = O(x^2)\)，為「Polynomial time complexity」 Depth first search 輸入 n 個點、m 個邊 其數據規模為 \(\Omega(n+m)\) 時間複雜度 $x = (n+m) $ 傳統的時間複雜度為 \(O(n+m)\) 則 \(O(x)\)，為「Polynomial time complexity」 接著，對「質數演算法」進行討論： 1234567bool isPrime(n) &#123; for(int i = 2; i &lt; n-1; i++) &#123; if(n%i = 0) return false; &#125; return true;&#125; 質數演算法 輸入 這種輸入規模會隨著 n 的大小而改變 \(x = \lg n\) 與排序的規模相比排序的 n 為元素多寡，但是每個元素皆為 32-bit 或是其他固定大小的整數範圍 （排序的輸入規模）\(x = c \cdot n\)，c 必為一常數 時間複雜度 \(x = \lg n\) 傳統的時間複雜度為 \(O(n)\) 則 \(n = 2^x \Rightarrow O(2^x)\) ，為「Non-polynomial time complexity」 進一步體會 一個二進位數（1010 1011） 其「質數演算法」的真實複雜度為 \(2^8\) 另一個二進位數（1 1010 1011） 其「質數演算法」的真實複雜度為 \(2^9\) 可以發現僅增加一個 bit 就會使的演算法的運行時間倍增]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discrete mathematics - Catalan number]]></title>
    <url>%2Fwillywangkaa%2F2019%2F01%2F24%2FDiscrete-mathematics-Catalan-number%2F</url>
    <content type="text"><![CDATA[Discrete mathematics - Catalan number 給定兩個生成函數： \(A(x) = \sum_{n = 0}^\infty a_nx^n\) \(B(x) = \sum_{n = 0}^\infty b_nx^n\) 則： \(A(x)\pm B(x) = \sum_{n = 0}^\infty(a_n+b_n)x^n\) \(\begin{aligned} A(x) \times B(x) = (a_0+a_1x+a_2x^2+\ldots)\times(b_0+b_1x+b_2x^2+\ldots) \\ \Rightarrow (a_0b_0) + (a_0b_1+a_1b_0)x + (a_2b_0+a_1b_1+a_0b_2)x^2+\ldots \end{aligned}\) 定義 \(c_n = a_n \otimes b_n = a_0b_n+a_1b_{n-1}+\ldots+a_nb_0\) \(a_n、b_n\) 為兩個遞迴函數 稱 \(c_n\) 為 \(a_n、b_n\) 的「Convalution」 \(c_n = a_n \otimes b_n \Rightarrow C(x) = A(x)\times B(x)\) \(c_n = a_n \otimes a_n \Rightarrow C(x) = A(x)\times A(x) = A(x)^2\) 「生成函數」推導 令 Catalan number 等於 \[ \left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1, a_1 = a_0a_0 = 1 \end{matrix}\right. \] 以「生成函數」求此遞迴函數的顯式 令 \(A(x) = \sum_{n = 0}^\infty a_n x^n\) 因為由上式可以知道此遞迴從 n ≧ 1開始有意義 \(\sum_{n = 0}^\infty a_n x^n - a_0 = \sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^n\) \(\sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^n \\ \Rightarrow x\cdot \sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^{n-1} = x\cdot A(x)^2\) \(A(x) - a_0 = x\cdot A(x)^2 \\ \Rightarrow xA(x)^2- A(x) +1 = 0\) \(A(x) = \frac{1\pm \sqrt{1-4x}}{2x}\) \((1-4x)^\frac12 = \sum_{r = 0}^\infty \binom{\frac12}{r}(-4x)^r\) \(\sum_{r = 0}^\infty \binom{\frac12}{r}(-4x)^r = \sum_{n = 0}^\infty \frac{\frac12(\frac12 -1)\ldots (\frac12-r+1)}{r!}(-1)^r4^rx^r\) \(\Rightarrow \sum_{r = 0}^\infty \frac{\frac12(-\frac12)(-\frac32)\ldots (-\frac{2r-3}{2})}{r!}(-1)^r4^rx^r\) \(\Rightarrow \sum_{r = 0}^\infty (-1)^{r-1}(\frac12)^r\frac{1(1)(3)\ldots (2r-3)}{r!}(-1)^r4^rx^r\) \(\Rightarrow -\sum_{r = 0}^\infty \frac{(1)(3)\ldots (2r-3)}{r!}2^rx^r\) \(\Rightarrow \sum_{r = 0}^\infty \frac{(1)(2)(3)\ldots (2r-3)(2r-2)(2r-1)(2r)}{r!\cdot2^r\cdot r!\cdot(2r-1)}2^rx^r\) \(\Rightarrow -\sum_{r = 0}^\infty \frac{(2r)!}{r!\cdot r! (2r-1)}x^r\) \(\Rightarrow -\sum_{r = 0}^\infty \frac{1}{2r-1}\binom{2r}{r} x^r\) 因為 A(x) 會有兩個解，但是因為欲求之解不可能有負數情形，所以取其正解 \(A(x) = \frac{1-\sqrt{1-4x}}{2x} = \frac{1+\sum_{r = 0}^\infty \frac{1}{2r-1}\binom{2r}{r} x^r }{2x}\) \(\Rightarrow \frac12 \sum_{r = 1}^\infty \frac1{2r-1}\binom{2r}{r}x^{r-1}\)，取 \(x^n\) 的係數 則 r = n+1，\(\Rightarrow \frac12 \cdot \frac1{2(n+1)-1} \binom{2(n+1)}{(n+1)}x^n\) \(\Rightarrow a_n = \frac{1}{2(2n+1)}\cdot\frac{(2n+2)\times(2n+1)}{(n+1)\times(n+1)}\cdot\binom{2n}{n} = \frac1{n+1}\binom{2n}{n}\) Catalan number 為 \(\frac1{n+1}\binom{2n}{n}\) Example 求取 n 個節點的「Binary ordered tree」個數？ 1548332494667 ，k ≧ 0 \(\Rightarrow\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1 \end{matrix}\right. \\ \Rightarrow a_n = c_n = \frac{1}{n+1}\binom{2n}{n}\) 變形 \(\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1 \end{matrix}\right.​\) \(a_n = c_n = \frac{1}{n+1}\binom{2n}{n}\) \(\left\{\begin{matrix} a_n = a_1a_{n-1} + a_2a_{n-2} + \ldots + a_{n-1}a_1 , n\geq 1 \\ a_1 = 1 \end{matrix}\right.\) \(a_n = c_{n-1} = \frac{1}{n}\binom{2(n-1)}{n-1}\) \(\left\{\begin{matrix} a_n = a_2a_{n-1} + a_3a_{n-2} + \ldots + a_{n-1}a_2 , n\geq 1 \\ a_2 = 1 \end{matrix}\right.\) \(a_n = c_{n-2} = \frac{1}{n+1}\binom{2(n-2)}{n-2}\) Example n 個變數 \(x_1, x_2, \ldots, x_n\) 之合法的括號數有幾個？ 1548332797656 ，k ≧ 1 \(\left\{\begin{matrix} a_n = a_1a_{n-1} + a_2a_{n-2} + \ldots + a_{n-1}a_1 , n\geq 1 \\ a_1 = 1 \end{matrix}\right. \Rightarrow c_{n-1} = \frac{1}{n}\binom{2(n-1)}{n-1}\) 「組合證明」推導 前導 令 Catalan number 等於 \[ \left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1, a_1 = a_0a_0 = 1 \end{matrix}\right. \] 則我們可以將此遞迴視為一個「合法路徑問題」 在一個二維空間下，從原點 (0, 0) 只能走下面兩種步伐至 (m, n) 步伐 R：(x, y) → (x+1, y) 步伐 U：(x, y) → (x, y+1) 並且在路徑中，不能發生 U 大於 R 的情形 違法：(0,0)→R→R→U→U→U→R→…→(m,n) 首先我們先將問題簡化成「Catalan number」可以解釋的問題，再來推廣 在一個二維空間下，從原點 (0, 0) 只能走下面兩種步伐至 (n, n) 步伐 R：(x, y) → (x+1, y) 步伐 U：(x, y) → (x, y+1) 並且在路徑中，不能發生 U 大於 R 的情形 討論 若問題再進一步簡化成「自點(0, 0) 只能以規定的兩種步伐至 (0, 0)」 令該方法數為 \(a_0\)，並且其方法數視為 1 而當問題為「自點(0, 0) 只能以規定的兩種步伐至 (1, 1)」時 只有唯一種方法，就是 (0,0)→R→U→(1,1) 而我們更可以進一步將此看成 \(a_1\) = 「自(0,0)至(0,0)的方法數」×（唯一的走法：…→R→U→…）×「自(1,1)至(1,1)的方法數」 \(a_1 = a_0\times1\times a_0 = a_0a_0\) 所以，在一個二維空間下，從原點 (0, 0) 只能以規定兩種步伐至 (n, n)的方法數為 \(a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0\)，為以下方法數組成 (「自(0,0)至(0,0)的方法數」×（唯一的走法：…→R→U→…）×「自(1,1)至(n,n)的方法數」) + (「自(0,0)至(1,1)的方法數」×（唯一的走法：…→R→U→…）×「自(2,2)至(n,n)的方法數」) + …. (「自(0,0)至(n-1,n-1)的方法數」×（唯一的走法：…→R→U→…）×「自(n,n)至(n,n)的方法數」) 由上方討論可以得知簡化的「合法路徑問題」與 n 個節點的「Binary ordered tree」個數問題等價 組合證明 一樣是上述的簡化的「合法路徑問題」，由下圖來討論 1548319123283 自 (0, 0) 至 (16, 16) 且不得超過中間雙線的部分（可觸及） 合法示意圖： 1548319440435 非法示意圖： 1548319549796 每個違法的路徑，必定會和下方紅色雙斜線接觸 1548320935256 將「開始違法的座標」之後的路徑對紅色雙斜線做對稱化，則最後到達的座標必定在 (15,17)，而這種轉換有幾個特性： 1-1 對應 可逆 若再一次對稱回來，必定會對應到一個違法的路徑自(0,0)至(16,16) 所以自(0,0)至(15,17)的每種路徑，皆會對應到一個違法路徑 合法路徑方法數 \(\binom{32}{16} - \binom{32}{15} = \frac{1}{16+1}\binom{2\cdot16}{16}\) 為「Catalan number」 所以從(0, 0)至(n, n)的「合法路徑為」 \(\binom{2n}{n}-\binom{2n}{n-1}\) Example 有一場選舉，兩個候選人 A、B，假設知道 A 的票數一定比 B 多，假設 A 的總得票數為 p ，B 的總得票數為 q，請問有幾種開票的方法可保證每個當下 A 的得票數會大於 B 當下的得票數？ 分析 有別於上面的題目，此處 A 每個當下的得票數絕對會比 B 每個當下的得票數還多 不合法的開票方法：A→A→B→B→… 1548330759722 假設 A 得到 15 票，B 得到 11 票，則上圖中綠色為合法的開票方法，紅色虛線為不合法的開票方法，但是這樣討論之下，綠色的開票方法在尚未開票時其實也觸碰了紅色雙斜線，然而為何還是正確的開票方法，因為我們在尚未開票時不討論誰贏的比較多，所以我們可以將起點平移到 (1, 0) 處，代表第一章開出來的票一定是 A 得到，且亦不牴觸我們方才的假設 1548331206829 則每個非法路徑會唯一對應到「自 (1,0) 至 (11,15) 的開票方法」 1548332141506 合法的開票方法為 \(\binom{(15-1)+11}{15-1} - \binom{(11-1)+15}{11-1} = \binom{25}{14}-\binom{25}{10} = 1188640\) 原本的問題之合法開票數為 \(\binom{(p-1)+q}{p-1} - \binom{(q-1)+p}{q-1}\)]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Catalan Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear algebra - Vandermonde matrix]]></title>
    <url>%2Fwillywangkaa%2F2019%2F01%2F22%2FLinear-algebra-Vandermonde-matrix%2F</url>
    <content type="text"><![CDATA[Linear algebra - Vandermonde matrix 法國數學家范德蒙 (Alexandre-Théophile Vandermonde) 是行列式的奠基者之一，他在十八世紀提出行列式專有符號，將行列式應用於解線性方程組，並且對行列式理論進行了開創性的研究 兩百多年後，他的名字因為「Vandermonde 矩陣」而經常被提及，具有以下形式： \(A_n=\begin{bmatrix} 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\ 1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;x_n&amp;x_n^2&amp;\cdots&amp;x_n^{n-1} \end{bmatrix}，其中\; x_1, x_2, x_3, \ldots, x_n\;全相異\) \((A_n)^T\) 也稱為 Vandermonde 矩陣 推導 令 \(f(t) = V(x_1, x_2, \ldots, x_{n-1}, t) = A_n=\begin{bmatrix}1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;t&amp;t^2&amp;\cdots&amp;t^{n-1} \end{bmatrix}​\) 上面方程式可以視為一個 t 的函數 對第 n 列作降階求行列式得到 \(c_0 + c_1t + \ldots + c_{n-1} t^{n-1}\)，為一個「t 的 n-1 次多項式」 其中 \(c_0, c_1, \ldots, c_{n-1}\) 為不含 t 的常數 \(c_{n-1}\) 為去除第 n 行與第 n 列後的行列式： $c_{n-1} = V(x_1, x_2, , x_{n-1}) $ 用 \(x_1,\ldots , x_{n-1}\) 代入 f \(f(x_1) = \det\begin{bmatrix} 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\ 1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \end{bmatrix} = 0 = f(x_2) = \ldots = f(x_{n-1})\) 可以知道 f(t) 有 n-1 個相異根 \(x_1, x_2, \ldots, x_{n-1}\) \(\Rightarrow f(t) = c_{n-1}(t-x_1)(t-x_2)\ldots(t-x_{n-1})\) 將 \(x_n\) 代入： \(f(x_n) = V(x_1, x_2, \ldots, x_n) = V(x_1, x_2, \ldots, x_{n-1})(x_n-x_1)\ldots(x_n-x_{n-1})\) \(V(x_1, x_2, \ldots, x_n) = V(x_1, x_2, \ldots, x_{n-1})(x_n-x_1)(x_n-x_2)\ldots(x_n-x_{n-1})\) \(\Rightarrow V(x_1, \ldots, x_{n-2})[(x_{n-1}-x_1)\ldots(x_{n-1}-x_{n-2})][(x_n-x_1)\ldots(x_n-x_{n-1})]\) \(\Rightarrow V(x_1, x_2)[(x_3-x_1)(x_3-x_2)]\ldots[(x_n-x_1)(x_n-x_2)...(x_n-x_{n-1})] \\\) \(\Rightarrow \prod_{1\leq i\leq j \leq n} (x_j-x_i)\) 應用 Vandermonde 矩陣常見於數值分析的內插 (interpolation) 問題 給出 n 個資料點 \((x_i, y_i)\)，\(i=1,2,\ldots,n\)，求 n-1 次多項式 \(p(x)=a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\cdots+a_1x+a_0\) 並滿足 \(\begin{aligned} p(x_1)&amp;=a_0+a_1x_1+\cdots+a_{n-1}x_1^{n-1}=y_1\\ p(x_2)&amp;=a_0+a_1x_2+\cdots+a_{n-1}x_2^{n-1}=y_2\\ &amp;\vdots \\ p(x_n)&amp;=a_0+a_1x_n+\cdots+a_{n-1}x_n^{n-1}=y_n \end{aligned}\) 將上面的線性方程組寫為矩陣形式 \(A\mathbf{a}=\mathbf{y}\) A 為 n×n 階 Vandermonde 矩陣 內插問題就是要解出係數向量 \(\mathbf{a}=\begin{bmatrix} a_0&amp;a_1&amp;\cdots&amp;a_{n-1}\end{bmatrix}^T\) 如果 n 個參數 \(x_1,x_2,\ldots,x_n\) 彼此相異，推知 \(\mathrm{det}A_n\neq 0\)， A 是可逆的，方程式必定存在唯一解]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Vandermonde matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Minimum edit cost problem]]></title>
    <url>%2Fwillywangkaa%2F2019%2F01%2F18%2FAlgorithm-Minimum-edit-cost-problem%2F</url>
    <content type="text"><![CDATA[Minimum edit cost problem 最常使用在檔案的比較以及更新上，若在系統上有多個類似的檔案，可以輕鬆比較差異，而若系統中有若干個不同版本的檔案，亦可以藉由此辦法儲存其差異而非整個檔案，如此一來便可以節省其儲存空間。 問題敘述 給定兩個字串 A[1…n]、B[1…m]，在下列三種運算之下，使用最小運算成本將字串 A 轉換成字串 B 插入：在字串中插入一個字元 刪除：在字串中刪除一個字元 替換：將字串中的某一個字元轉換成「指定的字元」 Optimal substructure （以最後一個字元做討論） 假設將 A 轉換為 B 的最少運算序列為 R[1…k]，若 A[n] ≠ B[m]，則當 R[k] 為 「刪除 A 尾端的 A[n]」時，則 R[k-1] 為「A[1…n-1] 轉換為 B[1…m]」的最少運算序列 「 A[n] 中插入一個字元」時，則 R[k-1] 為「A[1…n] 轉換為 B[1…m-1]」的最少運算序列 「將 A[n] 替換成 B[m]」時，則 R[k-1] 為「A[1…n-1] 轉換為 B[1…m-1]」的最少運算序列 若 A[n] = B[m]，則 R[k] 為「A[1…n-1] 轉換為 B[1…m-1]」的最少運算序列 Recursion（c[i,j]：A[1..i] 轉換成 B[1..j] 之最大成本） 若 A[i] ≠ B[j] \(min \left\{\begin{matrix} c[i-1, j]+1 &amp; ,刪除\;A\; 尾端的 \;A[i] \\ c[i, j-1]+1 &amp; , 在\;A[1..i]\;尾端插入B[j] \\ c[i-1, j-1]+1 &amp; ,直接將\; A[i]\; 轉換成 \;B[i] \end{matrix}\right.\) 若 A[i] = B[j] \(c[i-1, j-1] \quad , 為\;A[1...i-1] \;與 \;B[1...j-1] \; 的最少運算序列\) \(\forall i, \quad c[i,0] = i \quad：將\;A[1..i] \;轉換成\; \phi \;的最短運算序列\) 等價於 C[i-1,0]+1；遞迴刪除 A[i] 的末端字元 \(\forall j, \quad c[0,j] = j \quad：將 \;\phi\; 轉換成\; B[1..j] \; 的最短運算子序列\) 等價於 C[0,j-1]+1；遞迴在 \(\phi\) 末端新增 B[j] 字元 Algorithm 123456789101112131415161718192021222324char* MED(char* A, char* B, n, m) &#123; for i from 1 to n &#123; c[i,0] = i; label[i,0] = '↑'; // 等價於 C[i-1,0]+1 &#125; for i from 1 to m &#123; c[0,i] = i; label[0,i] = '←'; // 等價於 C[0,j-1]+1 &#125; for i from 1 to n &#123; for j from 1 to m &#123; if A[i] != B[j] c[i,j] = min(c[i-1,j] +1, // 刪除 A[i] 的字元 c[i,j-1] +1, // 在 A[1..i] 字串末端插入 B[j] 字元 c[i-1,j-1]+1);// 將 A[i] 直接轉換成 B[j] 字元 else c[i,j] = min(c[i-1,j] +1, // 刪除 A[i] 的字元 c[i,j-1] +1, // 在 A[1..i] 字串末端插入 B[j] 字元 c[i-1,j-1]); // 不做任何運算 // 依照上面的運算決定 lebel[i,j] 的性質 &#125; &#125;&#125; Ex （87 年交大資工） A = acbabca；B = babcbac ，使用最少轉換將字串 A 轉換成 B 字串 Recursion（c[i,j]：A[1..i] 轉換成 B[1..j] 之最大成本） 若 A[i] ≠ B[j] \(min \left\{\begin{matrix} c[i-1, j]+D[i] &amp; ,刪除\;A\; 尾端的 \;A[i] \\ c[i, j-1]+I[j] &amp; , 在\;A[1..i]\;尾端插入B[j] \\ c[i-1, j-1]+C[i,j] &amp; ,直接將\; A[i]\; 轉換成 \;B[i] \end{matrix}\right.\) \(\forall i, \quad c[i,0] = \sum_{k =1}^iD[k] \quad：將\;A[1..i] \;轉換成\; \phi \;的最短運算序列\) 等價於 c[i-1,0] + D[i]；遞迴刪除 A[i] 的末端字元 \(\forall j, \quad c[0,j] = \sum_{k=1}^jI[k] \quad：將 \;\phi\; 轉換成\; B[1..j] \; 的最短運算子序列\) 等價於 c[0,j-1] + I[j]；遞迴在 \(\phi\) 末端新增 B[j] 字元 1547791902730 Ex （轉換的成本不一致） 給定兩序列 A[1..3]，B[1..4]，以最少成本將 A 序列轉換成 B 序列 轉換成本 刪除 A[i] 字元 D[1..3] \(\begin{bmatrix} 6 &amp; 1 &amp; 2 \end{bmatrix}\) 插入 B[i] 字元 I[1..4] \(\begin{bmatrix} 5 &amp; 3 &amp; 1 &amp; 1 \end{bmatrix}\) 將 A[i] 字元轉換成 B[j] 字元 C[1..3, 1…4] \(\begin{bmatrix} 1 &amp; 2 &amp; 1 &amp; 1\\ 2 &amp; 1 &amp; 2 &amp; 2\\ 3 &amp; 1 &amp; 2 &amp; 4 \end{bmatrix}\) 1547794356093 DNA comparsion problem Ex（生物資訊比較問題） 在生物資訊學科裡，會給定兩個 DNA 序列 A[1..n]、B[1..m]，並以下列「運算/比較 — 權重」來決定兩個序列之相似度 相似度權重 A[i] = B[j]：比對直接命中 相似度加 2 A[i] ≠ B[j]：比對失敗 相似度減 3 在 A[i] 前插入空字元 ∅ （意旨跳過 B[i] 字元的比較）讓 A[i..n] 與 B[i+1..m] 達到最大相似度 相似度減 1 將 A[i] 字元刪除（意旨跳過 A[i] 字元的比較）讓 A[i+1..n] 與 B[i..m] 達到最大相似度 相似度減 1 Recursion（w[i,j]：A[1..i] 與 B[1..j] 比對的最大相似度） $ max{ \[\begin{matrix} w[i-1, j-1]+2 &amp; A[i]\;與\;B[j]\; 相等，其剩餘最大相似度等於\;w[i-1, j-1]\\ w[i-1, j-1]-3 &amp; A[i]\;與\;B[j] \;不等，其剩餘最大相似度等於\;w[i-1, j-1] \\ w[i-1, j]-1 &amp; 跳過對 \;A[i]\; 的比較，其剩餘最大相似度等於\;w[i-1, j] \\ w[i, j-1]-1 &amp; 跳過對 \;B[i]\; 的比較，其剩餘最大相似度等於\;w[i, j-1]\end{matrix}\] .$ 給定兩個 DNA 序列 A = ACGCTGA；B = AACTGT，使用最少「運算/比較 — 權重」以比較 A、B 字串： 1547798815815]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Graph]]></title>
    <url>%2Fwillywangkaa%2F2018%2F12%2F02%2FData-structure%2F</url>
    <content type="text"><![CDATA[The structure of graph [Note] Adjacency list 有一圖 G = (V, E), |V| = n, |E| = e，需要 n 條相鄰串列（vertex[1…n] : pointer）來表達，其中 vertex[i] 代表頂點 i 的相鄰串列，紀錄所有與頂點 i 相鄰的頂點編號 以「相鄰串列」表示無向圖時，因為 邊(i,j) = 邊(j,i)（一條邊有兩個頂點），所以串列需要 2×e 個節點來儲存這張圖 當圖的邊少時，可以取得優勢 Example（無向圖） 求頂點 i 的「Degree」需要的時間複雜度為？ 即為 vertex[i] 的串列長度，所以需要的時間複雜度為 O(\(V_i\)串列長度) ≦ O(e) Example（無向圖） 求圖上有多少邊的時間複雜度為？ \(e = \frac 12\sum_{i = 1}^n (V_i \;Degree)\\ \therefore e = \frac 12 \sum_{i = 1}^n (V_i \;串列長度)\\ = O(n+e)\) 無向圖上最多可以有 \(\binom {n}{2} = \frac{n(n-1)}{2} = \frac{n^2-n}{2}\) 條邊，從上述又可以得知如果要追蹤以「相鄰串列」表示的無向圖上之邊，最多的時間複雜度為 \(O(n + \frac{n^2-n}{2}) = O(n^2)\) Example 若以「相鄰串列」表示有向圖，要求頂點的「Out-degree」與「In-degree」，分別需要的時間複雜度為？ 「Out-degree」：vertex[i] 的串列長度，所以也為 O(e) 「In-degree」：因為必需追蹤所有點以找到指向 i 的頂點為何，所以全部的串列都要確認，時間複雜度為 \(O(n^2)\) 相鄰串列與相鄰陣列比較表 Adjacency matrix Adjacency list 空間需求 \(O(n^2)\) O(n+e) 表示頂點數多邊數少之圖 需要\(O(n^2)\)且為稀疏矩陣，不適合 適合 表示邊數多（e=O\((n^2)\)）之圖 適合 需要\(O(n+O(n^2))\)，不適合 判斷兩頂點間是否存在邊 時間複雜度 O(1)，適合 時間複雜度 O(e)，不適合 求圖上的邊數（判斷連通…） 時間複雜度 \(O(n^2)\)，不適合 時間複雜度 O(n+e)，適合 Adjacency multilist（相鄰多元串列） 欲表示圖 G = (V,E), |V| = n, |E| = e 每一條邊以一個節點表示 1543649110616 指標陣列（vertex[1…n] : pointer） Vertex[i] 指向第一個包含 \(V_i\) 的邊節點 1543649696312 空間複雜度：O(n+e) Index array 欲表示圖 G = (V,E), |V| = n, |E| = e 一個一維陣列（Array[1… 2×e]）紀錄所有點之相鄰頂點編號 一個一維陣列為「Index」（Index[1…n]）表示頂點 i 在 Array 中紀錄的起始位置 1543650099846 空間複雜度：O(n+e) Incident matrix （離散數學） 欲表示圖 G = (V,E), |V| = n, |E| = e 一個二維陣列（A[1…n, 1…e] : boolean） 若圖中存在邊 \(e_k\)=(i,j)，則 A[i, \(e_k\)]=A[j, \(e_k\)]=1，其餘為 0 1543650560718 圖的追蹤 G = (V,E), |V| = n, |E| = e 比較表 在演算法書籍中，使用「Adjacency list」作深度追蹤與廣度追蹤時，時間複雜度分析考慮了 visit[1…n] 陣列初值的設定，所以為 O(n+e)，而資料結構書籍則無考慮 DFS BFS 佐結構 Stack Queue Adjacency Matrix（時間複雜度） \(O(n^2)\) \(O(n^2)\) Adjacency List（時間複雜度）[DS版] O(e) O(e) Adjacency List（時間複雜度）[Algorithm版] O(n+e) O(n+e) DS 書籍版本 Depth first search 以無項圖為主，此演算法使用「相鄰矩陣」 深度優先追蹤法以「Stack」實作，所以使用遞迴法實現 Algorithm 12345678910111213// Global variable:// G: adjacency matrix// visit[1..n]: 頂點搜尋紀錄，且全部元素已經重設為 false// Parameter:// v: 起始頂點void DFS(v) &#123; visit[v] = true; for(int w = 0; w &lt;= n; w++) &#123; if(G[v,w]) if(!visit[w]) DFS(w); &#125;&#125; Depth first search 的路線並不唯一 通常頂點編號小者優先走訪，考試時路線才會唯一 Breath first search 廣度優先追蹤以「Queue」實作 Algorithm 1234567891011121314151617181920// Global variable:// G: adjacency matrix// visit[1..n]: 頂點搜尋紀錄，且全部元素已經重設為 false// Parameter:// v: 起始頂點int BFS(v) &#123; visit[v] = true; CreateQueue(q); Enqueue(q, v); while(!q.empty()) &#123; u = Dequeue(q); for(int w = 0; w &lt;= n; w++) &#123; if(G[u,w]) if(!visit[w])&#123; visit[w] = true; Enqueue(q, w); &#125; &#125; &#125;&#125; 1543651440091 無向圖二元樹 1543651513624 (見上圖) 在圖中執行 DFS(1) 類似在二元樹中作「前序追蹤」 (見上圖) 在圖中執行 BFS(1) 類似在二元樹中作「層序追蹤」 Example （實現「Level-order」追蹤演算法） 1234567891011121314151617// v: 根節點void Level_order(v) &#123; print(v); Createqueue(q); Enqueue(q, v); while(!q.empty()) &#123; u = Dequeue(q); if(u-&gt;lchild != null) &#123; print(u-&gt;lchild); Enqueue(q, u-&gt;lchild); &#125; if(u-&gt;rchild != null) &#123; print(u-&gt;rchild); Enqueue(q, u-&gt;rchild); &#125; &#125;&#125; Algorithm 書籍版本 Depth first search Algorithm u.Color White：尚未拜訪 Gray：已拜訪，但尚未拜訪完相鄰的頂點 Black：拜訪完相鄰的頂點 u.d 從起點拜訪 u 點的時間 u.f u 點拜訪完所有相鄰頂點的時間 u.parent 在 DFS 拜訪樹中，為 u 的父節點 12345678910111213141516171819202122232425262728293031// time: Global variable 用來記錄追蹤的路徑int DFS_visit(G, u) &#123; time++; u.color = gray; u.d = time; for each w in G.adj[u] &#123; if(w==white) &#123; w.parent = u; DFS_visit(G, w); &#125; &#125; time++; u.color = black; u.f = time;&#125;int DFS(G) &#123; // O(|V|) // Initialize for each u in G.V &#123; u.color = white; u.parent = null; &#125; time = 0; for each u in G.V &#123; if(u.color==white) &#123; DFS_visit(G, u); &#125; &#125;&#125; 有向圖 使用 DFS 追蹤時，會將圖分為四種邊（詳見演算法文章中的圖論） Tree edge：DFS 拜訪經過的邊 Back edge：指向祖先的邊 Forward edge：指向後代的邊 Cross edge：跨不同子樹的邊 在無向圖上，使用 DFS 追蹤只會將圖分成 Tree edge Back edge Breath first search Algorithm u.Color White：尚未拜訪 Gray：已拜訪，但尚未拜訪完相鄰的頂點 Black：拜訪完相鄰的頂點 u.d 從起點到 u 點路徑的邊數（深度） u.parent 在 BFS 拜訪樹中，為 u 的父節點 123456789101112131415161718192021222324252627282930// G: adjacency list// s: 起始頂點BFS(G, s) &#123; // Time complexity: O(|v|) // Initialize // G.V: Vertex set for G for each u in G.V-&#123;s&#125; &#123; u.color = white; u.d = oo; u.parent = null; &#125; s.color = gray; s.d = 0; s.parent = null; CreateQueue(q); Enqueue(q, s); while(!q.empty()) &#123; u = Dequeue(q); // Line A // G.adj[u]: Adjacency list for G for each w in G.adj[u] &#123; // ↑ if(w.color==while) &#123; // ︳ Loop A w.color = gray; // ︳ w.d = u.d+1; // ︳ w.parent = u; // ︳ Enqueue(q, w); // ︳ &#125; // ↓ &#125; u.color = black; &#125;&#125; Time complexity Line A：作「Dequeue」需要 O(1)，共有 |V| 個頂點 O(1)×|V| = O(|V|) Loop A ：找到每個頂點的相鄰頂點 O(2|E|) 總時間複雜度 O(|V|+|E|) 無向圖若邊上無權重，求某起點到各頂點之「最短路徑」可以使用廣度優先追蹤之生成樹即可 追蹤的應用 Example 無向圖 G，判斷是否有連通？ Algorithm 使用 DFS（[DS 版]） 或 BFS 追蹤 G 若 visit 陣列中有頂點尚未被拜訪即為不連通 Time complexity 相鄰矩陣：\(O(|V|^2) + O(|V|) = O(|V|^2)\) 相鄰串列：O(|V|+|E|) + O(V) = O(|V|+|E|) Example 有向圖 G，判斷是否有環路？ Algorithm 用 DFS，若存在「Back edge」即存在環路 Time complexity 相鄰矩陣：\(O(|V|^2)\) 相鄰串列：O(|V|+|E|) （當圖上存在「Hamilton cycle」，為最好的情況，因為只要搜尋過所有點即可找到） Example 無向圖 G，判斷是否有環路？（找「Back edge」即可） 如何判斷「Back edge」？ 修改程式（因為無項圖的邊可來回，為了防止同一邊追蹤兩次須加上 w.parent != u） 12345&gt; ....&gt; for each w in G.adj[u] &#123;&gt; if(w.color==gray &amp;&amp; w.parent!=u) // 為「Back edge」&gt; ....&gt; Spanning tree 針對無向圖 若 G 為非連通圖，則無「Spanning tree」 若 G 為連通圖，則「Spanning tree」≧ 1 Example （True or False） 一個連通無向圖 G，則 G 上任意的「Spanning tree」，必定包含 ≧ 1 條「共同的邊」？ False（見下圖） 1543652365094 Minimum spanning tree 若圖中有多條邊具有相同的值，則「Minimum spanning tree」≧ 1 若每條邊權重皆不同則「Minimum spanning tree」唯一 應用 電路布局成本最小化 連結 n 城市之最少建設成本 Kruskal’s algorithm [Algorithm 書上版本] G = (V,E), |V| = n, |E| = e 最多作 |E| 回合，而每一回合主要有兩個工作 挑選最小成本的邊 (u, v) 邊的權重集合若使用「Heap」維護，則時間複雜度則為「Delete min」的成本（O(log |E|)） 判斷邊 (u, v) 加入到 s 之中是否形成環路（O(1)） 使用一個「Disjoint set」維護「Minimum spanning tree」上的點，在加入新的邊時，使用邊上兩頂點在「Disjoint set」中尋找（Find(u)==Find(v)?），如果兩點都存在於同一個集合中，則形成環路，不加入該邊，反之將該邊加入（Union(u,v)）「Minimum spanning tree」中 若「Disjoint set」採用「Union by height」與「Find with path compression」，則 Union(u,v) Find(u) Find(v) 需要的時間複雜度為 O(1) Time complexity O( |E|×log|E|) Algorithm 12345678910111213141516Mst_kruskal(G, W) &#123; S = ∅; // MST邊集合 D = ∅; // Disjoint set for vertex for each vertex x in G.V &#123; // ↑ D.Make_set(x); // | O(|V|) &#125; // ↓ Sort(G.E); // 針對權重由小到大作排序 O(|E|log|E|) // 由小到大取邊 for each (u,v) in G.E &#123; // ↑ if(D.Find(u)!=Find(v)) &#123; // | S = S ∪ &#123;(u,v)&#125;; // | O(|E|) D.Union(u,v); // | &#125; // | &#125; // ↓ return S;&#125; Time complexity O(|V|) + O(|E|log|E|)+O(|E|) = O(|E|log|E|) 因為 |E| ≦ |V|×|V|，所以 O(|E|log|E|) = O(|E|log|\(V^2\)|) = O(|E|log|V|) Prim’s algorithm [DS 書上版本] Time complexity O(||) Algorithm 12345678910111213141516171819202122// G: graph// W: weight of G.E// r: 起點Mst_prim(G, W, r) &#123; for each u in G.V &#123; // ↑ u.key = ∞; // ︳ Initialize u.parent = null; // ︳ O(|v|) &#125; // ↓ r.key = 0; q = Build_priorityqueue(G.V); // 可以使用「Binary heap」或「Fib. heap」， // O(|V|) while(q != ∅) &#123; u = Extract_min(q); // ↑ LineA:O(log|V|) for each v in G.adj[u] &#123; // ︳ if(v.key &gt; W[u,v]) &#123; // ︳ LoopA v.parient = u; // ︳ v.key = W[u,v]; // ︳ LineB:不斷更新「Prioryty queue」的鍵值 &#125; // ︳ &#125; // ︳ &#125; // ↓&#125; Time complexity （用「Binary heap」作為「Priority queue」） 初值建立 O(|V|) 建立「Priority queue」 O(|V|) Line A：Extract_min(q) 作一次需要 O(log|V|) 共作 |V| 次，需要 O(|V|log|V|) Loop A：總共會檢視 2 ×|E| 個頂點 Line B：v.key = W[u,v] 相當於是作「Decrease key of node in heap」 因為為「Binary heap」，所以需要 O(log|V|) 的時間複雜度 迴圈總共的時間複雜度為 O(|E|log|V|) 總共需要 O(|V|) + O(|V|) + O(|V|log|V|) + O(|E|log|V|) ，因為 |E|≧ |V|-1 ，所以時間複雜度為 O(|E|log|V|) 與「Kruskal」的複雜度一致 可以使用「Fibonacci heap」再進行加速 1543730410752 Time complexity （用「Fibonacci heap」作為「Priority queue」） 初值建立 O(|V|) 建立「Priority queue」 O(|V|) Line A：Extract_min(q) 作一次需要 O(log|V|) 共作 |V| 次，需要 **O(|V|log|V|) Loop A：總共會檢視 2 ×|E| 個頂點 Line B：v.key = W[u,v] 相當於是作「Decrease key of node in heap」 因為為「Fibonacci heap」，所以需要 O(1) 的時間複雜度 迴圈總共的時間複雜度為 O(|E|) 總共需要 O(|V|) + O(|V|) + O(|V|log|V|) + O(|E|) ，因為 |E|≧ |V|-1 ，所以時間複雜度為 O(|V|log|V|+|E|) Sollin’s algorithm 步驟：（開始時先將每個頂點視為獨立的數根） 針對每棵樹，各自挑出「Minimum cost tree edge」 刪除重複挑出的邊 重複第一步與第二步直到成為「最小生成樹」 在循環迭代中 每棵樹都會合併成一棵較大的子樹 每次會使子樹的數量至少減少一半 所以循環迭代的總次數為O( log|V| ) 第一步會檢查所有邊以更新每個連通分量的最小弧 O( |E| ) 時間複雜度 O( log|V|×|E| ) Shortest path problem Dijkstra’s algorithm Bellman-ford algorithm Folyed-warshall algorihm 欲解問題 Single source Single source All pair shortest 策略 Greedy Dynamic programming Dynamic programming 允許負邊？ NO YES YES 允許負環？ NO NO NO 時間複雜度 Adjacency matrix: O(\(V^2\)) Adjacency matrix: O(\(V^3\)) O( \(V^3\) ) Adjacency listHeap：O(|E|log|V|)Fib. heap：O(|V|log|V|+|E|) Adjacency listO(|V|×|E|) Dijkstra’s algorithm [DS 書上版本] 適用於有向圖或無向圖皆可以 Data structure Cost matrix：為一 n × n 的矩陣，n = |V| \(cost[i, j] = \left\{\begin{matrix} 邊成本值 &amp; ,if \;＜i,j＞ \in E \\ 0 &amp; ,if \; i=j \\ \infty &amp; ,if \;＜i,j＞ \notin E\end{matrix}\right.\) S[1…n]：Boolean \(S[i] = \left\{\begin{matrix}False &amp; , 起點到 \;i \;點的最短距離尚未決定 \\True &amp; , 起點到 \;i \;點的最短距離已決定\end{matrix}\right.\) Dist[1…n]：Integer Dist[i] ： 起點到 i 點的最短路徑長（初值為「Cost matrix」起點到該點值） 概念 1543730847726 123if(Dist[i]&gt;Dist[u]+Cost[u,i]) &#123; Dist[i] = Dist[u] + Cost[u,i];&#125; 圖中不可有負邊，否則無法求初正確的最短路徑 1543731055463 以（1）作為起點，使用「Dijkstra’s algorithm」則 Dist[2] = 5，但其實應為 Dist[2] = 2 不得對所有邊以加權種方式使得負邊為正，因為若有一路徑經過點越多，則該路徑權重也倍數成長，如下： 1543731311974 在路徑＜1,2＞路徑上只有增加權重 6 ，但是在路徑＜1,3,2＞上路徑增加權重為 12 Example 1543736203059 Algorithm 1234567891011121314151617181920212223242526272829// s: 起點Initialize(G, s) &#123; // ↑ for each vertex v in G.V &#123; // ︳ v.d = ∞; // ︳ v.parent = null; // ︳ O(|V|) &#125; // ︳ s.d = 0; // ︳&#125; // ↓Relax(u,v,W) &#123; if(v.d &gt; u.d+W[u,v]) &#123; v.d = u.d + w[u,v]; // 不斷更新「Fib. heap」的鍵值:O(1) v.parent = u; &#125; &#125;// W[]: 邊權重集合Dijkstra(G, W, x) &#123; Initialize(G, x); S = ∅; // 已確定為最短路徑之點集合 // 以點的d值建立「Priority queue」（Fib. heap）: O(|V|) q = Build_priorityqueue(G.V); while(q != ∅) &#123; u = extract_min(q); // O(log|V|)×|V| = O(|V|log|V|) S = S ∪ &#123;(u)&#125;; for each vertex v in G.adj[u] &#123; // ↑ Relax(u, v, W); // ︳O(|E|) &#125; // ↓ &#125;&#125; Time complexity Binary heap：O(|V|) + O(|V|) + O(|V|log|V|) + O(|E|log|V|) = O(|E|log|V|) Fibonacci heap：O(|V|) + O(|V|) + O(|V|log|V|) + O(|E|) = O(|V|log|V|+|E|) 等同於「Prim’s algorithm」 與「Prim’s algorithm」的時間複雜度相同 「Prim’s algorithm」與「Dijkstra’s algorithm」都採用「廣度優先搜尋法」 Bellman-Ford algorithm Data structure \(Dist^k[1...n]\)：起點到 i 點的最短路徑長且經過邊數 ≦ k \(Dist^1\) ：初值，「Cost matrix」之起點到各點的權重值 依序求出 \(Dist^2、Dist^3、\ldots、Dist^{n-1}\)，且 \(Dist^{n-1}\) 即為最後結果 1543736615438 \(Dist^k[i] = min_{\forall u}｛Dist^{k-1}[i], min｛Dist^{k-1}[u]+Cost[u, i]｝｝\)，u 為有邊指向 i 的頂點 Example 1543737721578 Algorithm 12345678910111213141516171819202122// Cost: cost matrix// n: |V|// s: 起點BellmanFord(Cost, n, s) &#123; for(int i = 1; i &lt;= n; i++) &#123; Dist[i] = Cost[s,i]; &#125; for(int k = 2; k &lt;= n-1; k++) &#123; // ↑ tmp_Dist[1...n]; // ︳ for(int i = 1; i &lt;= n; i++) &#123; // ↑ ︳ for each u that has edge(u,i) &#123; // ︳ O(|V|) if(Dist[i]&gt;Dist[u]+Cost[u,i]) &#123; // ︳ ︳ tmp_Dist[i] = Dist[u]+Cost[u,i]; // ︳ ︳ &#125; else &#123; // O(|E|) tmp_Dist[i] = Dist[i]; // ︳ ︳ &#125; // ︳ ︳ &#125; // ↓ ︳ &#125; // ↓ copy(Dist[1...n], tmp_Dist[1..n]); &#125;&#125; 採用「Adjacency list」時間複雜度為 O(|V|×|E|) = O(|V|×|\(V^2\)|) Example 如何利用「Bellman Ford algorithm」判斷圖上是否有負環？ 先執行完一次正常的「Bellman Ford」（求到 \(Dist^{n-1}\) 為止） 再求 \(Dist^n\)，若有值比 \(Dist^{n-1}\) 還小，則必存在負環 1234567891011121314for(int i = 1; i &lt;= n; i++) &#123; tmp_Dist[1...n]; for each u that has edge(u,i) &#123; if(Dist[i] &gt; Dist[u]+Cost[u,i]) &#123; if(i==n) &#123; return "存在負環"; &#125; tmp_Dist[i] = Dist[u]+Cost[u,i]; &#125; else &#123; tmp_Dist[i] = Dist[i]; &#125; &#125; copy(Dist[1...n], tmp_Dist[1..n]);&#125; Floyd-Warshell algorithm 假設 G = ＜V, E＞ Data structure \(A^k\) ：n × n 矩陣，n = |V| \(A^k[i, j]\)：i 到 j 之最短路徑且途中經過頂點的編號必須 ≦ k \(A^0\)：原始的「Cost matrix」，依序求出 \(A^1, A^2, \ldots, A^n\) 概念 \(A^k[i,j]= min｛A^{k-1}[i,j], A^{k-1}[i,k]+A^{k-1}[k,j]｝\)，針對點（k）作討論，如果使用此頂點作為中介點路徑是否可以縮短 1543738191981 Example 1543739868201 Algorithm 12345678910111213141516171819// Cost[1..n, 1..n]: 邊的權重集合// n: 頂點數// A[1..n,1..n]: A^k[1..n,1..n]FloydWarshell(Cost, n, A) &#123; // Initialization for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) A[i,j] = Cost[i,j]; // 求取 A^1, A^2, A^3, ..., A^n for(int k = 1; k &lt;= n; k++) &#123; // ↑ tmpA[1..n,1..n]; // ︳ for(int i = 1; i &lt;= n; i++) // ︳ for(int j = 1; j &lt;= n; j++) // O(|V|^3) if(A[i,j]&gt;A[i,k]+A[k,j]) // ︳ tmpA[i,j] = A[i,k]+A[k,j]; // ︳ copy(tmpA, A); // ︳ &#125; // ↓&#125; Johnson’s algorithm All pair shortest path problem for sparse graph 一個 n 個頂點的無負邊有向圖上，可以在每個點上做一次「Dijkstra’s algorithm」以求出「All pair shortest path」 時間複雜度（All pair shortest path） [DS 版本：鄰接矩陣] |V| × O(\(|V|^2\)) = O(\(|V|^3\)) [Algorithm 版本：鄰接串列] |V|×O(|E|log|V|)（Binary heap）；|V|×O(|V|log|V|+|E|)（Fibonacci heap） 一個 n 個頂點的有負邊有向圖上，可以在每個點上做一次「Bellman-Ford’s algorithm」以求出「All pair shortest path」 時間複雜度（All pair shortest path） |V|×O(|V|×|E|) = |V|×O(|\(V^3\)|) = O(|\(V^4\)|) 「Johnson’s algorithm」藉由融合「Bellman-Ford’s algorithm」可以對負邊進行運算的優點，與「Dijkstra’s algorithm」在邊數很少時可以讓複雜度降低的優點，所以在「Sparse graph」計算「All pair shortest path」時，可以因為邊數少而降低時間複雜度，又不因負邊而無法計算正確的數值 演算法概念 以「Bellman-Ford’s algorithm」解決負邊問題 使用「Dijkstra’s algorithm」計算無負邊圖的「Shortest path」 給定一圖 G = ＜V,E＞ 步驟： 加入一個新的頂點 s 與 G 上的每個點連接成為新的圖 G’ = ＜V’, E’＞，且每條新增的邊之權重為 0 對 s 頂點執行「Bellman-ford’s algorithm」（Single source shortest path） 令 s 到其他 G 上的頂點 v 之「Shortest path」為 h(v) 對 G’ 上每個邊進行「重設權重」（Reweight） \(\hat{w}(u,v) = w(u,v) + h(u)-h(v)\) 將 G’ 上 s 點與連接的邊移除，保留「重設權重」的邊，對剩下的每個頂點做「Dijkstra’s algorithm」 時間複雜度：（等價於對每個頂點做「Dijkstra’s algorithm」，只是需要前置處理） $O(|V|) + O(|V||E|) + O(|E|) + |V|O(|V| |V|+|E|) = O(|V|^2 |V|+|V||E|) $ （新增|V|條邊）+（修正負邊）+（重設權重）+（對每個頂點做「Dijkstra’s algorithm」） Example（證明「Johnson’s algorithm」對邊的修正必不會產生負邊） 考慮一個「強連通有向圖」G = ＜V,E＞，並且圖上存在負邊但無負環路 假設 c(u,v) 表示 u 到 v 頂點的權重 假設 d(u,v) 表示 u 到 v 頂點的最小權重 證明 c(w,v) + d(u,w) - d(u,v) ≧ 0，對於圖上任意三個相異頂點 令 u 到 v 頂點的「Shortest path」為 d(u,v) ，所以任何其他從 u 到 v 頂點的路徑必 ≧ d(u,v)，且 d(u,w)+c(w,v) 亦為一個從 u 到 v 頂點的路徑，所以： \(d(u,w) + c(w,v) \geq d(u,v) \Rightarrow c(w,v) + d(u,w) - d(u,v) \geq 0\) johnsonalgorithm_1 Example（證明「重設權重」的圖 G’，其計算的「All pair shortest path」與圖 G 計算相等） 考慮一個「強連通有向圖」G = ＜V,E＞，並且圖上存在負邊但無負環路 假設 c(u,v) 表示 u 到 v 頂點的權重 假設 d(u,v) 表示 u 到 v 頂點的最小權重 新增一頂點 s 並對各個頂點連接且權重為 0，將每個邊以 c(u,v) + d(s,u) - d(s,v)（c(u,v)+h(u)-h(v)）的數值重設權重後成為 G’，證明其「Shortest path」在 G 上亦成立 考慮 P = ＜\(u = v_0, v_1, \ldots, v = v_k\)＞ 為一條從 u 到 v 的一條路徑 令 \(\hat{w}(u,v) = c(u, v)+d(s,u) - d(s,v)\)，則該路徑的權重總和為： \(\hat{w}(P) = \sum_{i = 1}^k \hat{w}(v_{i-1}, v_i)\) 將重設的權重值代入： \(\Rightarrow \sum_{i = 1}^k [c(v_{i-1},v_i)+d(s,v_{i-1}) - d(s, v_i)] = \sum_{i = 1}^k [c(v_{i-1},v_i)+h(v_{i-1}) - h(v_i)]\) 展開相消： \(\Rightarrow (\sum_{i=1}^kc(v_{i-1}, v_i)) + h(v_0) - h(v_k) = w(P)+h(v_0)-h(v_k)\\ \Rightarrow \hat{w}(P) = w(P)+h(v_0)-h(v_k)\) 因為 \(h(v_0)\) 與 h(\(v_1\)) 為固定值，所以當 \(\hat{w}(P)\) 愈小時，等價於 \(w(P)\) 也隨之愈小，且不會因為路徑長短而讓修正的邊影響答案（見下例） Example（失敗的「Reweight」方法） 給定一圖 G = ＜V,E＞，而 P 為一條從 s 到 t 頂點的「Shortest path」，假設將 G 上的每條邊的權重減一成為 G’，請問是否 P 路徑仍為 s 到 t 在 G’ 中的「Shortest path」？ 給定一圖 G = ＜V,E＞，而 P 為一條從 s 到 t 頂點的「Shortest path」，假設將 G 上的每條邊的權重改為 \(\hat{w}(u,v) = w(u, v) - w^＊\) 成為 G’，請問是否 P 路徑仍為 s 到 t 在 G’ 中的「Shortest path」？ \(w^＊ = min_{(u,v)\in G.E}｛w(u, v)｝\) （1）否，因為若路徑越長，權重扣除的越多： 從 u 到 v 頂點的原始「Shortest path」為 ＜u, v＞ johnsonalgorithm_2 因為路徑 ＜u,x,y,v＞ 比路徑 ＜u,v＞ 還要長，所以扣除的權重也越多（每條邊的權重扣 1），所以使 ＜u,x,y,v＞ 成為 u 到 v 的新「Shortest path」 johnsonalgorithm_3 （2）否，概念與上題一致： 從 u 到 v 頂點的原始「Shortest path」為 ＜u, x, y, v＞ johnsonalgorithm_4 因為路徑 ＜u,x,y,v＞ 比路徑 ＜u,v＞ 還要長，所以扣除的權重也越多（每條邊的權重扣 -5；應該說增加權重），所以使 ＜u,v＞ 成為 u 到 v 的新「Shortest path」 johnsonalgorithm_5 Activity on vertex network and topological sort 令 G = ＜V,E＞ 為有向圖，若為一個「Activity on vertex network」，則： Vertex：代表「工作」（Activity） Edge：工作之間的「先後次序關係」 若（頂點 i）→（頂點 j），代表「工作（i）必須要在工作（j）之前作完」 應用 判斷計畫工作先後的執行是否合理，即至少要有 ≧ 1 組合理的工作順序（使用拓樸排序來判斷） Topological sort（Order） 給一個不具有環路（使用 DFS 檢查是否有「Back edge」）的「AOV network」，則至少可產生 ≧ 1 組「頂點的拜訪順序」，且若「AOV network 中（i）→（j）」，則最後輸出的拜訪順序中，（i）必定出現在（j）之前 步驟： 找出「In-degree」等於 0 的頂點（i） 輸出該點，並將（i）點指出去的邊從圖中移除 重複第一、第二步直到所有頂點皆已輸出，或是圖上無「In-degree」等於 0 的頂點 確認是否所有頂點皆輸出，若否表示該圖上無法建立一個「Topological sort」（因為該圖上有環路） 若該圖不含有環路，則「Topological sort」 ≧ 1 組；反之，則無法建立「Topological sort」 Example 1543740383474 Algorithm [Algorithm 書上版本] 123456789101112131415161718192021222324252627282930313233343536int DFS_visit(G, u, p) &#123; time++; u.color = gray; u.d = time; for each w in G.adj[u] &#123; if(w==white) &#123; w.parent = u; DFS_visit(G, w, p); &#125; &#125; time++; u.color = black; u.f = time; insertFront(u, p); // 當一個頂點完成了 DFS 的搜尋，將該頂點插入連結串列的前面&#125;void DFS(G, p) &#123; // O(|V|) // Initialize for each u in G.V &#123; u.color = white; u.parent = null; &#125; time = 0; for each u in G.V &#123; // ↑ if(u.color==white) &#123; // | DFS_visit(G, u, p); // | O(|V|+|E|) &#125; // | &#125; // ↓&#125;ptr Topologicalsort(G) &#123; ptr p = null; DFS(G, p); return p; // 回傳建立好的「Topological sort」的鍊結串列&#125; Example 1543740792975 Time complexity （等同於 DFS 的時間複雜度）O(|V|+|E|) Topological sort（DFS 應用） 在「有向圖」上找出「Strongly connected component」 Algorithm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&gt; int DFS_visit(G, u, p) &#123;&gt; time++;&gt; u.color = gray;&gt; u.d = time;&gt; for each w in G.adj[u] &#123;&gt; if(w==white) &#123;&gt; w.parent = u;&gt; DFS_visit(G, w, p);&gt; &#125;&gt; &#125;&gt; time++;&gt; u.color = black;&gt; u.f = time;&gt; insertFront(u, p); // 當一個頂點完成了 DFS 的搜尋，&gt; // 將該頂點插入連結串列的前面&gt; &#125;&gt; &gt; int DFS_visit(G, u) &#123;&gt; time++;&gt; u.color = gray;&gt; u.d = time;&gt; for each w in G.adj[u] &#123;&gt; if(w==white) &#123;&gt; w.parent = u;&gt; DFS_visit(G, w, p);&gt; &#125;&gt; &#125;&gt; time++;&gt; u.color = black;&gt; u.f = time;&gt; &#125;&gt; &gt; void DFS(G, p) &#123;&gt; // O(|V|)&gt; // Initialize&gt; for each u in G.V &#123;&gt; u.color = white;&gt; u.parent = null;&gt; &#125;&gt; time = 0;&gt; for each u in G.V &#123; // ↑&gt; if(u.color==white) &#123; // |&gt; DFS_visit(G, u, p); // | O(|V|+|E|)&gt; &#125; // |&gt; &#125; // ↓&gt; &#125;&gt; &gt; graph Stronglyconnectedcomponent(G) &#123;&gt; ptr p = null;&gt; reverse(G_T, G); // 將原本 G 上的邊＜u,v＞，改為邊＜v,u＞&gt; DFS(G, p);&gt; &gt; // Initialize，要對 G_T 作 DFS 的事前準備&gt; for each u in G_T.V &#123;&gt; u.color = white;&gt; u.parent = null;&gt; &#125;&gt; time = 0;&gt; for(ptr i = p; i-&gt;link != null; i = i-&gt;link) &#123; &gt; // 沿用「Topological sort」的鍊結串列，&gt; DFS_visit(G_T, i); // 因為此順序恰巧是「Finish time」由大到&gt; &#125; // 小排序下來，依照此順序對 G_T 作 DFS&gt; &gt; return G_T; // 在 G_T 上的 DFS forest 即為各個&gt; // 「Strongly connected component」&gt; &#125;&gt; Example 1543741711989 有向無環路圖（Direct acyclic graph）上求「Single source all shortest paths」 可以利用「Topological sort」（O(|V|+|E|)）來減少維護「Fibonacci heap」需要的時間複雜度（每回合的Delete-min：O(|V|log|V|)） Algorithm 1234567891011121314151617181920212223242526272829&gt; // s: 起點&gt; Initialize(G, s) &#123; // ↑&gt; for each vertex v in G.V &#123; // ︳&gt; v.d = ∞; // ︳&gt; v.parent = null; // ︳ O(|V|)&gt; &#125; // ︳&gt; s.d = 0; // ︳&gt; &#125; // ↓&gt; &gt; Relax(u,v,W) &#123;&gt; if(v.d &gt; u.d+W[u,v]) &#123;&gt; v.d = u.d + w[u,v];&gt; v.parent = u;&gt; &#125; &gt; &#125;&gt; &gt; // W[1..n,1..n]: 邊權重集合&gt; // s: 起點&gt; void DAG_shorestpath(G,W,s) &#123;&gt; ptr p = Topologicalsort(G);&gt; // Dijkstra's algorithm&gt; Initialize(G, s);&gt; for(ptr u = p; u-&gt;link != null; u = u-&gt;link) &#123;&gt; for each vertex v in G.adj[u] &#123;&gt; Relax(u,v,W)&gt; &#125;&gt; &#125;&gt; &#125;&gt; Example 1543742596379 Time complexity O(|V|+|E|) + O(|V|) + O(|V|) + O(|E|) = O(|V|+|E|) 「Topological sort」+「Initialization」+「Trace adjacency list」 Activity on edge network, critical path and critical task 應用於「計畫的專案管理」、CPM（Critical path management） G = ＜V,E＞ 為有向圖且為「AOE network」，則： Vertex：代表「事件」（Event）、「里程碑」（Milestone）、「查核點」 Edge：代表「工作」（Activity） 權重：代表該「工作」需要完成的工作時數 所有指向某「事件頂點」的工作全部完成時，該事件才會發生 「事件頂點」一旦觸發後，從此頂點指出的「工作邊」才可以開工 1543742794508 Example 1543743405702 完成計畫最快需要幾天？ 求 s 至 e 之最常路徑，也就為「Critical path」的長度（24天） 1543743598858 列出所有「Critical path」 ＜s,e＞路徑長為 24 的皆為「Critical path」 1543744208911 列出所有「Critical task」（不可延遲的工作） 在「Critical path」上的工作邊｛\(a_1, a_6, a_7, a_8, a_{10}, a_{12}\)｝ 那些工作（瓶頸）的時數縮短後，可有效的縮短整體計畫之工作時數？ 所有「Critical path」上的「共同工作」（交集邊）｛\(a_1, a_6, a_{12}\)｝ 1543744339082 那些工作可以延遲？可以延遲多久不影響進度？ 不在「Critical path」上的工作邊可以有延遲 求各個事件頂點點之「最早觸發時間」（起點至各點的「最長路徑長」） 事件頂點 s t u v w x e 最早觸發時間點 0 8 13 16 19 12 24 最晚觸發時間點 求各個事件頂點點之「最晚觸發時間」（終點回推各點的最小值） 1543745099778 綜合以上可以發現事件頂點 x 必定要在第 7 天觸發 查看指向自己的頂點以確認最晚觸發的時間，也可以確認該工作邊是否可以延遲 1543747954832 事件頂點 s t u v w x e 最早觸發時間點 0 8 13 16 19 12 24 最晚觸發時間點 0 8 13 16 19 14 24 事件頂點 x 的觸發可以延遲 求各個工作之「最早開工」與「最晚開工」時間點 最早開工等價於「需觸發之事件點」之「最早觸發」時間點 最晚開工等價於「欲觸發之事件點」之「最晚觸發」時間點 1543748398923 工作邊 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 最早開工時間點 0 0 0 8 8 8 13 13 12 16 12 19 最晚開工時間點 0 8 9 10 9 8 13 13 14 16 19 19 在「Critical path」上的工作邊｛\(a_1, a_6, a_7, a_8, a_{10}, a_{12}\)｝ Articulation point Example 1543748935456 橘色即為「Articulation point」 Biconnected graph 一個連通無向圖，且無「Articulation point」，則稱為「Biconnected graph」 應用 網路節點設置 Biconnected component 子圖 連通 為極大的「Biconnected」子圖 1543749321235 求出「Articulation point」（以上圖為例） 從任意頂點作「深度優先查找」（這裡作DFS(3)），求出各點的「DFN」（DFS拜訪順序） 頂點 0 1 2 3 4 5 6 7 8 9 DFN 3 2 4 1 5 6 7 8 9 10 LOW 畫出「DFS spanning tree」並標出「Back edge」 1543749964256 求個頂點的「low」值 \(low(x) = min｛dfn(x), ｛dfn(y)|為x的後代頂點最多經過一條「Back\;edge」所到之頂點｝｝\) 頂點 0 1 2 3 4 5 6 7 8 9 DFN 3 2 4 1 5 6 7 8 9 10 LOW 3 1 1 1 1 6 6 6 9 10 判斷「Articulation point」 針對樹根頂點：若有 ≧ 2 個子頂點，則必為「Articulation point」 （3）有 ≧ 2 個子頂點，所以為「Articulation point」 針對非樹根頂點：任意一個 x 之子頂點 y（非所有後代頂點）只要符合low(y) &gt;= dfn(x)，則為「Articulation point」 （1）之子頂點（0）：dfn(1)&lt;=low(0)，為「Articulation point」 （2）之子頂點（4）：dfn(4)&gt;low(2)，非「Articulation point」 （5）之子頂點（6）：dfn(5)&gt;low(6)，非「Articulation point」 （6）之子頂點（7）：dfn(6)&gt;low(7)，非「Articulation point」 （7）之子頂點（8）、（9）：dfn(7)&gt;low(8)&amp;&amp;dfn(7)&gt;low(9)，非「Articulation point」 針對葉頂點：皆非「Articulation point」 （0）、（4）、（8）、（9）]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Search and sort]]></title>
    <url>%2Fwillywangkaa%2F2018%2F11%2F17%2FData-structure-Search-and-sort%2F</url>
    <content type="text"><![CDATA[Binary search Example n 筆資料作「Binary search」最多比較次數？ \(\lceil \lg (n+1) \rceil\) 200 筆資料：最多 8 次的搜尋 1024 筆資料：最多 11 次的搜尋 Example n 筆資料作「Binary search」 其「Worst case」為 O(log n) n 筆資料以「Binary search tree」作查找 其「Worst case」為 O( n ) ( Skew tree ) 其「Best case」為 O( log n ) Internal sort and external sort Internal sort 資料量少可一次載入到記憶體中進行排序 External sort 資料量太多無法一次全部置入記憶體之中，需藉由外部儲存體 ( Disk ) 來保存再進行排序 常用的「External sorting method」 Merge sort ( Selection tree 輔佐 ) M-way search tree、B-tree、B\(^+\)-tree 排序性質比較表 此表為方便比較用圖，欲瞭解其推倒原因詳見下方細述 Sort algorithm T.C. (Best) T.C. (Worst) T.C. (Avg.) S.C. Stable Insertion O(n) \(O(n^2)\) \(O(n^2)\) O(1) Yes Selection \(O(n^2)\)☆ \(O(n^2)\) \(O(n^2)\) O(1) No Bubble O(n) \(O(n^2)\) \(O(n^2)\) O(1) Yes Shell \(O(n^\frac 32)\) \(O(n^2)\) \(O(n^2)\) O(1) No Quick O(nlogn) \(O(n^2)\)☆ O(nlogn) O(lgn)~O(n)☆ No Merge O(nlogn) O(nlogn) O(nlogn) O(n) Yes Heap O(nlogn) O(nlogn) O(nlogn) O(1)☆ No Radix N/A N/A O(d×(n+r)) O(r×n)☆ Yes Counting N/A N/A O(n+k) O(n+k)☆ Yes 註 T.C. = Time complecity S.C. = Space complexity r 為「Redix sort」的基數大小 d 為「Redix sort」以 r 作為基數之位數最大值 k 為「Counting sort」之資料值域範圍 初等排序 Insertion sort 演算法 12345678910111213141516// 將資料 r 插入到已排好的區塊 A[0] ~ A[i]Insert(A[], r, i) &#123; j = i; while(r &lt; A[j]) &#123; A[j+1] = A[j]; j = j-1; &#125; A[j+1] = r;&#125;Insort(A[], n) &#123; A[0] = -oo; for(int i = 2; i &lt;= n; i++) &#123; Insert(A, A[i], i-1); &#125;&#125; Time complexity Best case：O(n) 當「Input data」恰巧為小到大，每回合檢查一次即可確定 r 的插入位置，共作 n-1 回合所以 O(n) Worst case：O( \(n^2\) ) 當「Input data」恰巧為大到小，\(Total = 1+2+ \ldots+n-1 \\=\frac{n(n-1)}{2} = O(n^2)\) 1541038370084 Avg. case：O( \(n^2\) ) 利用遞迴時間函數，令第 n 筆資料之平均比較次數 (Time complexity) 為 O(n) \(T(n) = T(n-1) + \frac n2 \\ = T(n-2) + \frac{n-1}2 + \frac n2 \\ \vdots \\ = \frac{1+2+\ldots+n}{2} = \frac{n(n+1)}{4} = O(n^2)\) Space complexity ( 除了「Input data」之外所需空間 ) O( 1 ) 1541092068950 Stable 因為這行程式碼while(r &lt; A[j]) do...所以不會交換一樣大小的資料 Selection sort 演算法 12345678910void SelectionSort(int a[], int n) &#123; // Iterate through array elements for (int i = 0; i &lt; n - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) if (a[min] &gt; a[j]) min = j; if(min != i) swap(a[i], a[min]); &#125; &#125; 1541092807581 Time complexity Best case：\(O(n^2)\) Worst case：\(O(n^2)\) Avg. case：\(O(n^2)\) Space complexity O( 1 ) 1541093304800 Unstable 多用在大型紀錄( 由多欄位組成之資料 ) 之排序 每回合最多一次資料交換 ( Swap )，不會吃太多資料存取較有優勢 if(min != i) do... 如果省略，可以省下比較之次數但是會多增加一次資料交換，所以適用於大多資料皆未落在正確位置之上時 ☆Bubble sort 版本一 由左而右，兩兩互相比較，若前者大於後者交換之 當某一回合在檢查時，未發生資料交換 ( Swap ) 則可以提早結束演算法 此演算法稱為「Bubble」是因為在每一回合檢查完，當時「Sublist」中最大值會往最高位置走，形同大泡泡往水上浮起一般 演算法 1234567891011121314void bubblesort(A[], n) &#123; for(int i = n; i &gt;= 1; i--) &#123; bool f = false; for(int j = 1; j &lt; i; j++) &#123; if(A[j]&gt;A[j+1]) &#123; swap(A[j], A[j+1]); f = true; &#125; &#125; if(!f) &#123; break; &#125; &#125;&#125; 1541094481788 版本二 由左而右，兩兩互相比較如果後者小於前者交換之 此處之「Bubble」是將最小值往最小位置走 演算法 12345678910111213void bubblesort(A[], n) &#123; for(int i = 1; i &lt;= n; i++) &#123; bool f = false; for(int j = n; j &gt; i; j--) &#123; if(A[j] &lt; A[j-1]) &#123; swap(A[j], A[j-1]); f = true; &#125; &#125; if(!f) break; &#125;&#125; 1541094963273 Time complexity Best case：O( n ) 在第一回合檢查時歷經 (n-1) 次比較，但無須作「Swap」即可將排序完成 \(T(n) = 0 + (n-1), T(1) = 0\) ( 第一回合之比較次數 + 剩下 n-1 筆資料之「Bubble sort」) Avg. case：O( \(n^2\) ) \(T(n) = O(n) + T(n-1)\) ( 每回合之平均比較次數 + 剩下 n-1 筆資料之「Bubble sort」) \(T(n) = O(n) + T(n-1) \\ \vdots \\ = T(1) + c \cdot(2 + \ldots + n) = O(n^2)\) Worst case：O( \(n^2\) ) 在「Input data」恰巧為大至小之狀況 (見下圖) 處理 n 筆資料時則為 \(n + (n-1) + \ldots + 1 = O(n^2)\) 1541214129532 Space complexity O( 1 ) Stable 因為 if(A[j]&gt;A[j+1]) 必須要大於才會交換資料所以為穩定排序法 [Weiss 版本] Shell sort 從 1 元素到 n-span 元素，比較 A[i] 與 A[i+span] ，若前者大於後者則交換；每一回合需持續到沒有交換為止，再進入下一回合 Span 型式（將會決定總回合數） ( 一般型 ) \(\lceil \frac {n}{2^k}\rceil\) 或 \([\frac{n}{2^k}]\) 第一回合 span 等於 \(\frac n2\) 第二回合 span 等於 \(\frac n4\) 以此類推，最後一回合 span 為 1 \(2^k-1\) 第一回合 span 等於 15 第二回合 span 等於 7 以此類推，最後一回合 span 為 1 （自訂型） 第一回合 span 等於 7 第二回合 span 等於 5 第三回合 span 等於 2 最後一回合 span 為 1 最後一回合 span 必須為 1 當此回合的 span 值為 k 時，則表示有 k 條「Sublist」要排序， Example ( Span型：5、3、2、1 ) 排序：9 8 7 2 3 5 1 4 6 1542454674621 Algorithm 123456789101112131415// span 型態 =&gt; n/(2^k)Shellsort(A[], n) &#123; span = n/2; while(span &gt;= 1) &#123; do &#123; f = 0; for(int i = 1; i &lt;= (n-span); i++) &#123; if(A[i] &gt; A[i+span]) &#123; swap(A[i], A[i+span]); f = 1; &#125; &#125; &#125; while(f != 0); &#125;&#125; Time complexity Avg. case：\(O(n^2)\) Worst case：\(O(n^2)\) Best case：目前無定論，與「Span 型態」有關 \(O(n^{\frac 32})、O(n^{\frac 54})、O(n^{\frac 76})\) Space complexity O(1) 1542455003562 Unstable 高等排序 Comparesion based ( Comparsion and swap ) sort 研究與探討 使用比較大小的方式進行排序可以使用一個「Decision tree」來表達 Example 三筆資料 R1, R2, R3 不知其大小關係，在排序之後之所有可能 1541935896940 根據上圖之「Decision tree」： 為一個「Binary tree」 非葉節點：「比較過程之節點」( Comparsion node ) 葉節點：「某個排序的結果」 假設排序 n 筆資料：會產生 n! 之排序可能結果，會有 n! 個葉節點 \(\because 總節點數量 = 葉節點數量 + 非葉節點數量 = 2\times 非葉節點數量 + 1 \\有\; n! \;個葉節點 \Rightarrow n! -1 \;個非葉節點\) \(\because 有\; n! \;個葉節點，又為「Binary \;tree」 \\ Tree \;height (h) \Rightarrow 2^{h-1} \geq n! \\ \Rightarrow h-1 \geq \lceil \lg n! \rceil \\ \Rightarrow h \geq \lceil \lg n! \rceil +1 \Rightarrow \\ \therefore 總共的比較需要大於等於 \lceil n \lg n \rceil \approx n\lg n \\ 「Comparsion\;based \; sort」 最快之\; Time \;complexity= \Omega ( n\lg n )\) Example 五筆資料排序之比較次數至少為何？ 5 × lg 5 =&gt; 10 \(\lceil \lg n!\rceil = \lceil\lg 5!\rceil = \lceil \lg 120 \rceil \approx 7\) 若非使用「Comparsion based」則可以不受到此限制，時間複雜度最快可達到線性時間 Quick sort Avg. case 在實際排序時間最快的方法 採用「Divide and conquer」作法 令陣列最左資料 A[1] 作為「Pivot key」，經過「分割」( Partition ) 動作後，將「Pivot」置於大小關係“最正確”的位置上 1541215583779 可用多線程電腦加速執行 Quicksort1 ( Hoare partition ) 1541216603304 Example 排序：6, 8, 3, 7, 5, 9, 4, 1, 10, 2 1541217794632 Algorithm 1234567891011121314151617181920212223242526// 排序陣列 A[l] ~ A[u]Qsort(A[], l, u) &#123; // Partition if(l &lt; u) &#123; i = l; j = u+1; p = A[l]; do &#123; do &#123; i++; &#125; while(A[i] &lt; p); do &#123; j--; &#125; while(A[j] &gt; p); if( i &lt;= j ) &#123; swap(A[i], A[j]); &#125; &#125; while(i &lt;= j); swap(A[l], A[j]); Qsort(A[], l, j-1); Qsort(A[], j+1, l); &#125;&#125; Example 排序：\(5^＊, 5, 5, 5, 5\) 1541218724819 Unstable Time complexity Best case：O( n log n ) (下圖一) 「Partition」恰將「Input data」分成兩等分 \(T(n) = O(n) + T(\frac n2) + T(\frac n2)\)：Partition time + 左右邊作「Quick sort」 \(T(n) = 2T(\frac n2) + cn\\ =nT(1) +c\cdot n\log n = O(n \log n)\) Avg. case：O( n log n ) (下圖二) \(T(n) = c\cdot n + \frac 1n\cdot \sum_{s = 1}^n (T(s) + T(n-s))\) Partition time + 全部狀況之平均 （1）$nT(n) = c n^2 + _{s = 1}^n(T(s) + T(n-s))\ = [(T(1)+T(n-1)) + (T(2)+T(n-2)) + + (T(n)+ T(0))] + cn^2 \ = 2 [T(1)+T(2)++T(n-1)] + T(n) + cn^2 $ 以 (n-1) 代入式（1）成為式（2） （2）$(n-1)T(n-1) = 2[T(1)+ T(2)++T(n-2)]+T(n-1)+c(n-1)^2 $ 式（1）— 式（2） \(\Rightarrow nT(n) - (n-1)T(n-1) = 2T(n-1)+T(n)-T(n-1)+c(n^2 - (n-1)^2) \\ \Rightarrow nT(n) - nT(n-1) + T(n-1) = T(n-1) + T(n) + c(n^2-(n-1)^2) \\ \Rightarrow (n-1)T(n) = nT(n-1) + c(n^2- (n-1)^2) \\ \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac{2n-1}{n(n-1)}) \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac 1n + \frac{1}{n-1}) \\ \Rightarrow \frac{T(n)}{n} = c(\frac 1n+\frac 1{n-1} + \ldots+\frac 12) + c (\frac 1{n-1} + \frac 1{n-2} + \ldots + \frac 11) \\ \Rightarrow\frac{T(n)}{n} = c(H_n -1) + c(H_n + \frac 1n) \\ \Rightarrow T(n) = 2 c\cdot n \cdot H_n - cn -c \\ = 2\cdot c \cdot n \log n - cn -c = O(n\log n)\) 上述遞迴時間表示式忽略執行「Partition」後，右邊會多少一筆資料（下圖二） 完整表示應該為 \(T(n) = \frac 1n \sum_{s = 0}^{n-1}(T(s) + T(n-1-s)) + c\cdot n\) Worst case：O( \(n^2\) ) (下圖三) 當 Pivot 恰為最小最大值時，作「Partition」不會使「Divide and conquer」的優點顯現 整體資料為「由小到大」或「由大到小」時會發生「Worst case」 \(T(n) = O(n) + T(n-1) \\ = T(1) + (2 + 3 + \ldots + n) \cdot c \\ = c \cdot \frac{(n+2)(n-1)}{2} = O(n^2)\) 1541765950716 圖一 1541766239354 圖二 1541766394245 圖三 如何避免「Worst case」發生？ 避免 Pivot 為最小值或最大值 Randomized quicksort 亂數挑一個數作為 Pivot 仍有可能發生「Worst case」( 無法完全解決問題 ) Middle of three （下圖） 做法 \(M = \frac {L+U}{2}\) 比較 A[L], A[M], A[U] 找出三者中之中間值，以此中間值與 A[l] 交換 選擇 A[L] 作為 Pivot（中間值），作「Quicksort partition」 可以解決「Worst case」問題 1541766823939 Median of medians ＜下方細述＞ Space complexity（遞迴所需的「Stack space」） Best case (下圖一)：O( log n ) Worst case (下圖二)：O( n ) 1541816631365 圖一 1541816965630 圖二 Quicksort2 ( 「Algorithm」書中版本 ) Example 2 8 7 1 3 5 6 4 之第一次「Partition」 1541818660118 Algorithm 1234567891011121314151617181920Quicksort(A[], p, r) &#123; // 排序 A[p] ~ A[r] if(p &lt; r) &#123; q = Partition(A[], p, r); // 見下圖一 Quicksort(A[], p, q-1); Quicksort(A[], q+1, r); &#125;&#125;Partition(A[], p, r) &#123; pivot = A[r]; i = p-1; for(l = p; i &lt;= r-1; j++) &#123; if(A[j] &lt;= pivot) &#123; i++; swap(A[i], A[j]); &#125; &#125; swap(A[i+1], A[r]); return i+1;&#125; Example The output of quicksort pass1 1 2 3 4 5 1541927350444 5 4 3 2 1 1541927780299 \(5 \;5 \;5 \;5 \;5^＊\) 在「Quicksort 2」演算情況下會是「Worst case」（O(\(n^2\))） 在「Quicksort 1」演算情況下會是「Best case」 1541928492844 改善上述問題 在「Partition」執行前檢查該陣列中元素是否相同：O( n ) 改採用「 Hoare partition」：「Best case」O( n log n ) 問題與討論—Selection problem 問題概要：想要在一個未排序的一維陣列中，找到其最大值與最小值 Native solution 歷經 n-1 次比較後找出最大值 剩下 n-1 筆資料中歷經 n-2 次比較找出最小值 總比較次數：(n-1) + (n-2) = 2n-3 次比較 改良解法 A[1] 與 A[2] 比較一次知道兩數大小 令兩者之大數為 m 、小數為 n 針對後面 n-2 筆資料以遞迴找出最大值與最小值（A[3]、A[4]、A[n-4]） 令 n-2 筆資料的最大值為 x、最小值為 y 『m 與 x 比較一次找出最大值』、『n 與 y 比較一次找出最小值』 初值 T(0) = T(1) = 0 T(2) = 1 總比較次數 T(n) = T(n-2) +（A[i] 與 A[i+1] 比較一次 + m 與 x 比較 + n 與 y 比較一次） \(T(n) = T(n-2) + 3 \\ = T(n-4) + 6 \\= T(n-6) + 9 \\ \vdots \\= T(0) + 3 \cdot \frac n2 &lt; 2n-3\) 稍微減少比較次數 問題與討論—Select i-th item among n unsorted data array 在未排序的陣列中找到第 i 小的資料 學過的演算法中： 不知道其值域 以「Quick sort」等算法求取資料各個大小的資訊 O(n log n) 知道資料範圍 以「Radix sort」等算法求取資料的大小資訊 O(n) 如果以「Comparison based」來解決這個問題有無更快的算法？ 利用「Quick sort」中的「Partition」為此算法基底 Algorithm 123456789101112// 在 A[p]~A[r] 中找到第 i 小的資料Select(A[], p, r, i) &#123; q = Partition(A, p, r); // 將 pivot 大小定位在 q 點 k = q-p+1; // 算出 pivot 是第 k 小的資料 if(i == k) &#123; // pivot 即為 A[p]~A[r] 中第 k 小的資料 return A[q]; &#125; else if(i &lt; k) &#123; Select(A, p, q-1, i); &#125; else &#123; Select(A, q+1, r, i-q); &#125;&#125; Time complexity Best case：Pivot 的定位恰將資料切為兩等分 對左半或是右半作「Selection」+ 「Partition」 \(T(n) = T(\frac n2) + cn \\ = c(n + \frac n2 + \frac n4 + \ldots+1) = \Theta(n)\) Average case \(T(n) = \frac 1n\sum_{s = 0}^{n-1} T(s)+ cn = O(n)\) Worst case 當 Pivot 恰為最大或是最小值 \(T(n) = T(n-1) + cn\\ = n + (n-1) + (n-2) + \dots + 1 = O(n^2)\) 解決辦法 採取「Median of medians」選擇 Pivot ，將 Worst case 弭平為 O(n) Selection with median of medians 1542449916157 步驟 先將 n 筆資料分成 \(\lceil \frac n5 \rceil\) 個群組，每個群組有五筆資料（可能有一群組不足 5 筆資料） 時間複雜度 O(n) 針對每個群組各自排序（如：Insertion sort） 時間複雜度 每個群組最多花費 O(25) 次比較 共有 \(\lceil \frac n5 \rceil\) 個群組 總共需 O(n) 每個已排序群組中第三個資料為該群組之中間值 對 \(\lceil \frac n5 \rceil\) 個群組的中間值作「Selection with median」 這些中間值中的中間值即為「Median of medians」 時間複雜度 遞迴呼叫「Selection with median」函式 在中間值中找第 \(\frac{\lceil\frac{n}{5}\rceil}{2}\) 小的中間值 \(T(\lceil\frac n5\rceil)\) 以「Median of medians」作為「Pivot」進行「Partition」 時間複雜度 O(n) 繼續尋找 i 大小的值 時間複雜度 取決於「Median of medians」作為「Pivot」將資料切割之程度 12345678k = q-p+1;if (i == k) &#123; return A&#123;q];&#125; else if (i &lt; k) &#123; Select(A, p, q-1, i);&#125; else &#123; Select(A, q+1, r, i-k);&#125; 扣除「Pivot」所在的群組以及不滿五筆資料之群組 約有一半的群中組必有 3 筆資料 ≧「Pivot」 比「Pivot」大的資料個數 $(12 n5-2) 3 = -6 $ 相反的會有 \(\lceil \frac{7n}{10}\rceil +6\) 筆資料 ≦「Pivot」 1542450245855 Time comlexity （下圖）最糟糕的情況 在資料比較多的地方作「Select」 在 \(\lceil \frac{7n}{10}\rceil +6\) 中遞迴找出目標值 第五步的遞迴最壞需要 \(T(\lceil \frac{7n}{10}\rceil + 6)\) \(T(n) = T(\lceil\frac n5\rceil) + T(\lceil \frac{7n}{10}\rceil+6)+O(n) \\ = T(\frac 15n)+ T(\frac 7{10}n) + cn = O(n)\)（以樹狀結構解此遞迴） 1542451499380 （下圖）如果以七筆資料為一群組 至少有 \((\frac 12\cdot\lceil\frac n7\rceil -2)\cdot 4\) 筆資料 ≧「Pivot」 \(\frac{2n}{7}-8\) 筆 ≧「Pivot」 \(\lceil \frac {5n}{7}\rceil+8\) 筆 ≦「Pivot」 \(T(n) = O(n) + O(n) + T(\lceil\frac n7\rceil) +O(n) + T(\lceil \frac{5n}{7}\rceil+8) \\ = T(\frac n7)+ T(\frac 57n)+cn = O(n)\) 1542450561714 （下圖）如果以三筆資料為一群組 至少有 \((\frac 12\cdot\lceil\frac n3\rceil -2)\cdot 2\) 筆資料 ≧ 「Pivot」 \(\frac{n}{3}-4\) 筆 ≧「Pivot」 \(\lceil \frac {2n}{3}\rceil+4\) 筆 ≦「Pivot」 \(T(n) = O(n) + O(n) + T(\lceil\frac n3\rceil) +O(n) + T(\lceil \frac{2n}{3}\rceil+4) \\ = T(\frac n3)+ T(\frac 23n)+cn = O(n\log n)\) 1542450928741 Merge sort 適用於「External sort」，所以可以又稱為「External merge sort」；其特性可讀入一些能放在內存內的數據量，在內存中排序後輸出為一個順串（即是內部數據有序的臨時文件），處理完所有的數據後再進行歸併 (見外排序- 維基百科，自由的百科全書 - Wikipedia) 名詞 「Run」：順串；排序好的片段資料 「Run」的長度：順串中的資料量 計算機科學家 吉姆·格雷 的 Sort Benchmark 網站用不同的硬體、軟體環境測試了實現方法不同的多種外排序算法的效率。效率較高的算法具有以下的特徵： 並行計算 用多個磁碟驅動器並行處理數據，可以加速順序磁碟讀寫 在計算機上使用多執行緒，可在多核心的計算機上得到優化 使用異步輸入輸出，可以同時排序和歸併，同時讀寫 使用多台計算機用高速網絡連接，分擔計算任務 提高硬體速度 增大內存，減小磁碟讀寫次數，減小歸併次數 使用快速的外存設備，比如15000 RPM的硬碟或固態硬碟 使用性能更優良個各種設備，比如使用多核心 CPU 和延遲時間更短的內存 提高軟體速度 對於某些特殊數據，在第一階段的排序中使用基數排序 壓縮輸入輸出文件和臨時文件 外歸併排序法並不是唯一的「External sort」，另外有「外分配排序」，其原理類似於內排序中的桶排序（Bucket sort） 「Merge sort」和「Bucket sort」之間存在數學上的某種對偶性 Example（106 清華大學資工基礎計算機科學第 6 題） 簡述 比較兩個「External sort」分別的特性，並且個別適合什麼類型的資料型態 Merge sort Bucket sort Merge sort 因為其特性，適合大量資料的排序，可以將資料從「Second storage」中取得資料存於 RAM 中，再進行排序，歸併後再輸出至「Second storage」 Bucket sort 與「Merge sort」一樣，經過調整的演算法可以作為「外分配排序」，同樣可以處理大量資料，但還有包含另一個性質，若資料位數很大時，或是基底很小時，也建議採用「MSD radix sort」 Iterative merge sort（Two way merge） Example 1542088579919 Algorithm（Merge 2 runs） 1234567891011121314151617181920212223242526// A[l....m]: 子陣列「順串一」// A[m+1..n]: 子陣列「順串二」Merge(A[], l, m, n) &#123; int p = l, q = m+1; int tmp[n-l+1]; // 暫存陣列 [1..(n-l+1)] int i = 1; // 當 run1 與 run2 皆未掃描完 while(p &lt;= m &amp;&amp; q &lt;= n) &#123; if(A[p] &lt;= A[q]) &#123; tmp[i++] = A[p++]; &#125; else &#123; tmp[i++] = A[q++]; &#125; &#125; // run1 未掃描完 while(p &lt;= m) &#123; tmp[i++] = A[p++]; &#125; // run2 未掃描完 while(q &lt;= n) &#123; tmp[i++] = A[q++]; &#125; copy(A[l..n], tmp[1..(n-l+1)]);&#125; Time complexity：O( n log n ) 「順串一」的長度為 m、「順串二」的長度為 n，合併兩順串： \(\left\{\begin{matrix}最少比較次數： &amp; m \;or \;n\\ 最多比較次數（有一方先掃描完）：&amp; m+n-1\end{matrix}\right.\) （下圖一）所以假設整體要排序的資料總量為 n ，合併一次所有的順串需 O(n) n 筆資料作「2-way merge sort」 （下圖二）可以看成一棵「Completed binary search tree」 因為「Merge」回合數 = 樹高 - 1 \(\Rightarrow 2^{k-1} = n \Rightarrow k = \lceil \lg n\rceil +1\) \(\Rightarrow 「Merge」回合數 = \lceil \lg n\rceil \\ \because 每個回合作「Merge」需\; O(n) \; \\ \therefore 總共的時間複雜度為\; O(n \log n)\) 1542088930143 圖一 1542089353231 圖二 Recursive merge sort（Two way merge） 採用「Devide and conquer」的技巧 步驟： 一律切割成兩等分之「子串列」（Sublist） O( 1 ) 左右子串列各自作「Merge sort」，算出左右之「順串」 \(2 \times T(\frac n2)\) 對左右順串作「Merge」 O( n ) 「Quicksort」相比 「Mergesort」把時間（O(n)）花在合併的階段 「Quicksort」把時間（O(n)）花在分割階段 1542090860348 Algorithm 123456789101112131415161718192021222324252627282930313233343536// A[l....m]: 子陣列「順串一」// A[m+1..n]: 子陣列「順串二」Merge(A[], l, m, n) &#123; int p = l, q = m+1; int tmp[n-l+1]; // 暫存陣列 [1..(n-l+1)] int i = 1; // 當 run1 與 run2 皆未掃描完 while(p &lt;= m &amp;&amp; q &lt;= n) &#123; if(A[p] &lt;= A[q]) &#123; tmp[i++] = A[p++]; &#125; else &#123; tmp[i++] = A[q++]; &#125; &#125; // run1 未掃描完 while(p &lt;= m) &#123; tmp[i++] = A[p++]; &#125; // run2 未掃描完 while(q &lt;= n) &#123; tmp[i++] = A[q++]; &#125; copy(A[l..n], tmp[1..(n-l+1)]);&#125;// 對 A[L]~A[R] 排序Mergesort(A[], L, R) &#123; if(L &lt; R) &#123; m = (l+u)/2; Mergesort(A, L , m); Mergesort(A, m+1, R); Merge(A, L, m, R); &#125;&#125; Time complexity Best / Worst / Avg.：O( nlogn ) \(\because T(n) = 2\times T(\frac n2) + cn \Rightarrow T(n) = O(n\log n)\) Space complexity O( n ) 在作「Merge」的時候為了暫存合併的結果 空間占用大小等於資料量（n） 空間需求高 Stable 因為在作「Merge」時，if(A[p]&lt;=A[q]).. 會讓左順串與右順串在有兩個同樣大小的值時，左順串優先進入新的順串之中 [輔助結構] Selection tree 如果在「Mergesort」中一次合併多個順串（k 個順串），稱之為「K-way mergesort」 Example 4-way merge 1542091456582 每次要對 k 個順串作合併時 資料總量為 n 每次從 k 個順串中找到最小的值必須花 k-1 次比較 最多要歷經 n-1 個回合 作一次「k-way merge」之時間複雜度為 O(n×k) 減少比較的次數 以資料結構輔佐 「Winner tree」、「Loser tree」 在實現上多採用「Loser tree」 Winner tree Example 8-way merge with winner tree 1542091906501 1542092026110 1542092171261 1542092353259 1542092514867 （重複動作直到「新順串」建立完） Time complexity（假設為「k-way merge」、總資料數為 n） 建立「Winner tree」：O( k ) 分別從 k 個順串中複製出最小值作為「Winner tree」的葉節點 O( k ) 在「Winner tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」 O( k ) 輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k ) 決定根節點（最小值） 假設 \(l\) 為葉節點數量 「Winner tree」之葉節點為\(l = k = 8\) 「Winner tree」樹高 h 為 \(O(\lceil\log l\rceil+1)\) 決定根節點需要歷經 \(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\) \(O(\log k)\) 輸出根節點：O( 1 ) 被輸出之順串下一筆資料遞補：O( 1 ) 總體時間複雜度 O(k) + O( nlogk ) = O( nlogk ) Loser tree Example 8-way merge with loser tree 1542093764103 1542093996385 （執行直到「新順串」建立完成） Time complexity （假設為「k-way merge」、總資料數為 n） 建立「Loser tree」：O( k ) 分別從 k 個順串中複製出最小值作為「Loser tree」的「葉節點」：O( k ) 在「Loser tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」：O( k ) 輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k ) 決定根節點（最小值） 假設 \(l\) 為葉節點數量 「Winner tree」之葉節點為\(l = k = 8\) 「Winner tree」樹高 h 為 \(O(\lceil\log l\rceil+1)\) 決定根節點需要歷經 \(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\) \(O(\log k)\) 輸出根節點：O( 1 ) 被輸出之順串下一筆資料遞補：O( 1 ) 總體時間複雜度 O(k) + O( nlogk ) = O( nlogk ) 「External merge sort」 排序資料：n 「K-way merging on m runs」 使用「Selection tree」其時間複雜度 O( n lg m ) 1542095449837 假設 m 個順串被 k-way 分成了兩堆 由「Selection tree」得知 作「k-way merge」之時間複雜度 \(O( \frac n2 \times \lg k )\) 因為有兩堆所以「Merge」總共需要 O( n lg k ) 推廣後無論分幾堆作「Merge」之時間複雜度 O( n lg k ) 因為『回合數 = 樹高 - 1』（見下圖），在「Sorting」時需要執行 \(\lceil log_km \rceil\) 回合 1542097917874 Time complexity 以樹的觀點 Degree = k Number of leaves = m \(\Rightarrow k^{h-1} = m \\ \Rightarrow h = \lceil\log_k m\rceil +1\\ 回合數 = h -1 = O(\log_k m)\) 總共時間複雜度 \(O((n \cdot \lg k) \times \log_k m) \\ = O(n \cdot \frac{\log k}{\log 2}\cdot\frac{\log m}{\log k})\\ = O(n\cdot\lg m)\) Heap sort 步驟： 先將 n 筆資料建構成「Max heap」 Time complexity：O(n) 執行「Del-max」並將取出資料放置於陣列最後端資料被移除處（見「Binary heap」之刪除節點） 動作（2）重複 n-1 回合 Example 排序：5 3 8 2 6 9 1 4 10 7 1542105475686 1542105714121 1542105818821 1542105935299 （重複動作） 1542106039971 Algorithm 12345678910111213141516171819202122232425262728293031323334// tree: Array[1..n]// n : 元素個數// i : 節點編號 (調整以 i 為樹根之子樹)Heapify(tree, i, n) &#123; x = tree[i]; j = 2 * i //左子 while(j &lt;= n) &#123; if(j &lt; n) // 具有右子 if(tree[j]&lt;tree[j+1]) j = j+1; if(x &gt;= tree[j]) // 已經為 heap break; else &#123; tree[j/2] = tree[j]; j = 2 * j; &#125; &#125; tree[j/2] = x; // 將資料 x 置於正確位置&#125;// tree[]: 目標排序資料// n: 排序資料數量Heapsort(tree[], n) &#123; // Build heap for(int i = n/2; i&gt;=1; i--) &#123; heapify(tree, i, n); &#125; // 執行 n-1 回合之 heap sorting for(int i = n-1; i&gt;= 1; i--) &#123; swap(tree[1], tree[i+1]); heapify(tree, 1, i); &#125;&#125; Time complexity Best case / Worst case / Avg. case = O(n log n) Build heap：O( n ) 執行 n-1 回合「Del max」：O ( n log n ) Space complexity O(1) Example 排序： 5 5* 1 1542106445237 Unstable Linear time sorting method 不採用「Comparison based」技巧之排序手法 在探討線性時間複雜度之排序技術前，要知道這類排序都要有一個前提，資料值域必須有範圍限制，才能將排序降低為線性時間 Example：當排序資料只有 0 與 1 兩種類型資料時，最快的排序方法 「Counting sort」、「Radix sort」 Example：當資料只有 -1、0、1 三種資料做排序，最快的排序方法 「Counting sort」、「Radix sort」 Radix sort 基數排序法 ( Data structure 書上版本 ) 又稱為「Bucket sort」，採取「Distribution and merge」之技巧 書本名詞差異 [DS 版]（Radix = Bucket） [Algorithm 版] LSD radix sort Radix sort MSD radix sort Bucket sort LSD radix sort（Least significant digital） 步驟： 令 r 為基底（Base） 準備 r 個「Bucket」編號為 0 ~ (r-1) 令 d 為「Input data」中所有值以 r 為基底之最大位數個數：O( n ) 之後在執行排序時只需要 d 回合即可完成 由最低位元至最高位元執行： 分派（Distribution） 依各個資料之該位元分派到對應的「Bucket」 合併（Merge） 將所有「Bucket」由小到大（0 ~ (r-1)）合併 Example（基底為 10；十進位） 排序：329、457、657、839、436、720、355 1542447949542 Time complexity 作 d 回合 \(\left\{\begin{matrix} 分派：O(n) \\ 合併：O(r) \end{matrix}\right. \\ \Rightarrow 一回合需要\; O(n+r) \\ \Rightarrow 總共時間複雜度：O( d \times (n+r) )\) 為「Linear time」：r 可以視為常數 c1 ，而因為值域受到限制，所以 d 為固定值亦為常數 c2 O(c2 × (n+c1)) = O( c2 × n + c2 × c1 ) = O( n ) Space complexity 額外空間需求為「Bucket space」，而有 r 個大小為 n 的「Bucket」：O( r × n ) Stable MSD radix sort（Most significant digital） 步驟： 令 r 為基底（Base） ，準備 r 個「Bucket」編號為 0 ~ (r-1) 依照「最高位元」的數值分派資料至「Bucket」中 每個「Bucket」內各自排序 由小到大合併所有「Bucket」 「LSD radix sort」最大的區別 「MSD radix sort」 作「分派」與「合併」各一次 若「資料位數很大」或「基底很小」時 建議採用「MSD radix sort」 Bucket sort（Algorithm 書上版本） 步驟： 將資料轉化成「純小數」 以各個純小數之小數後第一位值有序的插入「Bucket」中 由小到大合併所有「Bucket」 12345678910// Pseudo codeArray bucket-sort(array, n) &#123; Array buckets[n]; for i = 0 to (length(array)-1) &#123; buckets[msbits(array[i], k)].insert(array[i]); &#125; for i = 0 to n - 1 next-sort(buckets[i]); return concatenation(buckets[0], ..., buckets[n-1]);&#125; 在實作裡，可用每個桶內部用連結串列表示，在資料入桶的同時插入排序，然後把各個桶中的資料合併 Example 排序：179、208、306、93、859、984、55、9、271、33 1542448961965 Counting sort 假設 n 為欲排序資料之總數，且該資料範圍介於 1 ~ k 之間 步驟 統計各個鍵值出現次數，並記錄在 count[1…k] 之中 利用 count[1…k] 求出各個鍵值未來排序時之起始位置，紀錄在 start[1…k] 中 依據 start[1…k] 之指示，將「Input array」置入「Output array」中對應的位置 Algorithm 123456789101112131415161718192021222324252627282930// A: 欲排序陣列// n: 資料個數// k: 值域範圍Countingsort(A[], n, k) &#123; new count[1...k]; new start[1...k]; new output[1...n]; for(int i = 1; i &lt;= k; i++) &#123; // Time complexity: O(k) count[i] = 0; &#125; // 步驟一：統計鍵值出現個數 for(int i = 1; i &lt;= n; i++) &#123; // Time complexity: O(n) count[A[i]]++; &#125; // 步驟二：計算每個鍵值排序時之起點位置 start[1] = 1; for(int i = 2; i &lt;= k; i++) &#123; // Time complexity: O(k) start[i] = start[i-1]+count[i-1]; &#125; // 步驟三：依照指示放置資料 for(int i = 1; i &lt;= n; i++) &#123; // Time complexity: O(n) // 先使用 start[A[i]] 原本資料後， // 將 start[A[i]]+=1 output[start[A[i]]++] = A[i]; &#125;&#125; Time complexity O(k) + O(n) +O(k) + O(n) = O(n+k) 探討為何 O(k)+O(n)+O(k)+O(n) 為線性時間複雜度 觀點一 若鍵值值域之範圍變化是 O(n) 此處的 O(n) 為資料範圍 意旨「Input array」中每一個元素在資料範圍中均勻分布 此觀點來看時間複雜度為 O(n+k) =&gt; O(n+O(n)) =&gt; O(n) 觀點二 若「Input array」之值域受到限制 k 可以視為一個常數 O(n+k) = O(n) Space complexity count[1...k]、start[1...k]、output[1...n]，O(n+k) Stable Counting sort 問題與探討 延續上面探討時間複雜度之觀點一，已知「Counting sort」之時間複雜度為 O(n+k)，若資料範圍 k 為線性等級 O(k) ，則整理排序時間複雜度為 O(n) 倘若資料範圍 k 為平方等級 O(\(n^2\)) 意旨「Input array」中的元素在資料範圍超出原本「Counting sort」可執行排序的資料範圍 必須探討其時間複雜度之變化 O(n + O(\(n^2\))) Example（用例子解釋） 一「Counting sort」只能對值域 0 ~ 9 的資料集合（O(n)）作排序 要如何對一個值域為 0 ~ 99 （O(\(n^2\))）的資料集合作排序？ 以「基數排序法」的想法為基礎，則可以在兩回合中將排序完成 對每個鍵值作「mod n」 n 為「Counting sort」能夠排序的範圍，亦可以視為「基底」 取其作為排序鍵值，對每個資料以新排序鍵值作「Counting sort」 將結果以類似「『Radix sort』每回合最後之合併動作」收尾 因為值域介於 0 ~ (n-1) 之間 第一回合使用「Counting sort」的排序時間複雜度為 O(n) 以第一回合之「Output array」作為「Input array」 對每個鍵值作「÷ n」再作「mod n」取其作為排序鍵值 對每個資料以新排序鍵值作「Counting sort」 將結果以類似「『Radix sort』每回合最後之合併動作」收尾 採用「基數排序法」作為基礎 每回合的排序必須是「Stable」才能正確排序 「Counting sort」為「Stable」 排序執行成功， 第二回合之時間複雜度為 O(n) 總時間複雜度為 2 × O(n) = O(n) ，仍為線性時間複雜度 若資料範圍為 O(\(n^3\)) 則依照上述想法， 三回合即可排序完成 第一回合的排序鍵值為 $原本鍵值i ;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)） 第一回合的排序鍵值為 $;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)） 第一回合的排序鍵值為 \(\lceil\frac{原本鍵值i}{n^2}\rceil \;％ \;n ​\) 作為「Counting sort」排序鍵值（時間複雜度為 O(n)） 當資料範圍為 \(O(n^4)、O(n^5)\) 亦可以以此類推]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Search</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Advance heap]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F31%2FData-structure-Advance-heap%2F</url>
    <content type="text"><![CDATA[Binary heap Build heap Top down 依序插入所有資料逐步建立「Heap」 Time complexity for heap insertion：log n Time complexity 若要建立一個 n 筆資料之「Heap」 \(\sum_{i = 1}^n \log i = \log(n!) = n\log n\) \(\Theta(n\log n)\) Buttum up 將 n 個輸入資料先以「Complete binary tree」( 陣列 ) 放置好 從最後一個父節點 (A[i]) 開始，往回執行 ( A[i-1], A[i-2] … ) 對各個父節點，調整子樹成為「Heap」，直到 A[1] 為止 buildheap Time complexity 因為是一個「Complete binary tree」( 完全二元樹 )，所以樹高為 \(\lceil \log (n+1) \rceil\) 討論 buildheap_2 若父節點位於「Level i」調整其子樹成為「Heap」之最大成本為 K-i 而第 i 層最多有 \(2^{i-1}\) 個子樹需要調整，則最大總成本為 \(\sum_{i=1}^k 2^{i-1}\times (K-i) = \sum_{i=1}^{k-1} 2^{i-1}\times (K-i)\) \[ S = 2^0 \cdot (k-1) + 2^1 \cdot (k-2) + \ldots + 2^{k-2} \cdot (k-(k-1)) + 2^{k-1}\cdot (k-k) \\ = 2^0 \cdot (k-1) + 2^1 \cdot (k-2) + \ldots + 2^{k-2} \cdot 1 ...........(1)\\ \Rightarrow 2S = 2^1 \cdot (k-1) + 2^2 \cdot (k-2) + \ldots + 2^{k-1} \cdot 1.........(2) \\ 2S-S = -2^0\cdot(k-1) + 2 + 2^2 + \ldots + 2^{k-2} + 2^{k-1} \\ \Rightarrow S = -(k-1) + 2\cdot(\frac{2^{k-1}-1}{2-1}) = -k+1+2^k - 2 = 2^k-k-1 \\ = 2^{\lg n} - \lg n -1 = n - \lg n-1 \\ \Rightarrow \Theta(n) \] Algorithm ( Heapify ) Max-heap 12345678910111213141516171819// tree: Array[1..n]// n : 元素個數// i : 節點編號 (調整以 i 為樹根之子樹)Heapify(tree, i, n) &#123; x = tree[i]; j = 2 * i //左子 while(j &lt;= n) &#123; if(j &lt; n) // 具有右子 if(tree[j]&lt;tree[j+1]) j = j+1; if(x &gt;= tree[j]) // 已經為 heap break; else &#123; tree[j/2] = tree[j]; j = 2 * j; &#125; &#125; tree[j/2] = x; // 將資料 x 置於正確位置&#125; Build 12345Build(tree, n) &#123; for(i = n/2; i&gt;= 1; i--) &#123; // i = n/2 為最後一個父節點 Heapify(tree, i, n); &#125;&#125; Example ( Delete max ) Time complexity：O(log n) 12345// ...x = tree[1];tree[1] = tree[n];n--;heapify(tree, 1, n); Example ( Merge heap ) Time complexity：O(n) 12345678// H1:[1..n]// H2:[1..m]Heap H3[1..m+n];copy(H3[1..n], H1); // O(n)copy(H3[n+1..m], H2); // O(n)Build(H3, m+n); // O(n) Double ended priority queue 時間複雜度特性 Insert：O(log n) Del_min：O(log n) Del_max：O(log n) Min-max heap Complete tree 每層由「Min-level」與「Max-level」交互合併 樹根位於「Min-level」 Min-level 位於此層之節點在該子樹中有「最小值」 Max-level 位於此層之節點在該子樹中有「最大值」 minmaxheap Minimum value = 樹根節點 Maximum value = max｛樹根節點之左右子節點｝ Insert node in min-max heap 步驟： x 先置於最後一個節點之下一個位置 ( n = Min-max heap.size + 1 ) 令 p 為「 x 的父節點」 12345678910111213141516// case1 "p": 位於「Min-level」if(x &lt; H[p]) &#123; H[n] = H[p]; // 父節點下移 // verifyMin( binary_heap, position, value ) verifyMin(H, p, x); // 往祖父點測試有無違反「Min-level」性質&#125; else &#123; verifyMax(H, n, x); // 往祖父點測試有無違反「Max-level」性質&#125;// case2 "p": 位於「Max-level」if(x &gt; H[p]) &#123; H[n] = H[p]; // 父節點下移 // verifyMax( binary_heap, position, value ) verifyMax(H, p, x); // 往祖父點測試有無違反「Max-level」性質&#125; else &#123; verifyMin(H, n, x); // 往祖父點測試有無違反「Min-level」性質&#125; Time complexity Step 1：O(1) Step 2：O(1) + O(\(\frac{\lg n}{2}\)) (Verify) = O(lg n) Delete-min in min-max heap 步驟： 移出樹根資料 將最後一節點先暫存於 x 後刪除 x 插入樹根 123456789101112131415161718192021222324252627282930313233343536373839404142// H: Heap// n: Heap 大小// r: 目前子樹樹根編號// x: 重新插入值Del_reinsert(H, n, r, x) &#123; // case 1 if(r*2 &gt; n) &#123; // 檢查子樹樹根有無左子節點，若無則無子節點 H[r] = x; // case 2 &#125; else if (n*4 &gt; n) &#123; // 樹根無孫節點，所以此樹最小值可能落在樹根之子節點中 int k = r*2; if(H[k] &gt; H[k+1]) k++; if(x &lt; H[k]) &#123; // 此樹最小值在子樹樹根子節點中 H[r] = x; &#125; else &#123; H[r] = H[k]; H[k] = r; &#125; // case 3 &#125; else &#123; int k; int j = r*4; int min = oo; for(int i = j; i &lt;= j+4 &amp;&amp; i&lt;= n; i++) &#123; if(H[i] &lt; min) &#123; k = i; min = H[i]; &#125; &#125; int p = k/2; // p 為 k 之父節點 // k 必位於「Min-level」 if(H[k] &lt; x) &#123; // 此樹最小值在子樹樹根孫節點中 H[r] = H[k]; if(x &gt; H[p]) Swap(x, H[p]); // !! Del_reinsert(H, n, k, x); // "x"插入原本 k 所在之位置 &#125; else &#123; H[r] = x; &#125; &#125;&#125; 123456Del_min (H, n) &#123; swap(H[1], H[n]); re = H[n]; n--; Del_reinsert(H, n, 1, H[1]);&#125; Example (Delete 3 times) delminmaxheap_1 1 st deletion delminmaxheap_2 delminmaxheap_3 Seep 3 ↓ delminmaxheap_4 delminmaxheap_5 2nd delition delminmaxheap_6 delminmaxheap_7 delminmaxheap_8 delminmaxheap_9 3rd delietion delminmaxheap_10 delminmaxheap_11 delminmaxheap_12 Delete-max delminmaxheap_1 delminmaxheap_13 delminmaxheap_14 delminmaxheap_15 Double-ended heap (DEAP) Complete binary tree 樹根不賦值 樹根左子樹為「Min heap」 樹根右子樹為「Max heap」 deapnodemap 「Min heap」與「Max heap」對應編號 令 i 為在「Min-heap」中某一節點之編號，則 j 為「i 在 Max-heap 中對應」之節點編號 \(j = i + 上一層之最多節點數量 \\ = i + 2^{(目前節點之「Level」-1)-1} \\ = i + 2^{\lceil\lg (i+1)\rceil-2}\) 如果該節點 j 不存在 ( j &gt; n )，則 j = \([\frac i2 ]\) Insert data in deap 步驟： x 先置於最後一個節點之下一個位置 ( n = Deap.size + 1 ) 檢查 （1）若 x 目前位於「Min-heap」( 位置假設為 i )，則 j 為 x 在「Max-heap」對應之節點編號 12345678if(x &gt; deap[j]) &#123; deap[i] = deap[j]; //max_heap_insert(陣列, 陣列位置, 資料); max_heap_insert(deap, j, x); // 將 x 與該父節點比較並調整&#125; else &#123; //min_heap_insert(陣列, 陣列位置, 資料); min_heap_insert(deap, i, x); // 將 x 與該父節點比較並調整&#125; （2）若 x 目前位於「Max-heap」( 位置假設為 j )，則 i 為 x 在「Min-heap」對應之節點編號 12345678if(x &lt; deap[i]) &#123; deap[i] = deap[j]; //min_heap_insert(陣列, 陣列位置, 資料); min_heap_insert(deap, i, x); // 將 x 與該父節點比較並調整&#125; else &#123; //max_heap_insert(陣列, 陣列位置, 資料); max_heap_insert(deap, j, x); // 將 x 與該父節點比較並調整&#125; Delete data in deap 步驟： 將左子樹樹根資料移出 將最後一節點刪除並該資料先由 x 暫存 左子樹樹根之空缺，由其左右子節點中最小遞補之，由上而下直到某「葉節點」產生空缺 對該空缺作「Insert data in deap」 deap Example deldeap_1 deldeap_2 deldeap_3 deldeap_4 deldeap_5 Symmetric min-max heap (SMMH) Complete binary tree 樹根不賦值 條件一 ( \(P_1\) )：左兄弟 ≦ 右兄弟 條件二 ( \(P_2\) )：若該節點 x 有祖父節點則「祖父節點之左子節點鍵值」 ≦ x 條件三 ( \(P_3\) )：若該節點 x 有祖父節點則「祖父節點之右子節點鍵值」 ≧ x 針對下方全部綠色節點，全部鍵值都比 2 大，都比 80 小 SMMH 由上方性質可以反映出 「以節點邊號 i 為樹根之子樹中，其子孫最小值為左子節點，其子孫最大值為右子節點」 Insert data in SMMH 步驟： x 先置於最後一個節點之下一個位置 ( n = SMMH.size + 1 ) 檢查「條件一」是否滿足，若違反「左右兄弟節點互換」 檢查「條件二」、「條件三」是否滿足，若違反其中一者則調整之 Delete min in SMMH 步驟： 移出左子樹根之資料 刪除最後一個節點並將值暫存於 x x 暫置於左子樹根之空缺 檢查「條件一」是否滿足，若違反「左右兄弟節點互換」 檢查「條件二」是否滿足，若違反則調整之 重複步驟四、五直到完全符合條件 Example SMMH_2 delSMMH_1 在藍色中選出一個最小值 delSMMH_2 delSMMH_3 delSMMH_4 delSMMH_5 delSMMH_6 Leftist heap Min-heap Leftist heap Insert data O(log n) O(log n) Delete min O(log n) O(log n) Merge heap O(n)：build heap O(log n) Leftist tree (Minimum leftist tree) Shortest：到任一個外部節點之最短路徑長 令 x 為「Extended binary tree」中某個節點，則 Shortest(x) = \(\left\{\begin{matrix} 0 &amp;, x 為「外部節點」 \\ 1 + min｛Shortest(x\rightarrow Lchild), Shortest(x\rightarrow Rchild)｝ &amp; , 其他 \end{matrix}\right.\) Leftist tree 針對任何一個內部節點 x，其 Shortest(x→Lchild) ≧ Shortest(x→Rchild) Leftist heap 本身也為一棵「Leftist tree」且為一棵「Min-tree」( 父節點值 ≦ 子節點值 ) Merge leftist heap (\(H_1, H_2\)) 步驟： 比較 \(H_1\) 與 \(H_2\) 之根節點值，找出最小值。( 假設 \(H_1\) 之根節點比較小 ) 以 \(H_1\) 之根節點作為新樹之根節點，該新樹保留 \(H_1\) 之左子樹 Merge( \(H_1\) 之右子樹, \(H_2\) ) 成為新樹之右子樹 (遞迴) 檢查所有節點是否符合「Leftist tree」之性質，若不滿足則作「Swap」 Example leftisttreemerge_1 leftisttreemerge_2 leftisttreemerge_3 Delete-min in leftist heap 步驟： 刪除根節點並輸出，斷開鏈結後得兩子樹 \(H_1, H_2\) Merge(\(H_1, H_2\)) Insert data in leftist heap 步驟： 插入節點自成為一個「Leftist heap」\(H_2\)，令被插入之「Leftist heap」為 \(H_1\) Merge(\(H_1, H_2\)) Binominal heap Binominal tree 令樹高從 0 開始 高度為 0 的「Binominal tree」記為 \(B_0\)，只有樹根一個節點 高度為 k 的「Binaminal tree」 記為 \(B_k\)，由兩棵 \(B_{k-1}\) 組成 (任挑其中一點作為樹根) \(B_k\) 中「i-th level」之節點為 \(\binom{k}{i}\) \(B_k\) 之節點總數為 \(2^k\) Binominal heap 是由 ≧ 0 棵「Binominal tree」所組成之集合 ( 森林 ) 且每棵樹也為「Min-tree」 「Binominal heap」有 13 筆資料( 節點 )，則由 3 個「Binomal tree」組成 若總結點數量 n = \(2^k\) 「Binominal heap」只有一棵「Binominal tree」 若總結點數量 n = \(2^k-1\) 有 k 棵「Binominal tree」 k = lg ( n+1 ) Merge binominal heap 步驟： 將具有相同高度之「Binominal tree」合併成一棵新的「Binominal tree」 合併直到此集合中無相同高度之「Binominal 」 leftistheapmerge_1 leftistheapmerge_2 合併兩棵樹花費 O(1)，最多大約 lg n 棵樹合併 ( O(lg n) ) 上述之合併方法稱為「勤勞合併」( Hard-working merge ) 另一種合併方法為「偷懶合併」( Lazy merge ) 相同高度不合併，純粹串接在同一集合中( O(1) ) Delete-min in binominal heap 步驟： 從各個樹根找出最小值，令存在最小值數根之樹為 T，其餘樹之集合稱為 \(H_1\) （Binominal heap） 刪 T 的樹根會生成子樹，稱之為 \(H_2\) Merge(\(H_1, H_2\)) 在所有樹根找最小值，因為最多才 lg (n+1) 棵樹，所以尋找最小值只需 O( log n ) 即可 在作「Delete-min」時，必採取「勤勞合併」 Insert data in binominal heap (\(H_1\)) 步驟： 插入之資料 x，自己成為一個「Binominal heap」( \(H_2\) ) Merge( \(H_1, H_2\) ) Example (Amotize 計算) 給 1, 2, 3, 4, 5, 6, 7 以建立「Binominal heap」 insertbinominalheap_1 insertbinominalheap_2 insertbinominalheap_3 大部分插入的時間為 O( 1 ) 少部分插入的時間為 O( lg n ) 當 n = \(2^k -1\) 增加一個節點變成 \(2^k\)，有 k 棵樹要合併成一棵 Amotized cost：O( 1 ) Binominal heap ( 不同版本 ) datastructurebinominalheap 著重於「Data structure」之表示 Fibonacci heap [Corman] Fibonacci heap 也是用上述相同的資料結構 Fibonacci heap Algorithm wiss版本 Data structure 版本 Insert data O(1)：Amotized O(1)：Amotized Delete min O( log n )：採勤勞合併 O( log n )：採勤勞合併 Merge O( log n )：採勤勞合併 O( 1 )：採偷懶合併 Find-min O( log n )：有 log n 個樹根 O( 1 )：採用「Min」指標 Fibonacci heap - Data structure 為「Extended binominal heap」亦為「Binominal heap」之「Supperset」；除了「Binominal heap」之「Insert data」、「Merge」、「Delete min」，另外有： Delete x (任意刪除資料)：O( log n ) 考慮刪除資料恰為「Min-data」 Decrease key of a node (減少某點之鍵值)：O(1) 採用「Amotized cost」 應用於圖論中，如「Minimum spanning tree」之「Kruskal、Prim 演算法」 Delete x in fibonacci heap delfibonacciheap Example 刪除節點 12 刪除該節點後，其兩棵子樹獨立，成為樹根之間之「Sibling」，並且遇到相同高度「Binominal tree」時不合併 ( 偷懶合併法 ) delfibonacciheap_2 Decrease key in fibonacci heap delfibonacciheap 針對節點（1）減少 1：（1）→（0），其餘不動 O( 1 ) 針對節點（3）減少 1：（3）→（2），其餘不動 O( 1 ) 針對節點（3）減少 3：（3）→（0），其餘不動 需要改變「Min」指標 O( 2 ) 針對節點（15）減少 1：（15）→（14） （14）&gt; （12）：不用更動 O( 1 ) 針對節點（15）減少 4：（15）→（11） （11）&lt; （12）：該子樹獨立 O( 1 )，成為樹根之間之「Sibling」並檢查是否比「Min」還小 decreasekeyfibonacciheap_1 decreasekeyfibonacciheap_2 Operation Binary heap (worst cast) Fibonacci heap (amotized) Make empty heap \(\Theta(1)\) \(\Theta(1)\) Insert x \(\Theta(\log n)\) \(\Theta(1)\) Extract min \(\Theta(\log n)\) O( log n ) Union (Merge) \(\Theta(n)\)：Build heap \(\Theta(1)\)：偷懶合併 Decrease key \(\Theta(\log n)\) \(\Theta(1)\) Delete x \(\Theta(\log n)\)：視為子 heap 中 Del-min O(log n) Find min \(\Theta(1)\)：樹根 \(\Theta(1)\)：採「Min pointer」 Decrease key in binary heap ( \(\Theta(\log n)\) ) decreasekeyinbinaryheap （參考：Re: ［理工］ 106交大資演9 - 看板Grad-ProbAsk - 批踢踢實業坊） 「Fibonacci Heap」 DS 與 Algorithm 版實作一樣 「Worst case time/amortized time」皆一致 「Binomial Heap」 DS 和 Algorithm 對於 Merge/Insert 的實作不一樣 DS 版本直接串接（Lazy Merge） Algorithm 版每次「Insert/Merge」要保證「Binomial Heap」中沒有同 Order 的 「Binomial Tree」（Hard-working merge） 時間複雜度整理 Binomial (Algorithm) Binomial (Algorithm) Lazy-Binomial (DS) Lazy-Binomial (DS) Fibonacci Fibonacci Operation Worst Amortized Worst Amortized Worst Amortized Make empty heap Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Insert x Θ(lg n) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Minimum Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Extract-min Θ(lg n) Θ(lg n) Θ(lg n) Θ(lg n) Θ(lg n) Θ(lg n) Union (Merge) Θ(lg n) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Decrease key Θ(lg n) O(lg n) Θ(lg n) O(lg n) Θ(n) Θ(1) Find min Θ(lg n) Θ(lg n) Θ(lg n) Θ(lg n) Θ(n) Θ(lg n) 「Minimum」 假設一個指標指向「Minimum element」 進行其他操作時指標必須進行相對應的更新 「Minimum」可以在 Θ(1) 完成 「Fibonacci Heap」一般都會維護這個指標 當「Binomial Heap」不維護這個指標時 「Minimum」之「Worst/amortized」為 Θ(lg n) 「Extract-min」 課本上一般證明為 O(lg n) 但是不可能為 O(lg n)，因為如此一來只要靠 Insert/Extract-min 就可得到 O(n lg n) 排序 無論「Worst」或是「Amortized」都必須是 Θ(lg n) 「Delete」 依靠「Decrease-key」與「Extract-min」實作 時間複雜度為 Θ(「Decrease-key」+「Extract-min」) 「Fibonacci heap」的「Decrease-key」 「Worst case」： Θ(n) 可藉由一連串 Insert/Decrease-key/Delete 建構出一個「Fibonacci tree」並退化成一個串列，其全部的節點都已被標記（標記節點；用來標示一個非根節點已失去一個子節點，則不得再奪其子節點，可能需要進行其他特別操作） 對葉節點作 Decrease-key 時，必須要把所有串列上的點都「Cut」（分離成為一個獨立的「Fibonacci tree」），需要 Θ(n) 「Binomial heap」的「Insert/Union」 「Amortized time」：O(1) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.420.43 第六小節的第一段最後提到參考文獻 https://link.springer.com/chapter/10.1007%2F3-540-57568-5_242 Double-ended binomial queues, by C. M. Khoong and H. W. Leong 「Binomial heap」的「Decrease-key」 「Amortized time」：O(lg n) 找不到下限證明無法聲明其時間複雜度為 Θ(lg n) （猜測應該很多人都研究過，沒有辦法證明「Amortized time」為 O(lg n)，所以設計「Fibonacci Heap」）]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Advance binary search tree]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F28%2FData-structure-Advance-binary-search-tree%2F</url>
    <content type="text"><![CDATA[AVL tree Height balance binary search tree 性質 \(|H_L - H_R| \leq 1\)，其中 \(H_L、H_R\) 為樹根節點左右子樹之高度 左右子樹亦為「AVL tree」 Example (True or False) 若「Binary search tree」之樹根節點左右子樹皆為「AVL tree」則整棵樹為「AVL tree」(FALSE) 在「AVL tree」，任何節點在左右子樹必為「AVL tree」(TRUE) 在「AVL tree」，任何兩個葉節點位於的高度 (Level) 差必 ≦ 1 (FALSE)；如下圖 s、t 葉節點 AVLex_1 在「AVL tree」，左子樹所有節點之數必 ≦ 右子樹所有節點之數值 (TRUE) 在「AVL tree」中使用「Inorder travesal」可以得到「小→大」的排序 (TRUE) 調整原則 中間鍵值往上拉，小的置左大的置右 此三個節點是被標上 LL、LR、RL、RR 兩條邊所連結的三個節點 孤兒節點 (子樹) 依照「Binary serch tree」性質置入 LR AVL_LR_1 AVL_LR_2 RR AVL_RR_1 AVL_RR_2 從「AVL tree」中任取兩個葉節點，該高度差取絕對值小於等於一。( 任何大於等於 0 的整數都有可能 ) 從「AVL tree」中任取其根節點位於同層的兩子樹，其子樹的高度差取絕對值小於等於一。( 任何大於等於 0 的整數都有可能 ) AVLex_2 形成高度為 h 的 AVL tree 所需之最多節點數 = 「Full binary serach tree」數量 = \(2^h -1\) 形成高度為 h 的 AVL tree 所需之最少節點數 = \(F_{h+2} - 1\) ( F 為費氏數列 ) 證明 高度為 0 時為一空樹最少 0 個節點即可，\(F_{0+2}-1 = 1-1 = 0\) ，成立。 假設高度小於等於 h-1 時成立，考慮高度等於 h 時， 最少節點數必定發生在「樹根」之左右子樹高度相差一時， 不失一般性，令左子樹高度為 h-1；右子樹高度為 h-2， 所以左子樹最少節點個數為 \(F_{(h-1)+2}-1 = F_{h+1}-1\)； 右子樹最少節點個數為 \(F_{(h-2)+2}-1 = F_{h}-1\)。 整棵樹需要最少的節點數為 \(F_{h+1} -1 +F_{h} -1 + 1 = F_{h+2} - 1\) ，QED Example 形成高度為 5 的「AVL tree」最少需要的節點數？ \(F_{5+2}-1 = F_7 -1 = 12\) Example 300 個節點的 AVL tree 之最大高度為？ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 \(F_{13} -1 = 232 \\ \Rightarrow F_{13} = F_{11+2} \\ \Rightarrow h = 11\) 最小高度為？ \(2^h -1 = 300 \\ \Rightarrow h = \lceil \lg 301 \rceil = 9\) Example 令 N(H) 代表形成高度 H 之「AVL tree」之最小節點數 N(0) = 0、N(1) = 1 （1）寫出 N(H) 之遞迴定義 （2）延續（1），求出 N(5) 與 N(10) （1）：N(H) = N(H-1) + N(H-2) + 1，H ≧ 2； （2）：N(5) = 12，N(10) = 144 M-way search tree 主要應用在「External search (sort)」，資料量大於記憶體空間，必須藉由外部儲存體保存，再分批載入記憶體中搜尋欲求的資料 Example ( Height：h，m-way search tree ) （1）最多節點個數 （2）最多儲存資料數量 （1）：\(m^0 + m^1 + m^2 + \ldots + m^{h-2} + m^{h-1} = \frac{m^h-1}{m-1}\) （2）：\(\frac{m^h-1}{m-1} \cdot (m-1) = m^h -1\) B-tree of order m (Balance) 樹根節點至少有 ≧ 2 個子節點，即 m ≧ 根節點 Degree ≧ 2 除了樹根節點與失敗節點( Failure node；External node ) 之外，其餘的節點 \(\lceil \frac m2 \rceil \leq Degree \leq m\) 或 \(\lceil \frac m2 -1 \rceil \leq 節點內的資料數量 \leq m-1\) 所有的失敗節點皆必須位於同一層 ( Level ) mwaybtree 從上一層讀取至下一層需要多一次 Block I/O B tree of order 3 樹根節點：2 ≦ Degree ≦ 3 除失敗節點之其餘節點：\(\lceil \frac 32 \rceil = 2\) ≦ Degree ≦ 3 此樹中樹根節點恰巧與其餘節點 Degree 的特性相同，所以只會出現兩種節點 2 - node：Degree 為 2 3 - node：Degree 為 3 所以又稱此樹為「2-3 tree」 B tree of order 4 樹根節點：2 ≦ Degree ≦ 4 除失敗節點之其餘節點：\(\lceil \frac 42 \rceil = 2\) ≦ Degree ≦ 4 此樹中樹根節點恰巧與其餘節點 Degree 的特性相同，所以只會出現三種節點 2 - node：Degree 為 2 3 - node：Degree 為 3 4 - node：Degree 為 4 所以又稱此樹為「2-3-4 tree」 B tree of order 5 樹根節點：2 ≦ Degree ≦ 5 除失敗節點之其餘節點：\(\lceil \frac 52 \rceil = 3\) ≦ Degree ≦ 5 此樹中樹根節點與其餘節點 Degree 的特性不同 在固定高度之下： 最多節點數 \(m^0 + m^1 + \ldots + m^{h-1} = \frac{m^h-1}{m-1}\) 最多資料儲存量 因為每一節點都會有 m-1 筆資料，所以將最多節點數乘每節點最多 可儲存量 \(\frac{m^h-1}{m-1} \times (m-1) = m^h -1\) 最少節點數 樹根節點最少要有兩個子節點 其餘節點最少要有 \(\lceil \frac m2 \rceil\) 個子節點 則 \(1 + 2 + 2\cdot \lceil \frac m2 \rceil + 2\cdot \lceil \frac m2 \rceil^2 + \ldots + 2\cdot \lceil \frac m2 \rceil^{h-2} \\ = 1 + 2\cdot[\lceil \frac m2 \rceil^0 + \lceil \frac m2 \rceil^1 + \ldots + \lceil \frac m2 \rceil^{h-2} ] \\ = 1 + 2\cdot [\frac {\lceil\frac m2 \rceil^{h-1}-1}{\lceil\frac m2\rceil -1}]\) 最少資料儲存量 根節點最少可以儲存 1 筆資料 每個節點最少可以儲存 $m2 -1 $ 筆資料 則 \(1 + 2\cdot [\frac {\lceil\frac m2 \rceil^{h-1}-1}{\lceil\frac m2\rceil -1}] \times (\lceil \frac m2\rceil-1) \\ = 1 + 2\cdot(\lceil\frac m2\rceil^{h-1}-1) \\ = 2\cdot\lceil\frac m2\rceil^{h-1}-1\) Insert data in B-tree 步驟： 先找尋資料 x 在樹中的置入位置 檢查該置入節點是否「Overflow」( 即資料數量等於 m ) 如果無「Overflow」，結束 如果「Overflow」針對該點「Split」，再針對該父點做第二步的檢查 Split 將節點內的第 \(\lceil \frac m2 \rceil\) 個資料上拉至父節點，其餘資料分裂成兩個子節點 mwaybtree_split 註解：B tree 不直接新增節點，而是等到整個資料樹的樹根節點「Overflow」才會新增節點。 Delete data in B-tree 步驟： 在樹中找尋 x 資料位於的節點 將節點分為「葉節點」與「非葉節點」 「葉節點」 將資料 x 移除 檢查節點是否「Underflow」( 資料數量 \(\geq \lceil\frac m2\rceil-1\) )； 若無「Underflow」結束； 若有「Underflow」檢查是否可以「Rotation」，可以則執行之並結束，若否則作「Combine」( Merge ) 並對父節點執行此步驟 ( 檢查節點是否「Underflow」 ) 「非葉節點」( 注意 ) 找出 x 之左子樹中的最大值 y ( 或右子樹中的最小值 ) y 必存在於某「葉節點」之中，以資料 y 取代資料 x 並移除 y ( 相當於刪除「葉節點」的一筆資料 ) Rotation mwaybtree_ratation Combine mwaybtree_combine 若父節點因此發生「Underflow」，則兩代 ( 父、子 ) 所有鍊節全部斷開，再針對父節點的「Underflow」逐層往上處理 mwaybtree_split_2 Example ( 刪除 Leaf 之資料 ) 2 - 3 Tree ( 2 ≦ Degree ≦ 3；1 ≦ 資料量 ≦ 2 )，刪除 5, 50, 8, 90 mwaybtree_deletion 刪除 5 後 mwaybtree_deletion_2 刪除 50 後 mwaybtree_deletion_3 刪除 8 後 mwaybtree_deletion_4 刪除 90 後 mwaybtree_deletion_5 Red black tree Balanced binary search tree 節點顏色非黑即紅 樹根節點必為黑節點 「Nil」節點也視為黑節點 紅節點其子節點必為黑節點 ( 任何路徑上不得出現連續紅節點 ) 樹根至任意不同之「葉節點」路徑皆具有相同數量的黑色節點 ( Balance ) rbtree 在紅黑樹中 最短路徑：全為黑色 ( 鏈結、節點 ) 之路徑 最長路徑：黑紅交錯 ( 鏈結、節點 ) 之路徑 「2-3-4 tree」高度 = \(\lceil \log(n+1)\rceil\) 全為「2－節點」：\(\lceil \log_2(n+1)\rceil\) ( 最小高度 ) 因為當「2-3-4 tree」全為「2－節點」時，所建出之紅黑樹會一樣高 ( 全部皆為黑色路徑 ) 全為「4－節點」：\(2 \cdot \lceil \log_2(n+1)\rceil\) (最大高度) 因為當「2-3-4 tree」全為「4－節點」時，所建出之紅黑樹會是兩倍高 ( 黑紅路徑交錯出現 ) Insert x in RB-tree (Top-down) 步驟： 先找尋 x 的插入位置 在找尋 x 的插入位置時，所經過得路徑上，若發現有節點具有兩個紅色子節點，使其「顏色交換 ( color change )」，再檢查有無違反「連續之紅色節點」，若有作「Rotation」侯進行下一步 (插入)，若無直接進行下一步 將插入之節點標為紅色後放置在該插入位置 檢查有無違反「連續之紅色節點」，若有作「Rotation」進行下一步，若無則直接進行下一步 如果需要，將樹根節點改為黑色節點 注意：第一步與第三步只會有一者發生 Rotation 分為 LL、LR、RL、RR ，與 AVL tree 旋轉相似，只是加上顏色變化：中間鍵值往上拉標黑，兩子點標紅 Rbrotation Delete x in RB-tree 目前不討論 The height of RB-tree 假設原始紅黑樹為 T 假設對於每個頂點 x 其頂點至葉節點之每個路徑的黑色節點數量為 BH(x) （Black node height） 其樹高為 H(x) 其中 H(x)、BH(x) 定義如下： theheightofrbtree ＜證明＞任何以 x 頂點為根的子樹 T’，其內部節點（在原本 T 的內部節點）至少有 \(2^{BH(x)}-1\) （對 H(x) 做數學歸納法推導） 當 H(x) 為 0 時，則可以知道其為 Nil 節點，則以該節點為子樹 T’必無存在內部節點（T 的內部節點） 因為 BH(x) = 0，則 \(2^0-1 = 1-1 = 0\)，無內部節點 考慮一個節點 x（黑節點），其樹高為 H(x) = k &gt; 0，則該點為 T 的一個內部節點 討論其節點的「兩個子節點」y 節點 y 至每個葉節點的黑色節點數量為\(\left\{\begin{matrix} BH(x),\;若\; y \;為紅色節點 \\ BH(x)-1,\;若\; y \;為黑色節點 \end{matrix}\right.\) 假設其「兩個子節點」 成立，則 y 到葉節點包含 T 的內部節點至少有 \(2^{BH(x)-1}-1\) 考慮以 x 節點為子樹 T’ ，其包含 T 的內部節點至少有 （左子點包含 T 的內部節點）+（右子點包含 T 的內部節點）+（x 本身就為 T 的內部節點） \((2^{BH(x)-1}-1)+(2^{BH(x)-1}-1)+1 = 2^{BH(x)}-1\)，命題得證 ＜證明＞一棵含有 n 個內部節點的紅黑樹 T 其樹高最多只有 \(2\cdot\lg(n+1)\) 假設 H 為 T 的樹高 根據紅黑樹的性質「紅色節點不能與另一個紅節點相連」 從根節點至葉節點（不包括根節點）的任何一條簡單路徑，至少有一半的節點為黑節點 所以從根節點至葉節點的 \(BH \geq \frac{H}{2}\) 再根據上述定理，\(n \geq 2^{BH}-1 \geq 2^{\frac{H}{2}}-1\) 則 \(2^\frac{H}{2} \leq n+1 \Rightarrow \frac{H}{2} \leq \lg(n+1) \Rightarrow H \leq 2\lg(n+1)\) Red black tree ( 不同定義 ) 為一棵被「2-3-4 tree」所對應之「Binary search tree」 「鏈結」非黑即紅 若該「鏈結」在原本「2-3-4 tree」就已經存在則視為黑色鏈結，否則視為紅色鏈結 任何路徑上不可連續出現紅色鏈結 樹根節點到不同葉節點的路徑上皆具有相同數量之黑色鏈結 2－結點 2-nodetorbtree 3－結點 3-nodetotbtree 3－結點轉換時會有兩種可能，所以轉換不唯一 4-nodetorbtree Optimal binary search tree (OBST) 給 n 個內部節點加權值：\(p_i\)，1 ≦ i ≦ n，與 n+1 個外部節點加權值：\(q_i\)，0 ≦ j ≦ n 在所有 \(\frac {1}{n+1}\binom{2n}{n}\) 不同種二元搜尋樹中，具有最小的搜尋總成本之二元搜尋樹 ( 不唯一 ) Search total cost = 成功搜尋成本 + 失敗搜尋成本 成功搜尋成本 = \(\sum^n_{i = 1} (內部節點_i \;之「Level」值\times p_i)\) 內部節點\(_i\) 之「Level」值：比較次數 失敗搜尋成本 = \(\sum^n_{j = 0} ((外部節點_j \;之「Level」值-1)\times q_i)\) 外部節點\(_j\) 之「Level」值 - 1：比較次數 orbtree 圖（1） 成功搜尋成本 = 1 × 0.5 + 2 × 0.1 + 3 × 0.05 = 0.85 失敗搜尋成本 = 1 × 0.15 + 2 × 0.1 + 3 × 0.05 + 3 × 0.05 = 0.65 總成本 = 0.85 + 0.65 = 1.5 圖（2） 成功搜尋成本 = 1 × 0.1 + 2 × 0.5 + 2 × 0.05 = 1.2 失敗搜尋成本 = 2 × ( 0.15 + 0.1 + 0.05 + 0.05 ) = 0.7 總成本 = 1.2 + 0.7 = 1.9 在有加權值之影響下，不見得高度越小，成本越小 建立 OBST Dynamic programming 三要件 定出針對該問題之遞迴公式 建立表格 利用表格 假設 \(a_{i+1}, a_{i+2}, \ldots, a_{j}\) 為內部節點，且 \(a_{i+1} &lt; a_{i+2} &lt; \ldots &lt; a_{j}\) 令內部節點加權值 = \(p_{i+1}, p_{i+2}, \ldots, p_{j}\)；外部節點加權值 = \(q_{i}, q_{i+1}, \ldots, q_{j}\) 定義 \(T_{i, j}\) 代表由 \(a_{i+1}, a_{i+2}, \ldots, a_{j}\) 所組成之「OBST」，且令 \(T_{i, i}\) 為空樹，而當 i &gt; j 時無定義 Example \(T_{2, 5}\)：\(a_3, a_4, a_5\) 所組成之 OBST \(T_{2, 3}\)：\(a_3\) 所組成之 OBST 定義 \(C_{i, j}\) 代表 \(T_{i, j}\) 的成本 \(r_{i, j}\) 代表 \(T_{i, j}\) 之樹根節點編號 \(w_{i, j}\) 代表 \(T_{i, j}\) 之內外部節點加權值和 若為空樹 \(C_{i, i} = 0 \\ r_{i, i} = nil \\ w_{i, i} = q_i\) 遞迴推導 在 \(a_{i+1}, a_{i+2}, \ldots, a_{j}\) 中任挑一個作為樹根 ( \(a_k\) ) OBST_1 則 L 子樹以 \(T_{i, k-1}\) 表示； R 子樹以 \(T_{k, j}\) 表示 \(C_{i, j} = 1\cdot p_k + c_{i, k-1} + c_{k, j} + w_{i, k-1} + w_{k, j} \\ = c_{i, k-1} + c_{k, j} + w_{i, j}\) OBST_2 在所有可能中挑出一個能使當前子樹成本最低之樹根 \[ C_{i, j} = w_{i, j} + min_{i+1 \leq k \leq j}｛C_{i, k-1}, C_{k, j}｝ \] 在 Comman 之演算法教科書中 失敗搜尋成本 = \(\sum^n_{j = 0} (外部節點_j \;之「Level」值\times q_i)\)，不用多扣除一次「搜尋次數」 所以，可以先依上述方式計算完後之總成本再加上多出來的成本，如下： \[ ［Comman］總成本 = ［上述算法］總成本 + \sum_{j = 0}^n q_j \] 特殊題型 若題目未給出外部節點之加權值，將外部節點加權值視為 0，再沿用原本作法計算 重新定義 \(T_{i, j}\) 為 \(a_{i} , a_{i+1} , \ldots , a_{j}\) 所組成之 OBST 內部節點之加權值為 \(p_{i}, p_{i+1}, \ldots, p_{j}\) \(C_{i, j}\) 為 \(T_{i, j}\) 之總成本 OBST_3 \[ C_{i, j} = 1\cdot p_k + C_{i, k-1} + C_{k+1, j} + w_{i, k-1} + w_{k+1, j} \\ = w_{i, j} + C_{i, k-1} + C_{k+1, j} \\ \Rightarrow C_{i, j} = w_{i, j} + min_{i\leq k \leq j}｛C_{i, k-1} + C_{k+1, j}｝ \] Splay tree AVL tree Splay tree 調整過程 複雜 簡單 實際最差行況 O(log n) O(n) 分攤成本 (Amortize) N/A O(log n) 正常的插入與刪除節點只是會需要加上「Splay」操作 Splay：將該起點旋轉至整棵樹樹根節點 Search (x)：x 為作「Splay」之起點 Insert (x)：x 為作「Splay」之起點 Delete (x)： x 之父節點為作「Splay」之起點 ( 若存在 )]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data structure - Tree]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F28%2FData-structure-Tree%2F</url>
    <content type="text"><![CDATA[Binary tree 節點數量計算 二元樹之第 i 階之節點個數為 \(2^{i-1}\)，i ≧ 1 在高度為 k 的二元樹，全部節點之個數為 \(2^k-1\)，k ≧ 1 對於任一非空二原樹 T ，如果令 Leaf 節點的個數為 \(n_0\)， 而 Degree 為 2 的節點的個數為 \(n_2\)，則 \(n_0 = n_2+1\) \[ 令\; n_1 代表 \;Degree\;為\; 1 \; 的節點個數，n\; 表示節點總數 \\ \Rightarrow n = n_0 + n_1 + n_2 ......(1)\\ 又因為只有\; Degree \; 為 \; 1、2 \;的節點才會有分支，令分支總數為 \;B \\ \Rightarrow B = n_1 + 2\cdot n_2 \\ 樹的總節點個數又為分支總數加 \;1 \\ \Rightarrow n = n_1 + 2\cdot n_2 + 1 ......(2)\\ By \;(1)、(2)\Rightarrow n_0 = n_2 + 1 \] Example 有一樹的 Degree 為 4 ，Non-leaf 必有 4 個子節點，若 Leaf 節點個數為 \(n_0\) ，求總結點數？ \[ 令\; n \;為樹的節點總數 \\ n = n_0 + (n_1 + n_2 + n_3) + n_4 \\ 而非葉節點必有四個子節點，所以 \;n_1、n_2、n_3\; 個數皆為零 \\ \Rightarrow n = n_0 + n_4 ......(1)\\ 令\; B \;為樹的總分支數量 \\ B = 4\cdot n_4 \\ 樹的總節點個數又為分支總樹加 \;1 \\ n = 4\cdot n_4 + 1 ......(2)\\ By \;(1)、(2) \Rightarrow n_4 = \frac {n_0 -1}{3} \\ \Rightarrow n = n_0 + \frac {n_0 -1}{3} = \frac {4\cdot n_0 -1}{3} \] Example Completed binary tree 有 1000 個節點 (邊號為 1 ~ 1000) 節點編號 747 之 Grandparent 為 \(\frac{\frac{747}{2}}{2} = 186\) 節點編號 i 之 Grandchilden 為 4i +1、4i + 2、4i + 3、4i+4 節點編號 512 之左子節點為 512 × 2 = 1024 ≧ 1000 ，不存在 樹高為 \(2^k-1 = 1000 \\ \Rightarrow k = \lceil \lg 1001 \rceil = 10\) 節點編號 537 位於哪一層 \(2^k - 1 = 537 \\ \Rightarrow k = \lceil \lg 538 \rceil = 10\) 第七層的第一個節點編號為 前六層之節點總數 \(2^6 - 1 = 63 \\ \Rightarrow 64\) 最後一個父節點之編號 \(1000 / 2\) = 500 有幾個 Leaf 節點 1000 - 500 = 500 Degree 為 1 之節點個數為；該節點編號為 \(n = n_0 + n_1 + n_2 \\ \Rightarrow n = 500 + n_1 + (n_0 -1 )\\ \Rightarrow n = 1\) 編號為 500 (True or false) 在一個「Complete binary tree」，\(n_1\)的數量 = 0 or 1？ TRUE (True or false) 在一個「Complete binary tree」，任何節點之左右子樹必也為「Complete binary tree」？ TRUE (True or false) 在「Binary tree」中，根節點之左右子樹若皆為「Complete binary tree」，則此樹為「Complete binary tree」？ False Strict binary tree 二元樹中，任何非葉節點必有兩個子節點 ( \(n_1\) = 0 ) strictbinarytree Example 「Full binary tree」必為「Strict binary tree」？ True 「Complete binary tree」必為「Strict binary tree」？ False 「Strict binary tree」必為「Full binary tree」？ False 「Strict binary tree」必為「Complete binary tree」？ False Example 針對下列非空二元樹，選出正確敘述 （1）\(n_0 = n_2 + 1\) （2）\(n = 2\cdot n_0 - 1\) （3）高 = \(\lceil \lg (n+1)\rceil\) （4）\(n_0 + n_2 \leq n \leq n_0 + n_2 + 1\) 任意「Binary tree」— （1） 「Full binary tree」— （1）（2）（3）（4） 「Complete binary tree」 — （1）（3）（4） 「Strict bianry tree」— （1）（2） Link list tree n 個節點之「Binary tree」總共有 2n 個鍊節，其中 n-1 條鍊節是有用的 n - (n-1) = n + 1 為 Nil (浪費) Tree travesal 若只有前序與後序的資訊時狀況如下： Preorder：abc Postorder：cba treetra_1 treetra_2 treetra_3 treetra_4 Example Preorder：ABCDEFG Postorder：DCBFGEA A(BCD)(EFG) (DCB)(FGE)A traex_1 討論 ＜EFG＞ traex_2 討論 ＜BCD＞ traex_3_1 traex_3_2 traex_3_3 traex_3_4 Example 決定下列二元樹各為何？ 前序等於中序 Right skew tree、Empty、Single node tree 後序等於中序 Left skew tree、Empty、Single node tree 前序等於後續 Single node tree、Empty Example 下列哪些可決定唯一的二元樹？ （1）Levelorder + Preorder （2）Levelorder + Postorder （3）Levelorder + Inorder Levelorder：abc Preorder：cba traex_3_1 traex_3_2 traex_3_3 traex_3_4 Example 下列何者可以決定唯一的二元樹？ （1）Complete binary tree + 前序 （2）Complete binary tree + 中序 （3）Complete binary tree + 後序 （4）Complete binary tree + 中序 皆可，因為「Complete binary tree」可以視為一個已經建好的樹狀表格，在依照各不同的「Order」填入即可 應用 葉節點個數計算 12345678910int Myst( T:pointer of root ) &#123; if(T == nil) &#123; return 0; &#125; else &#123; n_L = Myst( T-&gt;leftchild ); n_R = Myst( T-&gt;rightchild ); if( n_L + n_R == 0 ) return 1; else return n_L + n_R &#125;&#125; Swap a binary tree 12345678910void Swap ( T:pointer of root ) &#123; if(T != nil) &#123; Swap(T-&gt;leftchild); Swap(T-&gt;rightchild); Tmp = T-&gt;leftchild; T-&gt;leftchild = T-&gt;rightchild; T-&gt;rightchild = R-&gt;leftchild; &#125; return;&#125; Binary search tree Example n 個節點的「Full binary search tree」問平均比較次數？ 樹高 k = \(\lceil \lg (n+1) \rceil\) \(\Rightarrow n = 2^k -1\) 令 S 為全部的比較次數，若比較到第一層需要比較一次比較次數，若到第二層需要兩次比較次數…. \[ \begin{matrix} S = &amp; 2^0 \cdot 1 + &amp; 2^1 \cdot 2 + 2^2 \cdot 3 + \ldots + 2^{k-1}\cdot k..................(1)\\ 2S= &amp; &amp; 2^1 \cdot 1 + 2^2 \cdot 2 + \ldots + 2^{k-1}\cdot (k-1) + 2^k \cdot k .....(2) \end{matrix} \\ By (2)-(1) \Rightarrow S = -2^0 -2^1 - 2^2 -\ldots - 2^{k-1} + 2^k \cdot k \\ \Rightarrow \frac{S}{n} = \frac{2^k\cdot k-\frac{2^k-1}{2-1}}{2^k-1} = \frac {2^k\cdot(k-1)+1}{2^k -1} \approx \frac {2^k\cdot(k-1)}{2^k} = (k-1) = \lg(n+1)-1 \] 所以平均只要比較樹高的量即可 Example 下列何者可決定唯一的「Binary tree」？ （1）Binary search tree + Preorder （2）Binary search tree + Inorder （3）Binary search tree + Postorder （4）Binary search tree + Levelorder 「Binary search」本身就會有「Inorder」 Example (P.212 ex28) 有一個「Binary search tree」，找資料 2006 時經過了 1000、5566、5203、k、1314、1510、2381、2006 雖然知道 K 是多少，但可以藉由 k 之後查詢的資料判斷一定是小於 5203，所以 treeex_1 還有兩種狀況需要討論 若 1314、1510、2381、2006 比 k 還要小的情況 treeex_2 則 2381 &lt; k &lt; 5203 若 1314、1510、2381、2006 比 k 還要大的情況 treeex_3 則 1000 &lt; k &lt; 1314 所以 2381 &lt; k &lt; 5203；1000 &lt; k &lt; 1314 Thread binary tree 一棵 n 個結點並以鏈結串列製作之二元樹中，會有 2n - (n-1) = n+1 條鏈結是「Nil」 若 x 的「Lchild」為「Nil」，則視為左引線指向中序順序中 x 的前一個節點 若 x 的「Rchild」為「Nil」，則視為右引線指向中序順序中 x 的後一個節點 節點結構 threadbt Head node threadbthead Insuccess (x) 找出 x 的中序後繼者 若 x 的「Rthread」為 True，則 x 的「Rchild」即為後繼者 若 x 的「Rthread」為 False，則 x 的右子點開始往左下找，直到「Lthread」為 True，該節點即為後繼者 Algorithm 123456789Insuccess(x)&#123; temp = x-&gt;Rchild; if(x-&gt;Rthread == false) &#123; while(temp-&gt;Lthread != false) &#123; temp = temp-&gt;Lchild; &#125; &#125; return temp; &#125; 簡化「Inorder travesel」 從「Head」開始不斷詢問「Insuccessor」並列出 1234567Inorder(head) &#123; temp = head; do&#123; temp = Insuccess(temp); if(temp != head) print(temp-&gt;data); &#125; while(temp != head);&#125; Insert t node as the right child of s 123456789101112Insert(t, S) &#123; t-&gt;Rthread = s-&gt;Rthread; t-&gt;Rchild = s-&gt;Rchild; t-&gt;Lthread = true; t-&gt;Lchild = s; s-&gt;Rthread = false; s-&gt;Rchild = t; if(t-&gt;rthread == false) &#123; temp = Insuccess(t); // 原本為 s 的中序後繼者，要將引線指向 t 節點 temp-&gt;Lchild = t; &#125;&#125; Extended binary tree n 個節點之二元樹，如果以鏈結串列方式建立，則有 n+1 條空鏈結，在這些空鏈結上加上特殊結點，稱為「外部節點」( Extended node；Falure node )，其餘結點稱為「內部節點」( Internal node ) extendbinarytree 有些版本 ( 如離散數學 )： 外部節點等價於葉節點 內部節點等價於非葉節點 I：Internal path length E：External path length 令 n 為內部節點數量，則有 n+1 個外部節點： I = \(\sum_{i = 1}^n\)（樹根至 內部節點\(_i\) 之路徑長） E = \(\sum_{j = 1}^n\)（樹根至 外部節點\(_j\) 之路徑長） Theorem 令 n 為內部節點個數 \[ E = I + 2n \] 數學歸納法 當內部節點數量為 0，E = I = 0，E = 0 + 2×0 = 0，成立 假設 內部節點數量 ≦ n-1 時成立 考慮內部節點數量 = n 時。令 \(n_L\) 為樹根之左子樹具有的節點數量 ，\(I_L\) 為「Internal path length」，\(E_L\) 為「External path length」， 同理右子樹也假設 \(n_R、I_R、E_R\)； 所以\(I = I_L + I_R + (n_L + n_R) \\ E = E_L+E_R +(n_L +1 +n_R+1)\\ \because E_L = I_L + 2n_L , E_R = I_R + 2n_R \\ \Rightarrow E = (I_L + 2n_L) + (I_R + 2n_R) + (n_L +1 +n_R+1) \\ = I + 2N\) E 與 I 成正比 樹高越小 E、I 值越小 Example Skewed extended binary tree 具有 n 個內部節點，求 I 與 E 之值 \(E = I + 2n = \sum_{i = 0}^{n-1} i + 2n \\ = \frac {n^2 + 3n}{2} \\ I = \frac{n^2-n}{2}\) Weighted external path length 給 n 個外部節點加權值 \(q_i, 1 \leq i \leq n\)，則 WEPL = \(\sum_{i = 1}^n [樹根到「外部節點_i」路徑長 \cdot q_i]\) 因為加權值的影響，不見得樹高越小 WEPL 越小 (Fall 的機率) Minimum WEPL 給 n 個外部節點加權值，要在 \(\frac 1n \binom{2n-2}{n-1}\) 棵不同的「Extended binary tree」中找出 WEPL 最小的樹 Huffman algorithm Greedy algorithm 此樹亦稱為「Optimal 2-way merge tree」 令 w = ｛n 個外部節點之加權值｝ 步驟： 在 w 中取出兩個最小的加權值建立「Extended binary tree」 將該「Extended binary tree」之加權值再加回 w 重複上述，直到剩下一個值在 w 中 (執行 n-1 次) 此樹稱為「Huffman tree」，其 WEPL 即為「Minimum WEPL」 123456789101112// w: set｛n 個外部節點之加權值｝// n: w.sizeHuffman(w, n) &#123; for(int i = 1; i &lt;= n-1; i++) &#123; node t; t-&gt;Lchild = Del_min(w); t-&gt;Rchild = Del_min(w); t-&gt;weight = t-&gt;Lchild-&gt;weight + t-&gt;Rchild-&gt;weight; Insert(w, t); &#125; return w[0];&#125; Time complexity Priority queue (Min-heap) 因為對「Min-heap」作了 n-1 次 Del_min 與 Insert(w, t) \(\Rightarrow O(n\log n)\)]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear algebra - Orthogonal complement]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F27%2FLinear-algebra-Orthogonal-complement%2F</url>
    <content type="text"><![CDATA[Minimal solution 假設 \(A \in F^{m\times n}\)，\(b \in F^{m\times 1}\)，其中 Ax = b 有解，若 s 為 Ax = b 的某一解滿足： 「Ax = b 的其他解 u 使得 \(\left \| s \right \| \leq \left \| u \right \|\)」，則稱 s 為 Ax = b 的極小解 ( Minimal solution )。 Theorem 假設 \(A \in F^{m\times n}​\)，\(b \in F^{m}​\)，若 Ax = b 有解，則 唯一存在 \(s \in R(A^H)\) 使得 s 為 Ax = b 的極小解 若 u 滿足 \(AA^Hu = b\) 則 s = \(A^H u\) minimalsol_1 minimalsol_2 minimalsol_3 猜想 Example 求下列線性系統的極小解 \(\left\{\begin{matrix} x + 2y + z = 4 \\ x - y +2z = -11 \\ x + 5y = 19\end{matrix}\right.\) \[ [A|b] = \left[ \begin{array}{ccc|c} 1 &amp; 2 &amp; 1 &amp; 4 \\ 1 &amp; -1 &amp; 2 &amp; -11 \\ 1 &amp; 5 &amp; 0 &amp; 19 \\ \end{array} \right] \\ \Rightarrow \left[ \begin{array}{ccc|c} 1 &amp; 2 &amp; 1 &amp; 4 \\ 0 &amp; -3 &amp; 1 &amp; -15 \\ 0 &amp; 3 &amp; -1 &amp; 15 \\ \end{array} \right] \\ \Rightarrow \left[ \begin{array}{ccc|c} 1 &amp; 2 &amp; 1 &amp; 4 \\ 0 &amp; 1 &amp; \frac {-1}{3} &amp; 5 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{array} \right] \\ \Rightarrow \left[ \begin{array}{ccc|c} 1 &amp; 0 &amp; \frac 53 &amp; -6 \\ 0 &amp; 1 &amp; \frac {-1}{3} &amp; 5 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{array} \right] \] \(x = -6 - \frac53z \\ y = 5 + \frac 13 z \\ \Rightarrow \left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right] + \left[ \begin{array}{} -\frac53 \\ \frac 13 \\ 1 \end{array} \right]z, z\in R\) \(\left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right]\) 為特解向量，$ z, zR$ 為 Ker(A) ， 將特解向量投影至 Ker(A) 的分量為 \(-\left[ \begin{array}{} 5 \\ -1 \\ -3 \end{array} \right]\) ， 所以 \(\left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right] + \left[ \begin{array}{} 5 \\ -1 \\ -3 \end{array} \right] = \left[ \begin{array}{} -1 \\ 4 \\ 3 \end{array} \right]\) 為特解在 \(Im(A^T)\) 的分量，即為極小解。 使用上述解法與 \(AA^T u = b\) 解出之 \(A^Tu = x\) 一致。]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Orthogonal complement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Recursive time function]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F21%2FAlgorithm-Recursive-time-function%2F</url>
    <content type="text"><![CDATA[Substution method Example 1 \[ T(n) = T(\sqrt n) + 1 \\ \Rightarrow T(n^{\frac 14}) + 1 + 1 = T(n^{\frac 14}) + 2 \\ \Rightarrow T(n^{\frac 18}) + 3 \\ \vdots \\ \Rightarrow T(2) + \lg (\lg n) = 1 + \lg \lg n \\ \therefore T(n) = O(\lg \lg n) \] \[ n^{\frac 1{k} } = 2 \\ \Rightarrow \frac 1k \cdot \lg n = 1 \\ \Rightarrow k = \lg n \] Example 2 \[ T(n) = 2\cdot T(\sqrt n) + \log n, T(2) = 1 \\ \Rightarrow 2\cdot(2\cdot T(2^{\frac 14}) + \log \sqrt n) + \log n \\ \Rightarrow 4\cdot T(n^\frac 14) + 2\log n \\ \vdots \\ \Rightarrow \lg n \cdot T(2) + (\lg \lg n )\cdot \log n \\ \Rightarrow \lg n + \lg \lg n \cdot \lg n \\ \therefore T(n) = O(\lg \lg n \cdot \lg n) \] Example 3 (無法使用「Master theory」) \[ T(n) = 2\cdot T(\frac n2) + n \log n, T(1) = 1 \\ \Rightarrow 2\cdot (2 \cdot T(\frac n4) + \frac n2\log \frac n2) + n\log n \\ \Rightarrow 4\cdot T(\frac n4) + n(\log n - 1) + n(\log n) \\ \vdots \\ \Rightarrow n \cdot T(1) + n(\lg n - (\lg n-1)) +\ldots+n(\log n - 1) + n(\log n)\\ \Rightarrow n + n(1 + 2 + \ldots +\log n - 1+\log n) \\ \Rightarrow n + n\frac {(1+\lg n)\lg n}{2} \\ \Rightarrow n + \frac {n\lg n + n(\lg n)^2}{2} \\ \therefore T(n) = O(n\lg^2 2) \] \[ \frac n {2^k} = 1 \\ \Rightarrow k = \lg n \] Example 4 (無法使用「Master theory」) \[ T(n) = 2\cdot T(\frac n2) + \frac {n}{\log n}, T(1) = 1 \\ \Rightarrow 2\cdot (2\cdot T(\frac n4)+\frac{\frac n2}{\log \frac n2}) + \frac {n}{\log n} \\ \Rightarrow 4\cdot T(\frac n4) + \frac {n}{\log n - 1} + \frac {n}{\log n} \\ \vdots \\ \Rightarrow n\cdot T(1) + \frac {n}{\log n - (\log n -1)} + \cdots+\frac {n}{\log n - 1} + \frac {n}{\log n} \\ \Rightarrow n+ n(\frac {1}{1} + \cdots+\frac {1}{\log n - 1} + \frac {1}{\log n}) \\ \Rightarrow n+ n\log\log n \quad （調和級數）\\ \therefore T(n) = O(n\log\log n) \] Example 5 (無法使用「Master theory」) \[ T(n) = 8\cdot T(\frac n2) + n^3 \cdot \log^2 n \\ \Rightarrow 8\cdot(8 \cdot T(\frac n4) + (\frac n2)^3\cdot \log^2(\frac n2))+n^3 \cdot \log^2 n\\ = 64 \cdot T(\frac n4) + n^3 \cdot \log ^2 (\frac n2)+n^3 \cdot \log^2 n \\ \Rightarrow 512\cdot T(\frac n8) + n^3 \cdot \log ^2 (\frac n4) + n^3 \cdot \log ^2 (\frac n2)+n^3 \cdot \log^2 n\\ = 512\cdot T(\frac n8) + n^3 \cdot (\log ^2 (\frac n4) + \log ^2 (\frac n2)+ \log ^2 n) \\ = 512\cdot T(\frac n8) + n^3 \cdot ((\log n - 2)^2 + (\log n - 1)^2+ (\log n)^2) \\ \vdots \\ \Rightarrow n \cdot T(1) + n^3 \cdot ((1)^2 + \ldots + (\log n - 1)^2+ (\log n)^2) \\ \Rightarrow n + n^3 \cdot (\log n)^3 \\ \therefore T(n) = O(n^3\log^3 n) \] Recursive tree 主要見 Algorithm-Recurrence ＜近似＞ \[ T(n) = T(\lceil\frac n2 \rceil + 17) + n \\ 當\; n \rightarrow \infty \Rightarrow \lceil\frac n2 \rceil + 17 = \frac n2 \\ \therefore T(n) = T(\frac n2) + n \Rightarrow T(n) = \Theta(n) \]]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
        <tag>Function</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - 特殊時間函數]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F15%2FAlgorithm-%E7%89%B9%E6%AE%8A%E6%99%82%E9%96%93%E5%87%BD%E6%95%B8%2F</url>
    <content type="text"><![CDATA[特殊的函數 \((\log n)^{\log n}\) \[ \Rightarrow n^{\log \log n} \\ 令 \;d \;為一常數\\ \because d\times \log n &lt; \log \log n\times \log n \\ \log \log n \times \log n&lt; \log n \times \log n \\ \log n \times \log n &lt; n \\ n &lt; n \times \log 2 \\ \therefore n^{\log \log n} &gt; n^d \\ n^{\log \log n} &lt; 2^n \] \((\log n)!\) \[ \because n! \approx n^{n+\frac{1}{2}} \cdot e^{-n} \quad(Stirling \;approximation)\\ \therefore (\log n)! \approx (\log n)^{\log n + \frac 12}\cdot e^{-\log n} \\ \Rightarrow (\log n)^{\log n + \frac 12}\cdot n^{-\log e} \\ \Rightarrow (\log n)^{\log n + \frac 12}\cdot n^{-1} \\ \Rightarrow n^{\log \log n} \cdot (\log n)^{\frac12}\cdot n^{-1} \\ \therefore (\log n)! &lt; (\log n)^{\log n} \] \(n^{\frac {1}{\log n}}\) \[ \because n = 2^{\log n} \\ \therefore (2^{\log n})^{\frac{1}{\log n}} \Rightarrow 2^{\log n \cdot \frac{1}{\log n}} \\ \Rightarrow 2^1 = 2 \] \(2^{\sqrt{2 \log n}}\) \[ 2 = n^{\frac{1}{\log n}} \\ \Rightarrow n ^{\frac{\sqrt{2\log n}}{\log n}} \\ \because 0 &lt; \frac{\sqrt{2\log n}}{\log n} &lt; 1 \\ \therefore \log n &lt; n^{\frac{\sqrt{2\log n}}{\log n}} &lt; n^c, \forall c \in Z^+ , c \geq 1 \] \((\log \log n)!\) f(n) log f(n) n! \(n\log n \notin O(\log n)\) \(2^n\) \(n\log 2 \notin O(\log n)\) \((\log n)!\) \((\log n)\cdot \log \log n \notin O(\log n)\) \(n^2\) \(2\log n \in O(\log n)\) \(\log n\) \(\log \log n \in O(\log n)\) \(2^4\) \(4\log 2 \in O(\log n)\) \(\Rightarrow\) f(n) 為「Polynominal bound」\(\Leftrightarrow\) \(\log f(n) \in O(\log n)\) \[ \Rightarrow \log((\log \log n)!) = (\log \log n)\cdot(\log \log \log n) \\ \Rightarrow (\log \log n)\cdot(\log \log \log n) \leq (\log \log n)^2 \\ \Rightarrow (\log \log n)\cdot(\log \log \log n) = O(\log n) \\ \therefore (\log \log n)! \;為\;「Polynominal \;bound」 \]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Approximation algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F15%2FAlgorithm-Approximation-algorithm%2F</url>
    <content type="text"><![CDATA[Approximation ratio 設 A 為一個「Approximation algorithm」， OPT 為一個「Optimal algorithm」， 對於任何輸入 x ，|A(x)| ≦ |\(\alpha\) OPT(x)|，則稱 A 的「Approximation ratio」為 \(\alpha\)。 (假設處理「最小化問題」) A(x)：以 x 為輸入產生的輸出大小。 所以「|A(x)| ≦ |\(\alpha\) OPT(x)|」的意義是說「Approximation algorithm」的解不會大於最佳解的 \(\alpha\) 倍。 Approximation algorithm for mimimum vertex cover question vertexcoverproblem 12345678910111213// Vertex cover algorithm// input Gc &lt;- &#123;&#125; // empty setE&apos; &lt;- G.Ewhile(E&apos; != &#123;&#125;) &#123; (u, v) &lt;- E&apos; // 任意 E&apos; c &lt;- c \union &#123;u, v&#125; 將 E&apos; 所有含有 u 與 v 的邊去除&#125;return c vertexcoverapproxi Time complexity 因為在 While 中，每次至少會去除一條邊，且邊總共有|E|條 \(\Theta(|E|)\) Apprimation ratio 因為「Vertex cover」要涵蓋圖中所有的邊，所以演算法中任挑一邊時，該連接兩點的其中一點必在「Minimum vertex cover」集合之中。 在此近似演算法中，每次都挑一邊並將兩頂點加入 c 集合之中，在最差的狀況下，都恰一個點在「Minimum vertex cover」中 所以 |c| ≦ 2 × |Minimum vertex cover| 「Approximation ratio」為 2 Approximation algorithm for euclidean traveling salesman problem 歐式空間上的「Traveling salesman problem」。 給定平面上 n 個點，求一個環路 ( Cycle ) 經過每個點恰一次且「Euclidean disteance」和最小 EDTSP Algorithm 選一個點 v 當作根節點 ( Root ) 以 v 為起點，用「Prim’s algorithm」算出 n 個點的「Minimum spainning tree」 將歐式空間上的每一點兩兩相連成為一個「Completed graph」 令 L 為「Minimum spainning tree」做「Preorder traversal」的序列 (sequence) 依照 L 的順序將點相連，則可以得到欲求取的環路 \(C\) Time complexity Step1：\(\Theta(1)\) Step2：將平面上點兩兩相連 \(\Theta(|V|^2)\)，使用 Prim’s algorithm \(\Theta(|V|^2)\) Step3：「Preorder traversal」\(\Theta(V)\) Step4：已在第三步算完 \(\Rightarrow \Theta(|V|^2)\) EDTSPapproxi Approximation ratio ( 100 中央資工 ) 假設最佳環路為 \(C^＊\)，令 T 為第二步所求出的最小生成樹 若將 \(C^＊\) 去除任一邊會形成一個生成樹 T’ 因為 T 為最小生成樹，所以 distance(T) ≦ distance(T’) ≦ cost( \(C^＊\) )……（1） 假設 w 為「Preorder traversal」的「full walk」( 完整走過整顆最小生成樹 )，又最小生成樹的邊被「Full walk」走過兩次，所以 cost(w) = 2 × cost(T)……（2） 首先，將 w 序列以保留頭尾、由前至後將「追蹤該點前已經有追蹤過」 的點去除，並且兩兩相連成為一個環路 \(C\) ，因為 三角不等式（dist(a, b) ≦ dist(a, c) + dist(c, b)）所以 cost( C ) ≦ cost( W )……（3） 因為（2）、（3）\(\Rightarrow\) cost( \(C\) ) ≦ 2 × cost( T )……（4） 因為（1）、（4）\(\Rightarrow\) cost( \(C\) ) ≦ 2 × cost( \(C^＊\) ) \(\Rightarrow\) 「Approximation ratio」：2 triangleinequality EDTSP_optimalsol]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Approximation algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - NP-completeness]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F15%2FAlgorithm-NP-completeness%2F</url>
    <content type="text"><![CDATA[基本概念 目的 將問題依照難度做分類 如何定義 A 問題比 B 問題難？ 如何分類？ 分幾類？ Decision problem 答案只有 Yse/No 的問題 Ex 一個圖中有無「Hamiltonian cycle」？ 每一個最佳化問題 ( Optimization problem ) 均可用參數化的方式化成一對應的「Decision problem」 Ex KP-optimal problem：給定一背包負重 W 以及 n 個物件，問最大的獲利是多少？ KP-decision problem：給定一背包負重 W 以及 n 個物件與一個整數 k，問獲利是否可大於 k？ 當輸出只有 0 或 1 時，稱之為「Language」 為何要化成「Decision problem」？ 將原本問題的輸出 ( Output ) 一致化，轉換成只有「Yes (1)/No (0)」的輸出方便比較原問題是否相同 利用每個「Decision problem」互相比較難度 decisionproblem Reduce 當 A 可以「Polynominal time reduce」至 B，記做，\(A \leq_P B\) 令 A、B 為兩個問題，當 A 可以「Polynominal time reduce」至 B，則滿足： 存在一個函數 f ：A 的輸入(input) → B 的輸入(input)；Transformation f 為「Polynominal time computable」；多項式時間 對於任何一個 A 的輸入 x \(A(x) = Yes \Leftrightarrow B(f(x)) = Yes\) reduce_1 若 \(A \leq_P B\) 代表可以用解決 B 問題的演算法，來實作解決 A 問題的演算法 若 \(A \leq_P B\) 代表A 問題的難度小於 B 問題的難度 ( B 至少比 A 難 ) 若 B 問題可以解決同時代表 A 問題也可以被解決 reduce_2 P、NP、NP-hard、NP-complete 「Deterministic algorithm」 使用該演算法碰到子問題時，只會有一種解答，不會有多種解答。(有限狀態機) P 問題集合 問題皆有一個「Deterministic algorithm」可以在「Polynominal time」中解決( Solve )。 Ex：「排序問題」\(\in\) P；存在一個演算法 ( Quick sort ) 可以在 \(\Theta(n\lg n)\) 中解決 NP 非「Non-polynomial time」 P \(\subset\) NP NP 問題集合 問題皆有一個「Non-deterministic algorithm」可以在「Polynominal time」中解決。 給一個可能的解，若可以在「Polynominal time」中判斷( Verify )是否為該問題的解，則此問題屬於 NP 集合。 NP-hard 問題集合 \(\forall Q \in NP, Q \leq_P A \Leftrightarrow A \in NP–hard\) 在 NP 集合中的問題均有演算法可以解決，所以在 NPC 集合即為「有可用演算法解的最難問題」 NPC 集合的問題在「Worst case」下沒有「Polynominal time」的演算法可解決 (至少都要「Exponential time」) 非「Any case」 有「演算法」可以解 NP-complete 問題集合 \(A \in NP–complete \Leftrightarrow A \in NP \;且\; A \in NP–hard\) 集合關係 nprelation Ex ( true or false ) \(P \supset NP\)；True \(P \supset NP\)；Unknown \(P = NP\)；Unknown \(P \neq NP\)；Unknown 有一個在 NPC 集合的問題之「Worst case」若可被「Polynominal time」的演算法解決 \(\Leftrightarrow P = NP\) 證明問題是否為 NP-complete 令 A 為一問題，欲證明 \(A \in NPC\) 證明 \(A \in NP\) 任找一個 \(B \in NPC\)，證明 \(B \leq_P A\) \(\Leftrightarrow\) 證明 \(A \in NP–hard\) (94 交大) ( True or False ) 已知 Clique 問題屬於 NPC 集合，Vertex-cover 問題屬於 NP 集合，欲證明 Vertex-cover 屬於 NPC 集合，則將 Vertex-cover \(\leq_P\) Clique 即可；False。 (99 政大) 欲證明 A 問題屬於 NPC 集合，則將一個 B 屬於 NPC 「Reduce」到 A 即可；False。 不知道 A 是否屬於 NP 集合，否則 A 有可能為 NP-hard 集合 (無演算法可以解)。 SAT problem 第一個 NP-complete 問題 給定一個「Conjection normal form」\(F\) ，問有無一組「Assignment」可使 \(F\) 輸出為 True。 令 \(F = (x_1 \vee \bar{x_2} \vee \bar{x_3}) \wedge (\bar{x_1} \vee x_3) \wedge (x_2 \vee \bar{x_3})\) 當給定 \(x_1 = true、x_2 = true、x_3 = true\) ，\(F\) 的輸出也為 True， 所以 \(F\) 在 SAT problem 的輸入，則其解為 True。 該問題使用了一個「Non-deterministic algorithm」解決。 常見的證明流程 \[ 「SAT」 \leq_P 「3-SAT」 \leq_P 「Clique」 \leq_P 「Vertex–cover」\\ \leq_P Hamilton \; cycle \leq_P \left\{\begin{matrix} Hamilton \; path\leq_P Longest \; path \\ Traveling \; salesman \; prblem \end{matrix}\right. \] 證明 Longest path problem 屬於 NPC 集合 給定一個圖 G = (V, E) 與 k，問 G 中有無長度大於 k 的「Simple path」。 Claim：Longest path problem 屬於 NP (給定可能的解) 給定一組 Longest path 的輸入 (G, k) 與任意一條「Simple path」\(P\) (在「Polynominal time」內可以確認其解) 則可以在「Polynominal time」中判斷 P 是否為 G 中長度大於等於 k 的「Simple path」 所以「Longest path problem」屬於 NP 集合。 給定 \(P = ＜u_1, u_2, \ldots, u_m＞\) 為一條「Path」 確認 m 是否大於等於 k+1 ？ \(\Theta(1)\) 確認 \((u_i, u_{i+1}) \in E\) ？ 若 G 使用「Adjacency matrix」儲存，若要判斷一邊是否屬於 E ；\(\Theta(1)\) Claim：Hamilton path \(\leq_P\) Longest path 給定一個 Hamilton path problem 的輸入：G = (V, E)， 定義一個函數 f ：G → (G, k = |V|-1)，則 (G, |V|-1) 為 Longest path problem 的輸入 f 顯然為「Polynominal time computable」 G 有 Hamilton path \(\Leftrightarrow\) G 有長度大於等於 |V|-1 的「Simple path」 G 有 Hamilton path \(P\) ，即： \(\Leftrightarrow P\) 必過 G 中每一點恰一次，且 \(P\) 為「Simple path」 \(\Leftrightarrow P\) 為 G 中長度大於等於 |V|- 1 的「Simple path」 longestpathproblem_NPC 證明 Traveling salesman problem 屬於 NPC 集合 給定一個無向、有權重的完全圖 G = (V, E) 與 k ，問 G 中有無總權重小於等於 k 的「Hamilton cycle」？ Claim：Traveling salesman problem 屬於 NP (給定可能的解) 給定一個無向、有權重的完全圖 G = (V, E) 與 k，與一個 G 上的一個 Hamilton cycle \(C\) (在「Polynominal time」內可以確認其解) 則可以在「Polynominal time」中驗證 \(C\) 的權重和是否小於等於 k ，所以 TSP 問題屬於 NP 集合 Claim：Hamilton cycle problem \(\leq_P\) Traveling salesman problem 給定一個 Hamilton 的輸入：G = (V, E)，定義一個 f：G → (G’, k = |V|)， 其中 G’ 的定義如下：G’ = (V, E’)， \(\left\{\begin{matrix} (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E \\ (u, v) \in E&#39;, weight(u, v) = 2, if \;(u, v)\notin E \end{matrix}\right.\) f 顯然為「Polynominal time computable」 G 有 Hamilton cycle \(\Leftrightarrow\) G’ 有一「Hamilton cycle」且其總權重 ≦ |V| TSP_NPC (\(\Rightarrow\)) G 若有一個「Hamilton cycle」\(C\) \(\because (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E\) \(\Rightarrow\) G’ 必也有一個相對應的「Hamilton cycle」\(C&#39;\) 其權重總和 ≦ |V| (\(\Leftarrow\)) G’ 若有「Hamilton cycle」\(C\) 且權重總和 ≦ |V| \(\because (u, v) \in E&#39;, weight(u, v) = 2, if \;(u, v)\notin E\) \(\Rightarrow C\) 上的每一邊在 G’ 的權重必為 1 \(\because (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E\) \(\Rightarrow C\) 通過 G 每節點一次 \(\Rightarrow C\) 為一個在 G 中的「Hamilton cycle」 補充例題 Example（107交通大學資料結構與演算法） A Hamiltonian path of a graph G is a path that visits each node in G exactly once Suppose that there is an \(O(n^7)\)-time algorithm that decides HamP(G) for any n-node graph G HamP(G) Input：an undirected graph G Output：“Yes”, if G has a Hamiltonian path; “No”, otherwise Give an \(O(n^7)\)-time algorithm that decides HamEx(G, x) for any n-node graph G, and prove the correctness of your algorithm Note that your algorithm must have running time \(O(n^7)\) No partial credit will be given if your algorithm runs asymptotically slowr HamEx(G, x) Input：an undirected graph G, and a node x in G Output：“Yes”, if G has a Hamiltonian path from node u to v so that u≠x and v≠x; “No”, otherwise （參考：Re: ［理工］ 107 交大資演10 - 看板Grad-ProbAsk - 批踢踢實業坊） 令 G’ = (V’, E’)，其中 V’ = V ∪ {s, t, s’, t’} |V’| = O(|V|) E’ = E ∪ {(s, s’), (t, t’)} ∪ {(s’, y) | for all y != x)} ∪ {(z, t’) | for all z != x)} 證明HamEx(G, x) = “Yes” iff HamP(G’) = “Yes” If HamEx(G, x) = “Yes”, then HamP(G’) = “Yes” G 中的「Hamiltonian path」頭尾不為 x 因為 s’ 與 G 中所有不是 x 的點相連且 t’ 跟 G 中所有不是 x 的點相連 則 ( s, s’ ,HP in G, t’, t ) 必是一條 G’ 上的「Hamiltonian path」 If HamP(G’) = “Yes”, then HamEx(G, x) = “Yes” 令 HP 為 G’ 中的「Hamiltonian path」 因為 s 和 t 在 G’ 中的 Degree 只有 1 G’ 中的「Hamiltonian path」頭尾必為 s 和 t s 和 t 只分別跟 s’ 和 t’ 相連 「Hamiltonian path」在 G’ 中必為 ( s, s’, HP in G, t’, t ) s’ 和 t’ 都不與 x 相連 在 G 中的「Hamiltonian path」頭尾必不為 x]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>NP-Complete</tag>
        <tag>Reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Computational geometry]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F15%2FAlgorithm-Computational-geometry%2F</url>
    <content type="text"><![CDATA[Computational geometry The rank of a node rankofnode Dominate and rank \(P_1 = (x_1, y_1)\) dominates \(P_2 = (x_2, y_2)\)：\(x_1 &gt; x_2\) and \(y_1 \geq y_2\) Rank (\(P_1\))：The number of node that \(P_1\) dominated Input 2-D 平面上的點集合 S Output 每個底的「Rank」 Native approach 對任意點檢查其它有幾個點可以「Dominate」 Time complexity：\(\Theta(n^2)\) Divide and conquer rankcomputation 先令 m 是集合 S 中每個元素之 x 座標的中位數 ( median )，將 S 分成： \(S_L\)：S 集合中 x 座標小於 m 之元素 \(S_R\)：S 集合中 x 座標大於 m 之元素 將 \(S_L\) 和 \(S_R\) 中每個點的「Rank」求出 ( 遞迴 ) 終止條件：若平面上只有一點，則設其「Rank」為零 對於每個在 \(S_R\) 中的點 P 修正其 Rank Rank(P) = Rank(P) + 「在 \(S_L\) 中 y 座標比 P 小的點個數」 回傳 \(S_L\) 中點之 Rank 加 \(S_R\) 中所有點之 Rank Time complexity Step1：\(\Theta(n)\) Step2：\(2T(\frac n2)\) Step3：\(\Theta(n)\) \(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\) Maximal points maximalpoint 「沒有被任何點 dominate」的點稱為 Maximal point maximalpointalgorithm 先令 m 是集合 S 中每個元素之 x 座標的中位數 ( median )，將 S 分成： \(S_L\)：S 集合中 x 座標小於 m 之元素 \(S_R\)：S 集合中 x 座標大於 m 之元素 將 \(S_L\) 和 \(S_R\) 中每個點的「Maximal point」求出 ( 遞迴 ) 終止條件：若平面上只有一點，則此點即為 Maximal point 將所有在 \(S_L\) 和 \(S_R\) 中的「Maximal point」投影到 L 上。並且依照其 Y 值由大到小用線性搜尋的方式找出每一個在 \(S_L\) 中的「Maximal point」且其 y 座標比某個 \(S_R\) 中的「Maximal point」的 y 座標小者，將其捨去 回傳 \(S_R\) 中「Maximal point」與 \(S_L\)中剩下的「Maximal point」 Time complexity Step1：\(\Theta(n)\) Step2：\(2T(\frac n2)\) Step3：\(\Theta(n)\) \(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\) Closest pairs 2-D 平面上的點集合 S，找 S 中距離最小的距離 概念 計算「有可能Closest pair」兩點的距離，不計算完全不可能的兩點之距離 Divide and conquer 先令 m 是集合 S 中每個元素之 x 座標的中位數 ( median )，將 S 分成： \(S_L\)：S 集合中 x 座標小於 m 之元素 \(S_R\)：S 集合中 x 座標大於 m 之元素 將 \(S_L\) 和 \(S_R\) 中的 Closest pair 的距離 \(d_L\), \(d_R\) 求出 (遞迴) 終止條件：若平面上只有一點，則「Closest pair」的距離為無限大。 closestpairalgorithm 令 d = \(min(d_L, d_R)\) (不跨 \(S_L、S_R\)) （1）對於在 \(S_L\) 中且 x 座標在 m-d ~ m 中的所有點 p = \((x_p, y_p)\) （2）與在 \(S_R\) 中且 x 座標在 m ~ m+d、y 座標在 \(y_p -d\) ~ \(y_p + d\) 的所有點 g 計算 \(min_p\) = min( dist(p, q)\(\forall q \in S_R\)) （3）最後令 d’ = min( \(min_p, \forall p \in S_L\) ) 回傳 min(d, d’) Time complexity Step1：\(\Theta(n)\) Step2：\(2T(\frac n2)\) Step3：\(\frac n2 \times \Theta(1) = \Theta(n)\) \(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\) Step3 根據鴿籠原理 closestpointnote_1 closestpointnote Convex hull 算出 2D 平面上所有點的最小凸多邊形。 名詞 順時針：Clockwise ；Right-turn 逆時針：Counterclockwise；Left-turn Naive Algorithm 令目前平面上 x 座標最小的點為 P ( 必定在凸包上 ) P 與平面上每一點算出向量 取其與 x 軸夾角最大的點 V 旋轉平面使 V 的 x 座標最小化（使 (P,V) 垂直）成為 P’，重複第一步 直到回到最一開始的 P 為止 演示 左：P 次：V convexhull_1 convexhull_2 convexhull_3 convexhull_4 convexhull_5 convexhull_6 Time complexity 若有 n 點必須重複上述動作 n 遍，其中每一遍需要： Step1 算出與其餘點的所有向量：\(O(n)\) Step2 找出與 x 軸夾角最大的 V 點：\(O(n)\) Step3 旋轉平面：\(O(n)\) \(\Rightarrow O(n^2)\) Graham scan 找出點 \(p_0\) ：2D 平面上做有點中 y 座標最小者 ( 若有多個最小點取其中最左者 ) 找出有序集 \(＜P_1, P_2, \ldots, P_n＞\)：依照從 \(P_0\) 對每個點取向量之角度由小到大排列 若兩個以上的點角度相同，則保留離 \(p_0\) 最近的點 建構一個空的「堆疊( Stack )」 \(S\) ( 最後凸包的接點 ) 建構完後 push(\(p_0, S\))、push(\(p_1, S\))、push(\(p_2, S\)) 123456789// 4. (第四步)for(int i = 3; i &lt;= n; i++) &#123; a = second(S); b = top(S); while(cross_product(vector(p_i, a), vector(p_i, b)) != "left_turn") &#123; pop(S); &#125; push(p_i, S);&#125; 外積 ( Cross porduct ) 給定兩向量 \(\vec{p_1} = (x_1, y_1), \vec{p_2} = (x_2, y_2)\) 其外積為 \(\vec{p_1} \times \vec{p_2} = det \begin{bmatrix}x_1 &amp; x_2\\ y_1 &amp; y_2 \end{bmatrix}\) \(\vec{p_1} \times \vec{p_2} &gt; 0\)：稱 \(\vec{p_1}\) 往 \(\vec{p_2}\) 為「Right turn」 \(\vec{p_1} \times \vec{p_2} &lt; 0\)：稱 \(\vec{p_1}\) 往 \(\vec{p_2}\) 為「Left turn」 Time complexity Step1：\(\Theta(n)\) Step2：\(\Theta(n\lg n)\) Step3：\(\Theta(1)\) Step4：\(\Theta(n)\) 每一個點一定會被「push stack」一次 而最多會被「pop stack 」 一次，且再也不會重新「push stack」 所以對於 stack 來說「push」會做 n 次，「pop」最多 n 次，所以最多 2n 次 應用 (92 台大) 在 2-D 空間中給定點集合 \(S = ｛(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)｝\) 一判斷是否有三點為共線 ( collinear )，使用一個 \(O(n^2 \log n)\) 演算法解之 1234567891011121314151617181920212223bool collinear (G) &#123; for(int i = 1; i &lt;= n; i++) &#123; set A = &#123;&#125;; // O(n) for(int j = 1; j &lt;= n ; j++) &#123; if(j != i) &#123; vector_2D tmp = vec(S[i], S[j]); push(tmp, A); &#125; &#125; sort(A); // 以斜率排序 O(nlogn) // O(n) for(int j = 1; j &lt;= n ; j++) &#123; if( slope(A[j]) == slope(A[j+1]) ) return true; &#125; &#125; return false&#125; (97 台大)找到 farthest pair 2D 平面上最遠的兩點必為在 Convex hull 上的某兩點 最遠的兩點必定「互相排斥」，意思是說通過該兩點的兩條平行線會使的其他所有點都在這個之內 ( 紅點、綠點；紅點、黃點 ) farthestpair_1 如何找到「凸包上面哪個點會和哪個點互相排斥」？ farthestpair_2 在該點 ( 紅點 ) 兩鄰邊 ( 黃邊、綠邊 ) 之「最遠點」之間( 黃點與綠點之間的藍點 )的所有點都有可以與紅點互相排斥 farthestpair_3 farthestpair_4 如何求邊的最遠點？ 名詞 「Bitonic sequence」：在碰到「Bitonic point」之前的序列「單調上升」；之後「單調下降」 ( 假設要幫黃邊找最遠點黃點 ) 將除了黃邊上之外的點對黃邊做點到邊的距離並且依序記錄成一個「Bitonic sequence」，接著在該序列中找到中找「Bitonic point」( 也就是我們要找的最遠點黃點 ) Time complexity 在「Bitonic sequence」找「Bitonic point」其實只要使用「Binary search」\(O(\log n)\) 即可 \(finBT(arr, L, R)\xrightarrow{mid = \frac{L + R}{2}}\left\{\begin{matrix} mid, if \; arr[mid-1] &lt; arr[mid] \; ＆ \; arr[mid] &gt; arr[mid+1] \\findBT(arr, mid+1, R), if\;arr[mid] &lt; arr[mid+1] \\findBT(arr, L, mid), if\;arr[mid] &gt; arr[mid+1]\end{matrix}\right.\) 相鄰兩頂點共用 \(O(1)\) 個「排斥點」( 下圖綠邊上的藍點與紅點有共同「排斥點」綠點；有可能不只一個 ) farthestpair_6 演算法 (假設平面上有 n 個點) 使用「Graham scan algorithm」將有 m 個頂點的凸包找出 在使用「Find bitonic point algorithm」將每邊的最遠點找出 使用最遠點將凸包上的頂點分成 m 片段 使用凸包片段列出 \(O(m)\) 對「互相排斥」的點並找出最遠的一個 使用 \(O(m)\) 線性找出最遠的一組 Time complexity Step1 \(O(n\log n)\) Step2 \(O(n\log n)\) 加總 \(O(n\log n)\) (100 政大) 判斷多邊形是 Convex 或 Concase 使用 Graham scan 判斷連續三點是否形成凹角即可]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Computational geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Graph algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F15%2FAlgorithm-Graph-algorithm%2F</url>
    <content type="text"><![CDATA[Graph algorithm Depth first search 所需變數：考慮圖中一點 u color(u)：目前 u 節點的狀態 White：初始值，尚未訪查過 Gray：已被訪查過，但未訪查完其子節點 Black：已經訪查完其子節點 d(u)：發現時間點( Discover time )，即為第一次被訪查的時間點 f(u)：完結時間點( Finish time )，即為訪查完其子節點的時間點 演算法 (P.4-6) DFS(G)：自 G 中任一點開始做 DFS dfs_visit(u)：訪查 u 節點 12345678910111213141516171819202122232425DFS(G)&#123; // initialize foreach u in G.V // G 的點集合 color(u) &lt;- white time &lt;- 0 // 紀錄目前的時間 foreach u in G.V if(color(u) == white) // 找到一個尚未被訪查過的節點 dfs_visit(u)&#125;dfs_visit(u)&#123; color(u) &lt;- gray d(u) &lt;- ++time foreach v in adj(u) if(color(v) == white) dfs_visit(v) color(u) &lt;- black time++ f(u) &lt;- time&#125; Time complexity \(\Theta(\vert V\vert+\vert E\vert)\) ：點數加上邊數 將整個圖的所有點與邊訪查一次。 應用 DFS tree - Edge 深度優先搜尋時，可以將圖中的邊分成四類： Tree edge：u 透過 (u, v) 邊以訪查 v 節點。 可在訪查的過程表示為一個「DFS tree」。 Back edge：不為「Tree edge」，而在「DFS tree」上由子孫節點至祖先節點的邊。 自旋邊( Self loop )亦為「Back edge」。 Forward edge：不為「Tree edge」，而在「DFS tree」上由祖先節點至子孫節點的邊。 Cross edge：無祖孫關係的邊。 在實現中，通常在做 DFS 時就會直接以節點的狀態判斷邊的種類。 Tree edge \[ u_{灰} \rightarrow_{Tree–edge} v_{白} \] Back edge \[ u_{灰} \rightarrow_{Back–edge} v_{灰} \] Forward edge \[ u_{灰} \rightarrow_{Forward–edge} ｛v_{黑} \;＆＆ \; d(u)&lt;d(v) ｝ \] forwardedge Cross edge \[ u_{灰} \rightarrow_{Cross–edge} ｛v_{黑} \;＆＆ \; d(v)&lt;d(u) ｝ \] crossedge Ex (96 年台大資工) 1234567891011121314151617181920212223242526272829303132333435363738DFS(G)&#123; // initialize foreach u in G.V // G 的點集合 color(u) &lt;- white edge(u) &lt;- Null // DFS tree 初始化邊( 雙向邊 ) time &lt;- 0 // 紀錄目前的時間 foreach u in G.V if(color(u) == white) // 找到一個尚未被訪查過的節點 dfs_visit(u)&#125;dfs_visit(u)&#123; color(u) &lt;- gray d(u) &lt;- ++time foreach v in adj(u) if(color(v) == white) edge(v) &lt;- u // 相連節點設為 u edge(v).attribute &lt;- tree dfs_visit(v) else if(color(v) == gray) edge(v) &lt;- u // 相連節點設為 u parent(v).attribute &lt;- back dfs_visit(v) else // 黑節點 edge(v) &lt;- u // 相連節點設為 u if(d(u) &gt; d(v)) // 無祖孫關係 edge(v).attribute &lt;- cross else if(d(u) &lt; d(v)) // 有祖孫關係 edge(v).attribute &lt;- forward dfs_visit(v) color(u) &lt;- black time++ f(u) &lt;- time&#125; DFS tree - Acyclic 存在「Back edge」時，代表有迴圈產生。 演算法 ( 94台大 ) ( 99台大資工 ) 12345678910111213141516171819202122232425262728Acyclic(G)&#123; // initialize foreach u in G.V // G 的點集合 color(u) &lt;- white time &lt;- 0 // 紀錄目前的時間 foreach u in G.V if(color(u) == white) // 找到一個尚未被訪查過的節點 dfs_visit(u) return acyclic&#125;dfs_visit(u)&#123; color(u) &lt;- gray d(u) &lt;- ++time foreach v in adj(u) if(color(v) == white) dfs_visit(v) else if(color(v) == gray) // back-edge is found return G is cyclic color(u) &lt;- black time++ f(u) &lt;- time&#125; Time complexity 有向圖 (94 台大) \(\Theta(V+E)\) 無向圖 (99 台大) \(\Theta(V)\) 在無向圖中，因為鴿籠原理，最多只要檢查 V 個邊即可知道此圖是否為「Cyclic」。( 且如果邊的數量大於點的數量也根據鴿籠原理，此圖必含有迴圈 ) \(\therefore \Theta(V+V) = \Theta(V)\) 另外，在無向圖中只有 Tree edge Back edge 但是，在有向圖則不能以上述判斷。 Ex 兩個節點：A、B 五條邊皆從 A 節點至 B 節點 此圖不包含「Cycle」 Minimum spainning tree 問題探討 假設 (u, v) 為 G 中「權重 ( weight )」最小的邊，則 (u, v) 必在 G 的某一個「最小生成樹」中。 ( 反證法 ) \[ 假設 \;\forall T \in MST \;of \;G \quad edge\;(u, v) \notin T.E \\ 將 \;(u, v)\; 加至 \; T \; ，會使\;T \;會產生一個 \;cycle \; C \\ 令 \;e\; 為\;C\;中除了 \;(u, v)\; 之外權重最大的邊 \\ 將 \;e\; 自\;C\;移除，使 \;C\; 會形成一個新的生成樹 \;T&#39; \\ 且 \;weight(T&#39;) \leq weight(T)\; 產生了一個更小的生成樹，\\ 所以一開始假設的生成樹並非為最小生成樹。(矛盾) \] 上述情況會有兩種矛盾的現象產生 當 \(Weight(T&#39;)&lt;Weight(T)\) 時，代表原本的生成樹不為最小生成樹。 當 \(Weight(T&#39;) = Weight(T)\) 時，代表該最小生成樹的集合中，必有一個樹包含 (u, v) 邊。 定義：「Cycle」由三條邊組成的迴路。 ☆ 假設 (u, v) 為 G 中「權重 ( weight )」第二小的邊，則 (u, v) 必在 G 的某一個「最小生成樹」中。 ( 反證法 ) 前提為該圖 G 各個權重不相等否則反例如下： \[ 假設 \;\forall T \in MST \;of \;G \quad edge\;(u, v) \notin T.E \\ 將 \;(u, v)\; 加至 \; T \; ，會使\;T \;會產生一個 \;cycle \; C \\ \because 一個「Cycle」一定由三個邊組成 \\ \therefore C \;中必有一個邊 \;e \;，其權重&quot;大於等於&quot; (u, v) 的權重 ....(*) \\ 將 \;e\; 自\;C\;移除，使 \;C\; 會形成一個新的生成樹 \;T&#39; \\ 且 \;weight(T&#39;) \leq weight(T)\; 產生了一個更小的生成樹，\\ 所以一開始假設的生成樹並非為最小生成樹。(矛盾) \] G 中權重第三小的邊不一定存在於 G 的某一個「最小生成樹」中 Counter example minimumspainingtree_3 Kruskal’s algorithm 的正確性 概念 T：使用 Kruskal 找出的生成樹 T’：真正的最小生成樹 若 \(T = T&#39;\) ，得證。 若 \(T \ne T&#39;\) ，T 必有邊不包含在 T’ 之中，所以在 T.E - T’.E ( 差集合 ) 中挑一個權重最小的邊 e。 將 e 加入 T’ 後，會形成一個 Cycle 「C」， 在 {C.V - e} 中任取一邊 e’ 必會大於等於 e， 因為如果該邊比較小，在 Kruskal 執行時必優先選擇 e’ ( 然而如此一來導致矛盾所以不可能發生 )， 最後我們可以造一個生成樹 T’’ = ( G.V, (T’.E - {e’}) \(\cup\) {e} )， 且 \(Weight(T&#39;&#39;) \leq weight(T&#39;)\) ； 重複上述步驟 \(T&#39; \xrightarrow{用\;T\;有而\;T&#39;\;沒有的邊做替換} T&#39;&#39; \xrightarrow{用\;T\;有而\;T&#39;&#39;\;沒有的邊做替換} ... \rightarrow T\) ， 並且其過程中生成樹的權重不會增加，所以可以證明 \(weight(T&#39;) = weight(T)\)， 所以 T 是最小生成樹。 Flow network 一個有向圖 G = (V, E) 滿足 只含有唯一一個 in-degree = 0 的點 S ( Source ) 只含有唯一一個 out-degree = 0 的點 T ( Sink ) 對於 G.E 中每個邊 e ，定義一個容量 c(e) ≧ 0 另外，定義一個流量的函數：f(e)，滿足 對每個點而言，流入水量等於流出水量。 對每個邊而言，0 ≦ f(e) ≦ c(e) Max flow problem Input 一個「Flow network」 G = (V, E) Output 此網路的最大流量，也就是源頭最大能流出多少水量 flownetwork Ford-Fulkerson algorithm 使用「Residual network」表示法 自 s → t 找一條路徑 P，令 a 為 P 上最小的權重 \(\overrightarrow{P}\) 上的每一邊 ← 權重 - a \(\overleftarrow{P}\) 上的每一邊 ← 權重 + a 重複此操作直到找不到最小的權重 a 可以做上述動作。 將最後指向 S 的邊之權重和輸出 Time complexity \(O(|f^＊|\cdot E)\) \(|f^＊|\) 為最大流量的值 效能差 如果每次在第二個步驟找到的最小流量 a 為 1，那勢必要重複 \(|f^＊|\) 來找到最後的答案。 可以利用「已經求取完最大流量」的 Residual network 得到「原本流量網路」的 Minimum cut。 Minimum cut：有 (S, T) 兩個子圖，滿足 S \(\cup\) T = V 且 S \(\cap\) T = \(\phi\) 從子圖 S 連至子圖 T 之所有邊的權重和為所有「Cut」中最小 在求完最大流量的「Residual network」中，令 S：｛自 S 可以到達的節點｝ T：｛自 T 可以到達的節點｝ 則 (S, T) 是原本「Flow network」的「Minimum cut」 Edmond-Karp algorithm 使用「Residual network」表示法 自 s 做 Breadth first search ，當找到 t 時建立一條 s → t 路徑 P，令 a 為 P 上最小的權重 \(\overrightarrow{P}\) 上的每一邊 ← 權重 - a \(\overleftarrow{P}\) 上的每一邊 ← 權重 + a 重複此操作直到找不到最小的權重 a 可以做上述動作。 將最後指向 S 的邊之權重和輸出 Time complexity \(O(VE^2)\)：只和網路的大小有關 時間複雜度證明： 證明最短增廣路徑（Argument path）的長度「非遞減」（利用反證法） 設 \(\delta_f (s, x)\) 為源點 s 到 x 增廣前在 \(G_f\) 中的最短路，令 v 頂點是在某次增廣後 \(\delta_{f&#39;} (s, v)\) 長度變小的頂點（$G_{f’} $ 中的最短路徑） 設 \(\delta_{f&#39;} (s, x)\) 表示源點到 x 增廣後在 \(G_{f&#39;}\) 中的最短路徑 所以上述可以寫為 \(\delta_{f&#39;}(s,v) &lt; \delta_f (s,v)\) 令 u 頂點為 v 增廣後在 \(G_{f&#39;}\) 最短路徑中的前一個節點 上述可以表示成 \(\delta_{f&#39;}(s,v)\) Example (P.4-80 ex20) Escape problem escapeproblem 將問題轉換成「邊與點均有 Capacity 的最大流量問題」 ( 將問題「Reduce」至「Flow network」中解決 ) escapeproblem_sol 給定一個「Escape problem」的格子圖 ( Grid；有 m 個起點與 4n - 4 個出口 ) 建立「Flow network」G = ( V, E )： 建立一個「Source」節點 S 並與逃生問題中的起點 ( 藍色節點 ) 相接。 建立一個「Sink」節點 T 並與逃生問題中的邊界點 ( 黃色區塊 ) 的點相接。 「Grid」上的每一條無向邊 ( u, v ) ，在 G 中建立相對應的有向邊 ( u, v ) 與 ( v, u )。 將每一個節點與邊的流量接設定為 1。 若在 G 中能找到最大流量為 m，則亦可以在「Grid」中找到一個逃生的方法。 點與邊均有「Capacity」 的流量網路可以用傳統的流量網路實現。 escapeproblem_solconti 其它問題 問題的要求即使有小變化，可能使其難度改變很大 Shortest path problem (Polynominal)與 Longest path problem (Non-deterministic polynominal) Minimum cut (Polyniminal) 與 Maximum Cut (Non-deterministic polynominal) Euler circuit (P) 與 Hamiltan Cycle (NP-Complete) 同一個問題，若給的環境不同，難度亦可能相差很多 Graph Tree Longest path problem NPC Linear time (P4-66 ex6) Minimum vertex cover NPC Linear time (P) Vertex cover：會和圖上所有邊相連的一個點集合 下圖的「Vertex cover」為｛b, d, f｝ vertexcover 補充例題 Example（100 交通大學資料結構與演算法） Suppose there are several cities along a highway (from the left to the right on the map), which has no forks Given the distances between the neighboring cities, we can compute the distance between any two cities For example, given 4 cities, in order, (A, B, C, D) and the distances between neighboring cities are: distance(A, B) = 1, distance(B, C) = 2, distance(C, D) = 4 Then we can compute the distance matrix In this problem, we consider the reverse problem Given the distance between all pair of the cities, we want to recover the order of the cities along the highway Suppose there are N cities and we only know the distances between all pairs of cities, that is, there are \(\frac{N(N-1)}{2}\) number in arbitrary order For convenience, let the leftmost city be the first city and the rightmost city be the last one and order cities accordingly B C D A 1 3 7 B 2 6 C 4 （中譯） 假設有數個在「無岔路高速公路」旁的城市（在地圖上為由左至右） 當每個相鄰城市的距離得知時，我們可以計算出任兩個城市之間的距離 舉例來說，依序給定四個城市（A、B、C、D）與每個相鄰城市的距離： A 與 B 距離 = 1 B 與 C 距離 = 2 C 與 D 距離 = 4 則我們可以計算出其距離矩陣 在此問題中要考慮的是「逆向工程問題」 給定任兩個城市之間的距離（未給出是哪兩個城市，只知道距離資訊），欲將原始相鄰城市的距離求出 假設知道 N 個城市與城市的距離，也就是說會給定一串大小為 \(\frac{N(N-1)}{2}\) 且無序的數字數列 為了方便計算，讓最左邊的城市當作第一個城市最右邊的城市為最後一個城市 Which of the following is false? The largest value must be the distance of the first city and last city along the highway It can be solved by searching If the input has an answer, then it is unique The second largest value can be the distance of the first city and second to the last city along the highway The second largest value can be the distance of the second city and the last city along the highway Ans: (3) Suppose there are 6 cities and the distance between each pair of the cities are: 9, 8, 8, 7, 6, 6, 5, 5, 3, 3, 3, 2, 2, 1, 1. Which of the following is correct ? There is no solution for this input The distance of the second city and the third city is 3 The distance of the fourth city and the fifth city is 1 The distance of the third city and the fourth city is 3 The distance of the second city and the third city is 8 2 3 4 5 6 1 1 3 6 8 9 2 2 5 7 8 3 3 5 6 4 2 3 5 1 Ans: (4)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Range query problem]]></title>
    <url>%2Fwillywangkaa%2F2018%2F10%2F03%2Fange-query-problem%2F</url>
    <content type="text"><![CDATA[Segement tree 用來存放紀錄在特定區間內 ( segement, interval ) 的資訊。 Pros 可以動態的更新欲求數組之元素。 數組區間的查詢 區間求和值 區間最大值 區間最小值 區間異或值 ( Exclusive or；XOR ) Cons 無法刪除數值 線段樹無法新增節點，只能更新節點的數值並保持區間的最大最小值仍保持正確。 實現 特性 完全二元樹 節點保存特定區間的訊息 採取 Buttom-up 的方式建構，從每一個葉節點建構 STree_1 上面的分段樹根節點保存 0 ~ 7 的資訊，2 號節點保存 0 ~ 3 的資訊，以此類推。 初始化 在建構的過程中，內部節點之建構會使用兩個子節點的資訊，而建構的方式以處理的問題而作法不同 ( 最大、最小、和、XOR )。 Segement create ( 求區間最小值 ) ST：線段樹 A：欲判斷之數組資料 線段樹因為為完全二元樹所以通常以陣列製作 陣列大小需求：\(2 \times 2^{\lfloor\lg N\rfloor + 1}\)，N 為數組大小 (見下圖) STree_2 程式碼 ( c++ ) 123456789101112131415161718192021222324typedef vector&lt;int&gt; vi;// ST:segement tree; A: target number arrayvoid st_create(vi &amp;ST, const vi &amp;A) &#123; int len = 2&lt;&lt;(sizeof(unsigned int) - __buildin_clz((unsigned int)A.size())); ST.assign(len, 0); // 線段樹歸零 st_build(ST, A, 1, 0, (int) A.size()-1);&#125; void st_build(vi &amp;ST, const vi &amp;A, int vetex, int L, int R) &#123; if (L==R) ST[vertex] = L; else &#123; int nL = vertex &lt;&lt; 1; int nR = (vertex &lt;&lt; 1) + 1; st_build(ST, A, nL, L , ((L+R)&gt;&gt;1)); st_build(ST, A, nR, ((L+R)&gt;&gt;1)+1, R ); int lContent=ST[nL], rContent=ST[nR]; int lValue=A[lContent], rValue=A[rContent]; ST[vertex]=(lValue &lt;= rValue)? lContent : rContent; &#125;&#125; 時間複雜度 \(\Theta(\log n)\) 更新 與建立線段樹的方法相同，將位於數組 i 的數字更新後，即從此葉節點向上執行更新至根節點。 123456789101112131415161718// 以數值 v 更新 A[p]// x: 數根// L: 數組左端// R: 數組右端int update (vi &amp;ST, vi &amp;A, int x, int L, int R, int p, int v) &#123; int mid=L+(R-L)/2; if (L == R) A[x] = v; else &#123; if (p &lt;= mid) update(ST, A, x*2 , L , mid, p, v); // 更新左子樹 else update(ST, A, x*2+1, mid+1, R , p, v); // 更新右子樹 &#125; ST[x] = (A[ST[x*2]]&lt;=A[ST[x*2+1]])? ST[x*2]:ST[x*2+1]; // 以左右子樹的資訊更新母節點&#125; 查詢 分為三種情形討論，若當前節點所代表的區間 完全位於欲求取之區間之外 完全位於欲求取之區間之內 部分位於欲求取之區間 1234567891011121314151617181920212223242526int query (vi &amp;ST, const vi &amp;A, int x, int L, int R, int ql, int qr) &#123; int mid = (L+R)/2, ans = -1; // 當前節點完全位於欲求取之區間之內 if (L&gt;=ql &amp;&amp; R&lt;=qr) // 取出該區間值最小的位址 return ST[x]; // 當前節點部分或無位於欲求取之區間之內 if (ql&lt;=mid) &#123; // 取出左區間 ans = query(ST, A, x*2 , L , mid, ql, qr); &#125; if (qr&gt;mid) &#123; // 取出右區間以及比較 int tmp = query(ST, A, x*2+1, mid+1, R , ql, qr); if (ans == -1) ans = tmp; else ans = (A[ans] &lt; A[tmp])? ans:tmp; &#125; return ans;&#125; 其它實現 Efficient Segment Tree Tutorial 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;iostream&gt;class SegmentTree &#123;public: SegmentTree(int count) &#123; n = count; data = std::vector&lt;int&gt;(2 * n, 0); &#125; SegmentTree(std::vector&lt;int&gt; const &amp;values) &#123; n = values.size(); data = std::vector&lt;int&gt;(2 * n); std::copy(values.begin(), values.end(), &amp;data[0] + n); for (int idx = n - 1; idx &gt; 0; idx--) data[idx] = std::min(data[idx * 2], data[idx * 2 + 1]); &#125; void update(int idx, int value) &#123; idx += n; data[idx] = value; while (idx &gt; 1) &#123; idx /= 2; data[idx] = std::min(data[2 * idx], data[2 * idx + 1]); &#125; &#125; int minimum(int left, int right) &#123; // interval [left, right) int ret = std::numeric_limits&lt;int&gt;::max(); left += n; right += n; while (left &lt; right) &#123; if (left &amp; 1) ret = std::min(ret, data[left++]); if (right &amp; 1) ret = std::min(ret, data[--right]); left &gt;&gt;= 1; right &gt;&gt;= 1; &#125; return ret; &#125;private: int n; std::vector&lt;int&gt; data;&#125;;int main() &#123; SegmentTree st(5); st.update(0, 5); st.update(1, 2); st.update(2, 3); st.update(3, 1); st.update(4, 4); for (int i = 0; i &lt; 5; i++) &#123; std::cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; st.minimum(i, i+1) &lt;&lt; std::endl; &#125; std::cout &lt;&lt; st.minimum(1, 4) &lt;&lt; std::endl; st.update(3, 10); std::cout &lt;&lt; st.minimum(1, 4) &lt;&lt; std::endl; std::cout &lt;&lt; st.minimum(0, 5) &lt;&lt; std::endl; st.update(4, 0); std::cout &lt;&lt; st.minimum(1, 4) &lt;&lt; std::endl; std::cout &lt;&lt; st.minimum(0, 5) &lt;&lt; std::endl; SegmentTree st2(&#123;5, 2, 3, 1, 4&#125;);&#125; Sparse table 「Sparse table」為古代之稱，如今詞不達意 Pros 數組區間的查詢 區間最大值 區間最小值 Cons 不能更新、插入、刪除值 浪費空間 無法數組區間的 求和值 異或值 ( Exclusive or；XOR ) 實現 初始化 Construct sparse table N：資料量 value[N]：數組 cnt［logN］[N]：Sparse table 依序先求出寬度為 \(2^0, 2^1, 2^2, \ldots, 2^{\lfloor\lg N\rfloor}\) 的區間最小值，區間的所有可能位置都要算一遍。兩個窄區間可以快速合成出一個寬區間。 STable_1 將所有區間算完存入 Sparse table STable_2 實作時，通常表格中記錄的是索引值、指標，而不是直接記錄數值的最小值。(如下程式碼) 程式碼 (c++) 123456789101112131415161718192021const int N = 1000000; //No. of elementsconst int logN = ceil(log(N));//const int logN = sizeof(unsigned int) - __builtin_clz((unsigned int)dist) - 1;;int value[N];int cnt[logN][N]; //cnt[i][j]: RMQ index void construct_ST() &#123; //Initialization for (int i=0; i&lt;N; ++i) cnt[0][i] = i; // 2^i - 1 &lt; N &lt;=&gt; i &lt; ceil(log(N)) for (int i=1; (1&lt;&lt;i)-1 &lt; N; i++) // j + (2^i-1) &lt; N ; buttom-up 建立 for (int j=0; j+(1&lt;&lt;i)-1 &lt; N; j++) &#123; int L = cnt[i-1][j]; int R = cnt[i-1][j+(1&lt;&lt;(i-1))]; cnt[i][j] = (value[L] &lt;= value[R])? L : R; &#125;&#125; 時間複雜度 \(\Theta(N\log N)\) 空間複雜度 \(\Theta(N \log N)\) 查詢 從表格中找到寬度略短於（相等於）查詢區間的區間，以靠左、靠右的兩條等寬區間，求得查詢區間的最小值： STable_3 如何知道要查「Range」大小為何的表？ 令 \(k\) 為我們所求 → \(k = \lfloor \lg N \rfloor\) 123456789int query(int a, int b) &#123; int dist = abs(b - a) + 1; // 2^i &lt; N &lt;=&gt; i &lt; cel(logN) ; 區間計算 int i = sizeof(unsigned int) - __builtin_clz((unsigned int)dist) - 1; int L = cnt[i][a]; // 左區間 int R = cnt[i][b-(1&lt;&lt;i)+1]; // 右區間 return value[L] &lt;= value[R]? L : R;&#125; 時間複雜度 \(\Theta(1)\) 參考 线段树（segment tree)，看这一篇就够了 輔大張信宏老師講義 演算法筆記]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Sequence</tag>
        <tag>Sparse table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Dynamic programming]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F23%2FAlgorithm-Dynamic-programming%2F</url>
    <content type="text"><![CDATA[Dynamic programming 將已計算的結果記錄在表格中的技巧，目的是為了要避免重複計算相同子問題，以「Button up」的方式實踐。 為何要使用這種方法，以費氏數列程式開始討論。 \[ F_n = \left\{\begin{matrix} 0 &amp; , if \; n = 0\\ 1 &amp; , if \; n = 1\\ F_{n-1} + F_{n-2} &amp; , if \; n \geq 2 \end{matrix}\right. \] 欲求出 \(F_5\) ，以遞迴程式執行，會造成「Overlapping subproblem」，如下圖 \(F_2\) 重複計算了 3 次，\(F_3\) 重複計算 2 次。 overlappingsubproblem 使用動態表格執行之，可以省去很多不必要的重複計算，如下圖。 fibonassidp 構思動態規劃題目的流程 Optimal substructure：一個母問題的最佳解如何由其子問題的最佳解構成。 observedp Shortest path problem Optimal substructure shortestpathproblem_subproblem (98 交大資工) 問 longest path problem 有無 optimal substructure。 無，所以不可以使用動態規劃解此問題。 longestpathproblem 但是如果此圖加上「Acyclic」、「Direct」等條件限制之後，可以用動態規劃解「longest path problem」。 通常要在各種條件之下都可以使用動態規劃解此問題，才可以宣稱此問題可以使用動態規劃解。 Ex (99 交大) 下列何者正確？ （a）Dynamic programming always provides polynominal time algorithm. （b）Huffman coding for compresion is a typical dynamic programming algorithm. （c）Dynamic programming use the table to design the algorithm. （d）Optimal is a important element in the dynamic programming. （e）Single source all shortest path problem has optimal substructure. Ans （a）：false。反例為 Subset-sum problem (暴力法：\(O(2^n)、動態規劃法：\)\(O(n2^{\frac n2})\)) （b）：false。為典型的 Greedy algorithm。 （c） （d） （e） Knapsack problem Fractional knapsack problem 此方法僅限於物品重量為正整數時 0/1 KP 為 NP - Completed 問題 Input： n 個物件 第 i 個重量為 \(w_i\) ，價值為 \(v_i\)。 背包最大負重 \(W\) Output： 最大的獲利值 限制條件： 取得物品的總重量 \(\leq\) W 可取物品的部分 想法 Greedy：從目前 \(\frac{v_i}{w_i}\) 最高的物品開始拿取，直到物品取完，或是取得物品負重已達 W。 Time Complexity \(\Theta(n\log n)\) Ex ( W = 5 ) Item \(v_i\) \(w_i\) 1 10 2 2 6 1 3 12 3 \[ \frac{v_2}{w_2} = 6 \geq \frac{v_1}{w_1} = 5 \geq \frac{v_3}{w_3} = 4 \] 取物品 2，取該物品之 1 單位重量，背包剩餘空間 4 單位重量，獲利 6 單位價值。 取物品 1，取物品之 2 單位重量，背包剩餘空間 2 單位重量，獲利 16 單位價值。 取物品 3，取物品之 2 單位重量，背包剩餘空間 0 單位重量，獲利 24 單位價值。 kpdp 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 10 10 10 10 2 0 6 10 16 16 16 3 0 6 10 16 18 22 Ex ( 98 交大 ) P.3-66 ex10 Maximize \(\sum_{i = 1}^n v_ix_i \; subject\; to \sum_{i = 1}^n w_ix_i \leq W, 0 \leq x_i \leq 1\) Greedy choise property ( \(\frac{v_1}{w_1} \geq \frac{v_2}{w_2} \geq\ldots\) ) 最佳解的 \(x_1\) 需取多少。 \[ x_n = \left\{\begin{matrix} 1 &amp; , if \; w_1 \leq W \\ \frac{W}{w_1} &amp; , if \; w1 &gt; W \\ \end{matrix}\right. \] 0-1 Knapsack problem Input： n 個物件 第 i 個重量為 \(w_i\) ，價值為 \(v_i\)。 背包最大負重 \(W\) Output： 最大的獲利值 限制條件： 取得物品的總重量 \(\leq\) W 只能取物品的整體 想法 無法使用 Greedy method 解決 使用動態規劃解決，物品的重量必為正整數 遞迴結構：(令 \(C[i][k]\) 在負重 k 之下考慮物品 1 … i 之最大獲利 \[ C[i][k] = \left\{\begin{matrix} 0 &amp; , if \;i = 0\;OR\; k = 0 \\ max(C[i-1][k-w_i]+v_i, C[i-1][k] )&amp; , if \; w_i \leq k \\ C[i-1][k] &amp; , if \; w_i &gt; k \\ \end{matrix}\right. \] Algorithm ( Bottom up ) 12345678910111213for k &lt;- 0 to w c[0, k] &lt;- 0for i &lt;- 1 to n&#123; c[i, 0] &lt;- 0 for k &lt;- 1 to w &#123; if k &lt; w_i c[i, k] &lt;- c[i-1, k] else c[i, k] &lt;- max(c[i-1, k], c[i-1, k-w_i]+v_i) &#125;&#125; Time complexity \(\Theta( nW )\) Pseudo-polynominal Space complexity \(\Theta( nW )\) Branch and bound 解 0-1 Knapsack problem 對於一個 NP-Completed 問題來說，可以使用「Branch and bound」來解決 「Branch and bound」演算法中，「Bounding function」的設計會是影響整體效能最大的關鍵 ( 收斂快慢 )。 Time complexity：O( 葉節點個數 ) 葉節點個數取決問題本身。 組合性問題：\(2^n\) 排列性問題：\(n!\) 將球最佳解的過程視為在一個「State space tree」中尋找最好的節點。 實務上，通常是設計一 個「Bounding function」以估計目前狀態可到最佳解的可能性。 建構「State space tree」時，每次都先展開「Bounding function」的節點。( Branch ) 在每次展開的過程中，都可以得到一個目前最佳解 (葉節點)，接著，之後不展開「Bounding function 值 \(\leq\) 目前最佳解」的內部節點。( Bound ) 以 Branch and bound 解 0-1 Knapsack problem 每個節點須紀錄 目前的獲利 目前的負重 「Bounding function」算出的值 為了計算「Bounding funciton」括號中要估計「Fractional knapsack」的未來最大值，需要將物品依照 \(\frac{v_i}{w_i}\) 排序。 \(w = 4\) Item \(v_i\) \(w_i\) 1 6 1 2 10 2 3 12 3 \[ \frac{v_2}{w_2} = 6 \geq \frac{v_1}{w_1} = 5 \geq \frac{v_3}{w_3} = 4 \] 設計「Bounding function」。(括號部分就是用來估計以目前節點拓展，獲利的上限) \[ Bounding \;funciotn(目前的節點)\\ = 在「目前的節點」上可得的獲利 + \\ (將背包剩餘的重量以「Fractional \;knapsack \;problem」拿取剩下的物品的獲利) \] KPstatesearchtree 拓展節點 展開 Root 因為該節點「Bounding function」最大，所以展開 A 展開節點 C E 節點因為超重所以為「Infeasiable solution」 F 為一可能解，使 \(Max = 16\) 因為節點 D 在樹中較深處，先展開之 G 與 H 均為一解，設 \(Max = 18\) 因為節點 B 的「Bounding function」\(\leq\) Max，不展開該節點 Ans：18 ( 取物品一與物品三 ) Longest Common Subsequence Sequence X = ＜a, b, c, a＞ Subsequence ＜a, c＞ 為 X 的「Subsequence」 Prefix ( 前綴 ) \(X_3 = ＜a, b, c＞\) Common subsequence Y = ＜a, c, b, c＞ 則＜a, c＞為 X 與 Y 的「Common subsequence」 Longest common subsequence ＜a, b, c＞ 為 X 與 Y 的「LCS」 「LCS」不一定唯一 遞迴結構 令 \(c[i , j]\) 為 \(LCS(X_i, Y_j)\) 的長，則： \[ c[i, j] = \left\{\begin{matrix} 0 &amp; , if \;i = 0\;OR\; j = 0 &amp; \\ c[i-1, j-1] + 1 &amp; , if \; X[i] = Y[j] &amp; \\ max(c[i-1, j], c[i, j-1])&amp; , if \; X[i] \ne Y[j] \; &amp; （該兩個字絕對不會同時出現在LCS） \end{matrix}\right. \] 演算法 ( Bottom-up ) 123456789101112for j &lt;- 0 to n c[0, j] &lt;- 0for i &lt;- 0 to m c[i, 0] &lt;- 0for i &lt;- 1 to m for j &lt;- 1 to n &#123; if(X[i] = Y[i]) c[i, j] = c[i-1, j-1] + 1 else c[i, j] = max(c[i-1, j], c[i, j-1]) &#125; Time complexity \(\Theta(mn)\) Space complexity \(\Theta(mn)\) Ex X = ＜a, b, a, c＞ Y = ＜a, b, c, a＞ 求「LCS」 - - - “a” “b” “a” “c” - - 0 1 2 3 4 - 0 0 0 0 0 0 “a” 1 0 1（↖） 1（←） 1（↖） 1（←） “b” 2 0 1（↑） 2（↖） 2（←） 2（←） “c” 3 0 1（↑） 2（↑） 2（←） 3（↖） “a” 4 0 1（↖） 2（↑） 3（↖） 3（←） Longest Increasing Subsequence Ex X = ＜5, 1, 3, 2, 4＞ LIS(X) = ＜1, 2, 4＞ 演算法 Y &lt;- sort(X) LCS(X, Y) Time complexity \(\Theta(n^2)\) 排序：\(\Theta(n\lg n)\) LCS：\(\Theta(n^2)\) Longest Common Substring Ex X = ＜a, b, a, c＞ Y = ＜a, b, c, a＞ Output：＜a, b＞ \[ c[i, j] = \left\{\begin{matrix} 0 &amp; , if \;i = 0\;OR\; j = 0 &amp; \\ c[i-1, j-1] + 1 &amp; , if \; X[i] = Y[j] &amp; \\ 0&amp; , if \; X[i] \ne Y[j] \; &amp; （該兩個字絕對不會同時出現在LCS） \end{matrix}\right. \] Algorithm 12345678910111213141516171819202122// X[1...n]// Y[1...m]lcstring = &#123;&#125;length = 0// initializefor i &lt;- 0 to n c[0, i] &lt;- 0for i &lt;- 0 to m c[i, 0] &lt;- 0for i &lt;- 1 to m for j &lt;- 1 to n &#123; if(X[i] != Y[i]) c[i, j] = 0 else &#123; c[i, j] = c[i-1, j-1] + 1 if(length &lt; c[i, j]) &#123; length = c[i, j] lcstring = X[(i-length+1)...i] &#125; &#125; &#125; Matrix Chain Multiplication Input： n 個矩陣的大小 P[0 … n] ( 其中\(A_i\) 的大小為 \(P_{i-1}\times P_i\) ) Output： 算出 \(A_1 \times A_2 \times \ldots \times A_n\) 所需最少的純量乘法數 n 個矩陣的「Matrix chain」有 \(C_{n-1} = \frac{1}{(n-1)+1}\binom{2(n-1)}{(n-1)}\) 相異種乘法可能，所以列出所有乘法順序需要指數時間。 Ex. 給定三個矩陣的大小如下 \(A_1：10 \times 100\) \(A_2：100 \times 5\) \(A_3：5 \times 50\) 求算出 \(A_1 \times A_2 \times A_3\) 所需最少的純量乘法數。 若每一個矩陣均為相同大小的「方陣」，改變乘法的順序無法影響所需的純量乘法數，只能使用「Strassen’s algorithm」以加速。 遞迴結構 令 m[i, j] 為算出 \(A_i \times \ldots \times A_j\) 所需最少乘法數 \[ m[i, j] = \left\{\begin{matrix} 0 &amp; , if \;i \geq j\\ MIN_{i\leq k \leq j-1}(m[i, k] + m[k+1, j] + P_i\times P_k \times P_j) &amp; , if \; i &lt; j \end{matrix}\right. \] 演算法 123456789101112131415for i &lt;- 1 to n (「Matrix chain」長度為一) m[i, i] &lt;- 0for l &lt;- 2 to n (「Matrix chain」長度為二以上) for i &lt;- 1 to n-l+1 (起點) &#123; j &lt;- i+l-1 (終點) m[i, j] &lt;- infinity for k &lt;- i to j-1 &#123; tmp &lt;- m[i, k] + m[k+1, j] + P_i-1 * P_k * P_j if tmp &lt; m[i, j] m[i, j] &lt;- tmp (純量乘法數) s[i, j] &lt;- k (切點) &#125; &#125; Time complexity \(\Theta(n^3)\)：\(\sum_{l=2}^n \sum_{i = 1}^{n-l+1}\sum_{k = i}^{i+l-2} 1\) Space complexity \(\Theta(n^2)\) Ex \(A_1：3 \times 3\) \(A_2：3 \times 7\) \(A_3：7 \times 2\) \(A_4：2 \times 9\) \(A_5：9 \times 4\) 算出 \(A_1 \times A_2 \times \ldots \times A_5\) 最少的乘法數。 matrixchaindp martixchainproblem_2 m (乘法數) 1 2 3 4 5 1 0 63（←） 60（←） 114（↓） 156（↓） 2 0 42（←） 96（↓） 138（↓） 3 0 126（←） 128（←） 4 0 72（←） 5 0 s (切點) 2 3 4 5 1 1 1 3 3 2 2 3 3 3 3 3 4 4 最少乘法數：156 最佳乘法順序：\((A_1\times (A_2 \times A_3)) \times (A_4 \times A_5)\) 補充例題 Example（107交通大學資料結構與演算法） We define the maximum subarray of an array A to be the nonempty, contiguous subarray of A whose value have the largest sum Fill in the blank (a), (b) in the following c++ function so that it returns value are placed in A[1], A[2], …, A[n-1] 12345678910111213int maxSubarray(int A[], int n) &#123; for(int i = 1; i&lt;n; ++i) &#123; A[i] += A[i-1]; &#125; int ans = A[0]; int k = 0; for(int i = 0; i&lt;n; ++i) &#123; ans = max(ans, (a) ); k = min(k, (b) ); &#125; return ans;&#125; 考慮一個「Maximum subarray」為 A[x…y] A[x…y] = A[1…y] - A[1…x] 若欲使 A[x…y] 最大化 A[1…y] 必為最大 A[1…x] 必為最小 (a)：A[i]-k (b)：A[i]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Principle of inclusion and exclusion - 排容原理]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F11%2FPrinciple-of-inclusion-and-exclusion-%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Principle of inclusion and exclusion - 排容原理 假設 \(U\) 為與集合，其中 \(|U| = N\)，令 \(a_1, a_2, ..., a_n\) 為 n 個性質，其中這些性質直接定義在 \(U\) 上且 \(N(a_i)\) 表示 \(U\) 中滿足性質 \(a_i\) 的元素個數。 定義 \(N(\bar{a_i})\) 表示 \(U\) 中不滿族性質 \(a_i\) 的元素個數。 \(N(a_ia_j)\) 表示 \(U\) 中同時滿足性質 \(a_i\) 與 \(a_j\) 的元素個數。 \(N(\bar{a_i}\bar{a_j})\) 表示 \(U\) 中同時滿足性質 \(a_i\) 與 \(a_j\) 的元素個數。 Lemma 1 若有一數 \(n\) 有正因數解，該組解必有一正因數「小於等於」\(\sqrt{n}\)。 Proof 若兩正因數都大於 \(\sqrt{n}\) ，相乘後不可能為 \(n\) Ex ( 97 清大 ) 1 ~ 100 中質數有幾個？ Sol \[ \because \sqrt{100} = 10 \therefore Consider: 2, 3, 5, 7\\ \begin{matrix} 令 &amp; \; U \; 表示 2 到 100 的所有數所成集合，則 \; N = |U| = 99 \\ &amp; a_1 表示 U 中大於 2 且為 2 的倍數的性質 \\ &amp; a_2 表示 U 中大於 3 且為 3 的倍數的性質 \\ &amp; a_3 表示 U 中大於 5 且為 5 的倍數的性質 \\ &amp; a_4 表示 U 中大於 7 且為 7 的倍數的性質 \end{matrix} \\ 欲求: N(\bar{a_1}\bar{a_2}\bar{a_3}\bar{a_4})\\ \Rightarrow 100 - (\lfloor\frac{100}{2}\rfloor + \lfloor\frac{100}{3}\rfloor+ \lfloor\frac{100}{5}\rfloor+ \lfloor\frac{100}{7}\rfloor) + \\ (\lfloor\frac{100}{6}\rfloor + \lfloor\frac{100}{15}\rfloor+ \lfloor\frac{100}{35}\rfloor+ \lfloor\frac{100}{10}\rfloor + \lfloor\frac{100}{14}\rfloor + \lfloor\frac{100}{21}\rfloor) - \\ (\lfloor\frac{100}{30}\rfloor + \lfloor\frac{100}{70}\rfloor+\lfloor\frac{100}{105}\rfloor + \lfloor\frac{100}{42}\rfloor) + \lfloor\frac{100}{350}\rfloor\\ = 22 -1 + 4 = 25 \] Ex ( 97 台大 ) 尤拉公式說明 \(n = P_1^{e_1}\times P_2^{e_2}\times P_3^{e_3}, P_i \;is \;prime , e_i &gt; 0\quad Prove: \Phi(n) = n\times(1 - \frac1{P_1}) \times (1 - \frac1{P_2}) \times (1 - \frac1{P_3})\) Proof \[ U = ｛1, ..., n｝, a_1 = ｛1 &lt; x &lt; n \;\vert\; P_1|x ｝, a_2 = ｛1 &lt; x &lt; n \;\vert\; P_2|x ｝, a_3 = ｛1 &lt; x &lt; n \;\vert\; P_3|x ｝\\ 求 \; N(\bar{a_1}\bar{a_2}\bar{a_3}) \\ \Rightarrow n - (\frac{n}{P_1}+\frac{n}{P_2}+\frac{n}{P_3}) + (\frac{n}{P_1P_2} + \frac{n}{P_2P_3} + \frac{n}{P_1P_3}) - \frac{n}{P_1P_2P_3} \\ = n \times (1-(\frac{1}{P_1}+\frac{1}{P_2}+\frac{1}{P_3}) + (\frac{1}{P_1P_2} + \frac{1}{P_2P_3} + \frac{1}{P_1P_3}) - \frac{1}{P_1P_2P_3}) \\ = n\times(1 - \frac1{P_1}) \times (1 - \frac1{P_2}) \times (1 - \frac1{P_3}) \] Theorem m 個相異物放置 n 個相異箱子「不允許」空箱的方法數。 \(|A| = m, |B| = n, m\geq n \Rightarrow onto(m, n) = \sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m\) ( 由 A 集合至 B 集合的映成函數個數 ) 箱子不得為「空」，採用排容原理。 Proof \[ onto(m, n) = n^m - \binom{n}{1}(n-1)^m + \binom{n}{2}(n-2)^m - ... + (-1)^{n-1}\binom{n}{n-1}(1)^m + (-1)^{n}\binom{n}{n}(0)^m\\ = \sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m \] Stirling number of the second kind ＜Note＞ 分堆 m 個相異物放置於 n 個相同箱子「不允許空箱」的方法數，也就是將「映成函數個數」扣除重複計算到相同箱子的個數 假設 \(m, n\) 為兩個整數，其中 \(m \geq n \geq 1\)，定義 \[ S(m, n) = \frac{onto(m, n)}{n!} = \frac{\sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m}{n!} \] 稱為第二種 Stirling 數，有時記作 \(\begin{Bmatrix} m \\ n \end{Bmatrix}\) ，另外為了方便起見，當 \(m &lt; n\) 時，定義 \(S(m, n) = 0\) ＜Note＞ m 個相異物放置於 n 個相同箱子「允許空箱」的方法數 \[ = S(m, n) + S(m, n-1)+S(m, n-2)+\ldots+S(m, 2)+S(m, 1) \] Theorem - 第二種 Stirling 數的遞迴結構 可用在演算法的使用上，通常以「Dynamic programming」的方式撰寫。 \[ S(m+1, n) = S(m, n-1)+S(m, n) \] Dynamic programming ( 直向軸為 m，橫向軸為 n ) 1 2 3 4 5 6 7 1 S(1, 1) = 1 - - - - - - 2 S(2, 1) = 1 S(2, 2) = 1 - - - - 3 S(3, 1) = 1 S(3, 2) = 3 S(3, 3) = 1 - - - - 4 S(4, 1) = 1 S(4, 2) = 7 S(4, 3) = 6 S(4, 4) = 1 - - - 5 S(5, 1) = 1 S(5, 2) = 15 S(5, 3) = 25 S(5, 4) = 10 S(5, 5) = 1 - - 6 S(6, 1) = 1 S(6, 2) = 31 S(6, 3) = 90 S(6, 4) = 65 S(6, 5) = 15 S(6, 6) = 1 - 使用方法 欲求 \(onto(6, 3) + onto(6, 4)\) 查表加上轉換後：\(90\times 3! +65\times 4!\) Proof ( 組合證法 ) S(m+1, n)：m+1 個相異物分成 n 堆，固定一物 A A 為邊緣人\(\Rightarrow S(m, n-1)\) A 有孤單病，所以在 n 堆中挑一堆進入 \(\Rightarrow S(m, n)\times n\)]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>排容原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - File Management]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F10%2FOperating-System-File-Management%2F</url>
    <content type="text"><![CDATA[File management File open、File close 作業系統對檔案進行任何運作之前，皆必須到磁碟的「Physical directory」找出檔案的配置資訊。 問題 因為檔案數目太龐大，所以搜尋的時間長 磁碟 I/O time(次數)很多，非常耗時 File open 當檔案第一次被使用時，作業系統必須到磁碟的「Physical directory」找出檔案的配置資訊，接著將此資訊複製到作業系統的記憶體空間之中的一個表格稱為「Open file table」。將來對這個檔案進行任何操作之前，作業系統只需要到此表格搜尋取得檔案的配置資訊即可。由於「Open file table」中的檔案很少 ( E.g., 20 個)，搜尋的時間可以大幅降低，此表格位於記憶體中，所以可以節省可觀的 I/O time (次數)。 fileopen 因為檔案可以被多個 Process 共用，「Open file table 」分為： System-open file table 保存檔案共通配置的資訊 檔案名稱 配置區塊 檔案大小 Process-open file table Process 存取檔案時，會有不同的資訊要保存( E.g. 檔案目前讀取的指標位置、對檔案的存取權利 ) openfiletable File close 當檔案不再使用時，作業系統會將「Open file table」中此檔案的配置資訊更新回磁碟的「Physical directory」，且自表格中刪除此檔案的配置資訊。 Consistency semantic - 一致性語意 檔案可以被多個 Process / User 共享，而共享的模式 ( Model ) 有那幾種？ UNIX semantic Ex 訂票系統的「座次表」檔案 需要具備「互斥存取」 全部單位讀取檔案必須是「一致的」 某個 Process 對檔案作的任何改變其它 Process 會知道 Session semantic Ex 「空白報名表」檔案供人下載填寫 不需具備「互斥存取」：大家是在各自的「副本」上進行讀寫，讀寫不受限制。 全部單位看到的內容「不一定一致」 Immutable (不可改變) semantic Ex 「總經理公告文件」檔案 唯讀；不可更改 檔名不得重複 File protection Physical protection 防止因為「磁碟毀壞」，所造成的「資料遺失」。 Backup only Logical protection 防止非法使用者對檔案之不當存取。 Name protection Password protection Access list Access group Access group accessgroup User Owner Group ( member ) Others ( universal ) Access right R：Read W：Write X：Execute]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>File Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Disk Management]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F10%2FOperating-System-Disk-Management%2F</url>
    <content type="text"><![CDATA[Disk management Disk system disksystem 硬碟系統由多片「Disk」( 磁片 ) 組成 每片磁片通常雙面都可存取資料。 每一面劃分為多個同心圓軌道，稱為「Track」( 磁軌 )。 每條「Track」由多個「Sector」( 磁區 ) 組成。 不同面之相同「Track no.」組成之集合叫做「Cyclinder」( 磁柱 )。 Ex Disk system 有 10 片磁片 每片皆雙面存取 每面有 2048 條磁軌 每條磁軌有 4096 個磁區。 每個磁區可以存 16 kB 資料 求 Disk system 可存放大小？ \[ ( 10 \times 2 ) \times 2048 \times 4096 \times 16 kB = 2.5 \;TB \] Disk access time Seek time：將磁頭移至愈存取的磁軌上方所花的時間。 Latency time ( or Rotation time )：將欲存取之磁區轉到磁頭下方所花的時間。 Transfer time：資料在磁碟與記憶體之間傳輸的時間，與傳輸量呈正比關係。 Ex 磁碟轉速 7200 RPM 求平均 Latency ( rotation ) time？ \[ Avg. Latency \;( rotation ) \;time = \frac12 \times \frac{1}{7200} \;MPR = \frac{60}{14400} \;SPM = \frac{1}{240} \;second \] Ex Disk system 有 3 片磁片 雙面可存 每面有 1024 條磁軌 每條磁軌有 4096 個磁區 每個磁區可存 32 kB 轉速 6000 RPM 求 Transfer rate ( 每秒可傳輸多少量的資料 ) ＜Note＞ 每轉一圈可傳輸一個磁柱的容量 \[ \frac{6000}{60} \;RPS \times ( ( 3 \times 2 )\;磁軌 \times (4096 \times 32 \;kB) ) = 600 \times 128 \;MB/sec \] Ex Disk system 有 3 片磁片 雙面可存 每面有 1024 條磁軌 每條磁軌有 4096 個磁區 每個磁區可存 32 kB 轉速 6000 RPM 磁碟的平均「Seek time」 = 10 ms 讀取一個大小為 2 MB 的檔案，要花多少 I/O time？ \[ 10 \;ms + \frac{1}{2} \times \frac{60}{6000} \;SPR + \frac{2 \;MB}{600\times128 \;MB/sec} \\ = 10 ms + 5ms + \frac{10}{3\times128} ms \] Disk free space management Block 磁碟配置空間及存取的最基本單位。 Bit vector ( Bitmap ) 每一個 Block 皆用一個bit 表示空閒與否 \(\left\{\begin{matrix}0 &amp;：&amp; 代表空閒\\1 &amp;：&amp; 代表已被配置 \end{matrix}\right.\) 。若磁碟有 n 個 Blocks，則 Bit vector 大小為 n bits。 Pros 簡單容易實施。 容易找到連續的閒置空間 ( 利用演算法找到連續足夠的 0 )。 Cons 適用於小型磁碟；不適用於大型磁碟 ( Blocks 數量龐大造成 Bit vector size 太大，占用記憶體空間 )。 Ex bitvector Link list linklistfreespace 作業系統直接在磁碟上，將這些「Free block」以鍊結的方式串接管理。 Pros 適用於大型磁碟 插入/刪除「Free block」簡單 Cons 找尋大量的可用「Block」不夠迅速( 因為在磁碟上進行 I/O 讀取「鍊結資訊」非常耗時 )＜Note＞ 使用「Grouping」改善 不容易找到「連續的Free block」＜Note＞ 使用 「Counting」改善 Grouping 在「Free block」內除了紀錄「鍊結資訊」，額外紀錄其他「Free block」之編號。 ( Address ) Pros 可快速找到大量的「Free block」 Ex ( 令一個 Block 可以記錄 5 個欄位 ) Linklist_grouping Counting 利用連續性配置以及歸還的特性，改變鍊結串列紀錄的方式；Free block 內除了紀錄 鍊結資訊以外，另外紀錄在此 Free block 之後的連續「Free block」的個數。 Pros 適用於連續性配置，方便找到「連續的 Free block」，若連續的 Free block 很多「Link list」 長度也可大幅縮短。 Ex Linklist_counting ☆File Allocation method Contiguous allocation contiguousallocation 若檔案的大小為 n Block，則作業系統必須在磁碟中找到 n 個「連續的 Free block」，才能配置給它，此外作業系統在「Physical directory」會記錄下列資訊。 File name Start block number Size ( 區塊數量 ) Pros 因為連續的 Block 大多落在同一條磁軌或鄰近的磁軌上，所以平均的 Seek time 較小。 可以支持 Random direct access ( 任意存取該檔案 i-th block )與 Squential access。\(i－th \;block \;no. = Start \;no. + (i-1)\) 與「Linked allocation」相比，可靠度較高。 與「Linked allocation」相比，循序存取速度較快。 Cons 會有外部碎裂的問題磁碟使用磁碟重組 ( Repack )方式解決，類似記憶體中的「Compaction」＜Note＞ 因為所有的檔案是以 Block 為單位在配置，所以所有配置方法都有「內部碎裂」問題 Ex Block size = 10 kB 檔案大小 = 44 kB 所以配置 5 block 內部碎裂 = (5 × 16) - 44 = 6 kB 檔案不易動態擴充 建檔之前必須事先宣告大小 Ex (如上圖) 檔案{ Count } 的大小為 2 block ( Block1 , Block2 ) 作業系統在「Physical directory」紀錄資訊如上圖右側。 Linked allocation Linkallocation 若檔案大小為 n Block，則作業系統只需要在磁碟中找到 n 個 Free blocks (不需連續) 即可配置，且「Allocates block」 之間以鍊結方式串聯，另外作業系統在「Physical directory」紀錄： File name Start block no. End block no. Pros 無外部碎裂的問題 檔案容易動態擴充 建檔之前必不須事先宣告大小 Cons 因為不連續的 Block 可能散落在不同條磁軌上，所以平均的 Seek time 較大。 不支援 Random direct access 使用者的觀點還仍是 Random access 但實際上是先經由 Sequential access 讀至記憶體。 與「Contiguous allocation」相比，若鍊結一旦斷裂資料毀損，可靠度較低。 與「Contiguous allocation」相比，要在磁碟上讀取鍊結的資訊，才知道下一個 Block 為何，所以循序存取速度較慢。 File Allocation Table (FAT) method - Microsoft windows 採用 fileallocationtable 「Allocates block」之間的鍊結資訊存在於「作業系統記憶體區塊」中的一個表格稱為 FAT，並非存於磁碟中。 Pros 讓「Link allocation」在作「Random access」時能加速 因為可使用存在於記憶體中的「FAT」快速 ( 不用 I/O ) 找到第 i 個 Block 的編號，接著再到磁碟存取該 Block 即可。( 不用在磁碟中追蹤該鍊結的資訊 ) Index allocation indexallocation 若檔案大小為 n 個 Block，則作業系統配置 n 個 Block ( 無須連續 ) 存放資料之外，另外需要額外配置「Index block」，儲存所有 Data block 的編號( Address )，且作業系統在「Physical directory」紀錄： File name Index block no. Pros 不會有外部碎裂問題 支援「有效率的 Random access」與 Sequential access 檔案大小容易動態擴充 建檔之前無須事先宣告大小 Cons Index block 會占用額外的空間 Link space 浪費 ( Overhead ) 比「Linked allocation」大很多 若檔案很大，則單一個 Index block 可能無法容 ( 保存 ) 納所有 data block no. ＜解決單一個 Index block 不夠存放所有 data block 的問題＞ Linking scheme - 使用多個 Index block，且彼此以鍊結串接。 Cons 要對 i-th block 作 Random access 之平均 I/O 次數大幅增加 Ex ( 令一個 Index block 可存放 5 個 no. ) linksheme Multilevel scheme - 使用階層式的 Index 架構 Pros 要對 i-th block 作 Random access 之平均 I/O 次數一致 Cons 因為 index block 太佔空間，甚至多於 data block 數量，所以極不適合小型檔案。 Ex ( Two-level index structure ) mulitilevelscheme Combined scheme - UNIX i-node 見下面細述 Ex (如上圖) - 若檔案 ｛jeep｝ 大小為 5 block - 作業系統已配置 ｛9 , 16, 1, 10 ,25｝ 號 block 給它存放資料，另外配置 19 號 block 作為「Index block」 「Physical directory」( 上圖右上側 ) ☆ UNIX i-node unix_inode Ex ( i-node with 15 entry，一個 block 可存放 n 個指標 ) 1st ~ 12th entry：直接紀錄 data block no. ( 目前可記錄的 data block：12 ) 13th entry：為一指標指向「Single-level index」 ( 目前可記錄的 data block：12 + n ) 14th entry：為一指標指向「Two-level index」( 目前可記錄的 data block：\(12 + n + n^2\) ) 15th entry：為一指標指向「Three-level index」( 目前可記錄的 data block：\(12 + n + n^2+n^3\) ) Ex ( 正常的 i-node 定義沿用 ) Block size：16 kB Block no. 占用 4 B 求 max file size 大小？ 一個 index block 可存 \(\frac{16 \;kB}{4 \;B} = 2^{12}\) data block no，所以 \[ max \;file \;size = ( 12 + 2^{12} + 2^{12^2} + 2^{12^3} ) block \\ = ( 12 + 2^{12} + 2^{12^2} + 2^{12^3} ) \times 16 \;kB \approx 2^{36} \times 16 \;kB = 2^{50} B = 1 \;PB \] Ex ( 正常的 i-node 定義沿用 ) 檔案大小為 8000 block 假設 i-node 已經在記憶體之中，則要存取此檔案的第 6000 data block 需要幾次 I/O？ \[ 6000 - 12 = 5988 \\ 6000 - 12 - 4096 = 1892 \\ \] 在「Two level index」的 1892th block，所以需要三次 I/O 存取。 Ex ( 正常的 i-node 定義沿用 ) 檔案大小為 8000 block 循序存取前 6000 個 data block，需要幾次 I/O？ \[ 6000 + (1 \;single－level+ 2 \;two－level) = 6003 \] Disk scheduling algorithm ＜Note＞：Disk schduling 既無「最好」也無「最差」。 FCFS (First come first service) FCFSdiskscduale 最早到達的磁軌請求優先服務。 Cons 排班效果不佳、磁軌移動量大，「Seek time」較長 Pros 公平；No starvation Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 \[ |183-53|+|37-183|+|122-37|+\\ |14-122|+|124-14|+|65-124|+|67-65| = 640 \;軌 \] SSTF ( Shortest seek time track first ) SSTFdiskscheduale 距離磁頭目前為址最近的磁軌要求，最優先服務。 Pros 排班效果不錯，需移動之磁軌數較少、「Seek time」小，【但並非為 Optimal scheduling】。依照目前的題目使用 Look 法則會比較好。 Cons 不公平，有可能會 Starvation Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 \[ |67 - 53| + |14 - 67| + |183 - 14| = 236 \; 軌 \] Scan SCANdiskschedule 磁頭來回雙向移動掃描，遇到有「磁軌請求」即執行服務，當磁頭遇到磁軌的開端或是盡頭時，才「折返」提供服務。 SCANdemo Pros 適用於「大量負載的情況」，排班效能尚可接受。由於磁軌請求有比較均勻的等待時間。 Cons 在某些時候，對某些「磁軌請求」不盡公平。(下圖一)＜Note＞：用「C-Scan 方法」解決。 磁頭需要遇到「磁軌開端或盡頭」才折返會耗費不必要的 Seek time。(下圖二)＜Note＞：用「Look 方法」解決。 SCANdemo2 SCANdemo3 Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 (往小的方向) \[ |53 - 0| + |0 - 183| = 236 \] C-Scan ( Circular-scan ) CSCANschedule 只提供「單向的服務」，折返回程不提供服務。 ＜爭議＞ 是否需要將磁軌回程的移動量\(\left\{\begin{matrix}列入\\ 不列入 \end{matrix}\right.\) 計算。 ( 通常不列入 ) Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 \[ |199-53|+|37-0|\\ OR \\ |199-53|+|37-0| + |199 - 0| \] Look 磁頭服務完該方向的最後一個「磁軌請求」後，即可折返提供回程服務。 Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 (往小的方向) \[ |14 - 53| + |183 - 14| \] C-Look CLOOKschedule 只提供單向的服務。 ＜無爭議＞ 需要將磁軌回程的移動量列入計算。 Ex 磁碟有 200 軌，編號：0~199，磁頭目前停在第 53 軌，現在「Disk queue」中有上圖磁軌請求。 求磁軌移動總數 \[ |183 - 53| + |14-183| + |37 - 14| \] 補充 不同版本比對 恐龍教科書 Modern、其他版本 Scan X C-Scan X Look Scan ( Elevator 法則 ) C-Look C-Scan 其它名詞 Formatting ( 格式化 ) lowlevelformat Physical format ( Low-level format ) 工廠生產「Disk system」時執行 劃分出「Disk controller」可以存取的「磁區」(如上圖) 偵測有無「Bad sector」( 壞磁區 ) Logical format：在使用者使用磁碟之前必須執行 Partition：切割分區，即為「Logical drive」( E.g. C、D、E 磁碟機 ) Logical format：作業系統製作(寫入) 「File management system」所需的資料結構。 空閒空間管理 ( E.g. bitvector ) FAT、i-node 空的「Physical directory」 Row - I/O 將磁碟視為一個大型的陣列使用，一個「磁區」就視為陣列的一個 entry。 沒有「File system」的支援。 Pros 存取速度快 Cons 使用者不易使用，通常用在資料庫系統的底層。 ☆Bootstrap loader windowsMBR 開機時讓電腦可以從磁碟載入作業系統的「Object code」到記憶體的特殊「Loader」。 早期 boot1 流程 Power-on 執行存在 ROM 裡的「Bootstrap loader」 「Bootstrap loader」將存在於磁碟中的「作業系統目的碼」載入到記憶體之中 作業系統執行「System configuration」 開機完成，等待使用者下命令 Cons 「Bootstrap loader」無法任意變更 ROM 大小有限，「Bootstrap loader」無法做大 現今 boot2 完整的 Bootstrap Loader 位於磁碟的固定「Block」位置，稱為「Boot block」； 擁有「Boot block」的磁碟稱為「Boot disk」或「System disk」。 流程 Power-on 執行存在 ROM 裡的「Simple bootstrap loader」( 固定 5 - 10 條指令 ) 「Simple bootstrap loader」將存在於磁碟中的「Complete bootstrap loader」載入到記憶體之中 執行「Complete bootstrap loader」 「Complete bootstrap loader」將 「OS object code」載入記憶體之中。 作業系統執行「System configuration」 開機完成，等待使用者下命令 處理 Bad sector 磁區毀壞原因 工廠生產時已經毀壞 正常使用後一段時間正常毀損 處裡方法 Mark bad sector 標註完後之後看到這個標記就不使用之 Ex：IDE disk controller 採用 Spare(備料) sector ( 下圖一 ) 作業系統無法看到及使用「Spare sector area」，只有「Disk controller」可使用。 工廠生產時，就已經在「Low-level formatting」中預留。 一旦有「Bad sector」則「Disk controller」會從「Spare sector」選擇一個 Spare sector 來替代 Bad sector，將來作業系統在存取該「Bad sector」 時，SCSI controller 會將它導向至替換後的 sector ( 作業系統不知情 )。 Cons 「充新導向」的動作，可能會破壞作業系統「Disk scheduling」的效益。( 下圖二 )改善：將「Spare sector」分散到每條磁軌( 或磁柱 )上，不要集中存放；若磁區發生毀壞，則使用相同或鄰近的磁軌上的「Spare sector」來作替代。 Ex：SCSI disk controller 採用 Sector slipping ( 下圖三 ) Cons 讀寫次數過大，業界不常使用 圖一 sparesector 圖二 SCSIsparesector 圖三 sectorslipping Swap space management 在「Vitrual memory」裡，「Medium-term scheduler」會將磁碟作為「Swap out」的分頁或「Process image」之暫存處。 決定「Swap space」大小時，最好超估( Overestimate )，比較安全。 swapspace 方法 用甚麼方式保存 Swap out page/process image？ 使用 File system 仍用檔案的形式保存。 Pros 實現簡單 Cons 因為通常使用連續性配置 ( Seek time 小；I/O 時間小 )，所以會有外部碎裂 效能比較差 使用獨立的「Partition」來保存 Pros 因為採用「Raw-I/O」，無須「File system」支持，所以效能佳 Cons 內部碎裂 若「Partition」不夠大，則需要「Re-partition」 提升「Disk data access」效能 「Data striping」( Interleaving ) 將多部「Physical disk」組成一個單一的「Logical disk」，運用「平行存取技巧」來提升效能。 Bit-level striping Block-level striping ( 下圖 ) datastriping 提升「Disk availibility」( 可靠度 ) 當「Block」毀損，發生「Data lost」時要如何作「Data recovery」？ Mirror ( shadow ) 技術 每一部正常的磁碟均配備有對應的「Mirror disk」，資料須同時存入正常磁碟與該「Mirror disk」；將來若正常的磁碟發生毀損，則使用「Mirror disk」來取代。 Pros 可靠度高 「Data recovery」最快。 Cons 價格盎貴 Parity-check 技術 多準備一部磁碟用來儲存「Parity-check block」之用，資料寫入時，需額外算出「Parity-check block」內容；將來，若某一「Block」發生毀損，只要用其它「Block」與「Parity block」作偶同位，即可「Recovery data」。 Pros 成本比起 Mirror 技術便宜許多 Cons 可靠度低於 Mirror 技術若多個 Block 同時毀壞，則無法恢復資料 因為需要偶同位的計算，「Data recovery」的速度比 Mirror 技術的慢 因為資料的寫入也需要偶同位的計算，所以寫入的速度比 Mirror 技術的慢 使用 Parity disk 重建資料 假設 P(i) 為「Parity disk」， i 可以是「單位區塊 (block)」或「單位位元 (bit)」，其他四個磁碟儲存資料 ( D(i) ) \[ P(i) = D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i) \] 若 \(D_1\) 發生錯誤透過 P、\(D_3、D_2、D_0\) 重建 \[ D_1(i) = P(i) \oplus D_3(i) \oplus D_2(i) \oplus D_0(i) \] 小量寫入與更新同位位元資料 假設 P(i) 為「Parity disk」， i 只可以是「單位區塊 (block)」，其他四個磁碟儲存資料 ( D(i) ) \[ P(i) = D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i) \] 將 \(D&#39;_1 (i)\) 寫入 \(D_1(i)\)： \[ P&#39;(i) = D_3(i) \oplus D_2(i) \oplus D&#39;_1(i) \oplus D_0(i) \\ = D_3(i) \oplus D_2(i) \oplus D&#39;_1(i) \oplus D_0(i) \oplus (\; D_1(i) \oplus D_1(i) \;) \\ = (\;D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i)\;) \oplus D&#39;_1(i) \oplus D_1(i)\\ = P(i) \oplus D&#39;_1(i) \oplus D_1(i) \] 需要兩次硬碟讀取 ( P、\(D_1\) ) ，兩次硬碟寫入 ( P’、\(D&#39;_1\) ) Redundant Array of Implement Disk ( RAID ) 使用多個容量小的硬碟以替代一個容量大的硬碟，由於多個硬碟可有多個讀寫頭，所以可以使磁碟存取效能獲得提升、改善 使用多個磁碟所組成之「磁碟系統」會使得可靠度 ( Reliability ) 降低，假設兩兩磁碟之錯誤的發生情況是獨立事件，所以： \[ N \; 個磁碟之「Reliability」 = \frac{1 \;個磁碟之「Reliability」}{N} \] 解決可靠度降低之辦法 磁碟陣列技術 ( RAID )：結合多個容量小、便宜之磁碟以獲得一個容量大之磁碟 ( Large expensive drive；SLED )，且在存取上有更好的效能 兩種技術以提升磁碟陣列的「Performance」與「Availability」： Data stripping ( Interleaving ) 將資料分散存儲到不同磁碟，在「資料存取」時，多個磁碟會同時存取以增加「Performance」 E.g. 「Block level striping」 Redundancy 使用部分磁碟作為資料之「備份資訊」或「還原資訊」以提升磁碟陣列的「Availability」( Mean time to repair；MTTR ) 使用「Redundancy」可以改善磁碟陣列系統的「Avaliability」，但無法改善其「Reliability」( Mean time to failure；MTTR )；「Reliability」只能透過改善製造技術，或是使用較少的磁碟建構磁碟系統才能改善 RAID RAID 0 只提供「Block-level striping ( interleaving )」，未提供任何「Availability」技術 ( 未使用附加的磁碟以保護資料 ) Pros 用在存取效能高，但可靠度不重要的場合 E.g. VOD server Cons 任意一硬碟發生錯誤即發生資料遺失 RAID 1 ( Mirroring ) 提供「Mirror」技術以容忍硬碟錯誤 ( 提升「Redundancy」以提升「Availability」 ) ，當資料寫入陣列時，這些資料也會一併寫入「Redundant disk」，使得資料總是有兩個備份 一個硬碟發生錯誤時，磁碟系統會改讀取對應的「Mirror disk」 儲存資料量 \[ Size =\min \left(S_1,S_2,S_3\ldots \right), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots \] Pros 磁碟陣列錯誤容忍度高 Cons 因為需要最多的「備份磁碟」，所以為最昂貴之磁碟陣列技術 RAID 2 ( Double error detecting and single correcting code ) RAID2 採用記憶體的「Error correcting code」( Hamming code ) 技術來改善「Availability」，希望降低「Mirror」成本，但是成本降低有限 ( 比「RAID 1」少一部磁碟 ) 寫入磁碟陣列時，需要讀出所有磁碟之資料，重新計算「Hamming code」並寫入「ECC 硬碟」，效率不佳 Pros 還原資料時間短 Cons 與「RAID 3」相比，雖然「Availability」相同但成本卻比較高 ( 次昂貴之成本 ) 寫入磁碟陣列時需要更新漢明碼不易，維護成本太高 RAID 2 並無實際產品 RAID 3 ( Bit-interleaved parity ) RAID3 採用「Bit-level striping」與「Parity check」技術 提升「Availiability」所需之成本 \(\frac 1N\) N 表示同一個「保護群組」( Protection group ) 中的磁碟數量 Pros 與「RAID 1」相比，使用較少的「還原磁碟」 因為使用「Bit-interleaved」所以可以使「Latency」降很低，所以在操作單一「I/O operation」時速度極快 Cons 與「RAID 1」相比需要使用更多時間以恢復資料 由於資料內的位元分散在不同的硬碟上，因此就算要讀取一小段資料資料都可能需要所有的硬碟進行工作，不允許多個「I/O operation」同時執行 ( 「Throughput」低 ) 由於資料內的位元分散在不同的硬碟上，因此就算要讀取一小段資料資料都可能需要所有的硬碟進行工作，所以這種規格比較適於讀取大量資料時使用 每次的資料存儲都必須從同位元檢查的那個硬碟中取出對應的同位元資料進行核對，由於過於頻繁的使用，所以對硬碟 ( Parity disk ) 的損耗可能會提高 RAID 4 ( Block-interleaved parity ) RAID4 採用「Block-level striping」與「Parity check」技術 同位資訊以區塊的方式儲存，與一組「Data block」相關聯 提升「Availiability」所需之成本 \(\frac 1N\) N 表示同一個「保護群組」( Protection group ) 中的磁碟數量 Pros 相對於「RAID 3」，如果資料存取量為「Block」則可以在不同的磁碟上獨立存，所以可以進行「平行存取」 在大量存取資料時，還是必須存取所有位於同一保護群組之磁碟 在少量寫入磁碟時 ( &lt; block )，計算該「新同位元區塊」：「新資料區塊」、「舊資料區塊」與「舊同位元區塊」執行「XOR」計算即可，不需要「同一保護群組」之其他磁碟中的區塊參與 Cons 需要較多時間以回復毀損資料 平行寫入時必須排隊寫入「Parity desk」( Bottleneck ) 每次的資料存儲都必須從同位元檢查的那個硬碟中取出對應的同位元資料進行核對，由於過於頻繁的使用，所以對硬碟 ( Parity disk ) 的損耗可能會提高 RAID 5 ( Distributed block-interleaved parity ) RAID5 採用「Block-level striping」與「Parity check」技術 為了改良頻繁對「Parity desk」之讀寫使得該磁碟易損耗，也避免平行寫入時會有「Bottleneck」，將「Parity block」分散存於不同的磁碟之中，並非集中在一部磁碟 資料儲存量 \[ Size = (N-1) \times \min (S_1,S_2,S_3\ldots, S_N), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots \] Pros 可以平行讀寫 避免對單一磁碟過度使用 Cons 回復毀損資料需時較久 至少需要三部磁碟組成 RAID5 RAID 5可以理解為是RAID 0和RAID 1的折衷方案；RAID 5可以為系統提供資料安全保障，但保障程度要比鏡像低而磁碟空間利用率要比鏡像高 RAID 5具有和RAID 0相近似的資料讀取速度，只是因為多了一個奇偶校驗資訊，寫入資料的速度相對單獨寫入一塊硬碟的速度略慢，若使用「Write back cache」可以讓效能改善不少 同時由於多個資料對應一個奇偶校驗資訊，RAID 5的磁碟空間利用率要比RAID 1高，儲存成本相對較便宜 RAID 6 ( P+Q redundancy ) RAID6 不用「Parity check」技術，改用類似「Reed-Solomon」( 李德-索羅門碼 ) 技術，任兩塊「Disk block」同時出錯還是能恢復資料 資料儲存量 \[ Size = (N-2) \times \min (S_1,S_2,S_3\ldots, S_N), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots \] Cons 比起「RAID 2」的製作成本太高 「校正區塊」為 RAID5 的兩倍 RAID 6需要分配給奇偶校驗資訊更大的磁碟空間和額外的校驗計算，相對於RAID 5有更大的IO操作量和計算量，其「寫入效能」強烈取決於具體的實現方案，因此RAID 6通常不會通過軟體方式來實現，而更可能通過硬體方式實現 必須具備四個以上的磁碟才能生效 硬體磁碟陣列卡的功能中，也是最常見的磁碟陣列等級 RAID 01 RAID01 File:RAID 01.svg 先 Striping 再整體 Mirror 雖然成本相當昂貴，但是通常用在高效能與高可靠度的場合 Cons 一部磁碟毀壞，須整組替換 RAID 10 ( 優秀 ) RAID10 File:RAID 10.svg 先個別 Mirror 再整體Striping 雖然成本相當昂貴，但是通常用在高效能與高可靠度的場合 結論 p.9-31 RAID 0 用在「高性能( 高存取效能 ) 」且「資料的損失並不重要」的應用場合。 RAID 1 用在「快速復建」且「高可靠度」的應用場合。 RAID 01、RAID 10 用在「高性能」與「高可靠度」的應用場合。 RAID 5 通常適合「儲存大量資料」的應用場合。 Mirror 高可靠度，但卻非常昂貴。 Striping 提供高資料傳輸速率，但卻不能增進可靠度。 RAID 3 比起 RAID 1，「增加可靠度但卻使用較少的磁碟完成」、「Bit-level striping 存取效能高」。 但是 RAID 3 的磁碟使用度 ( Utilization ) 比較低，一次只能一個執行一個 I/O 操作。 RAID 4 大量讀取傳輸速率高，因為磁碟可以平行的讀取/寫入。 小規模獨立寫入必須存取所有硬碟的資料( 包括 Parity disk 資料 )，算出 Parity 值後再寫入。 RAID 5 藉由散布同未位元到所有磁碟機之中，避免對單一台位元磁碟機過度使用( RAID4 、RAID3 )。 ＜Note＞ 解釋不完整，稍後更正。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Disk Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Virtual Memory]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F10%2FVirtual-memory%2F</url>
    <content type="text"><![CDATA[Virtual memory Pros 允許 Process 大小超過實體記憶體可用空間大小時，Process 仍可以正確執行，主要是作業系統要解決之議題，開發者無須擔心。 Additional pros RAM 的利用度 ( Utilization ) 高 儘可能地提高系統的多工度 ( Multiprogramming degree )，亦也提高 CPU 的利用度( Utilization ) ＜Note＞ Thrashing 除外 I/O Transfer time ( I/O 傳輸時間 )較小 (Response)：每次程式要執行時從原本要抓取該程式全部頁面( page )，變成只需要抓取足夠頁面即可 傳輸時間 \(\propto\) 傳輸量 ＜Note＞ 但是整個 Process 在執行的時間作 I/O 傳輸的次數上升(還是要將方才剩餘的頁面抓進頁框之中)，導致整體作 I/O 傳輸的時間是上升的 開發者只需專注於程式的開發，無須將心思置於程式過大而無法執行之問題，因為虛擬記憶體是作頁系統管理的一環。( 開發者不需要使用「Overlay」的技術 ) 實現虛擬記憶體 Demand paging ( 需求分頁技術 ) demandpaging 架構於 Page memory management 的基礎之上 ＜Note＞ 但在虛擬記憶體之中，與傳統 Page memory management 最大的差異在於以前的 Process 必須等到所有程式載入到頁框之中才可執行；但是在虛擬記憶體裡採用「Lazy swapper」，意指在程式開始時，無須載入所有與該 Process 相關之頁面也可正確的執行 Process，等到該 Process 需要該頁面時才載入至頁框。(若初始時，若該 Process 在記憶體無任何頁面，則稱之為「Pure demand paging」 ) 當 Process 於執行階段企圖存取不在頁框( RAM frame )中的頁面時，則稱為發生了「Page fault」並對作業系統發出該錯誤中斷，接著作業系統會將 Process 所需的「Lost page」從硬碟載入至 RAM 中，Process 方可執行。 在分頁中，需要一個欄位：「Valid/ Invalid bit」，用來區分此分頁是否存在於 RAM 中。 \(\left\{\begin{matrix} 1 &amp; ： &amp; 在 \; RAM 中 \\ 0 &amp; ： &amp; 不存在於 RAM 中 \end{matrix}\right.\) Valid bit 作業系統 設定、修改 ( 作業系統在建立分頁表時會決定哪些頁面的進出，所以會設定該 Valid bit 的狀態，另外作業系統在處理「Page fault」時會將頁面抓入 RAM 中並修改該 Valid bit ) 記憶體管理單元 讀取 Valid bit 處理 Page fault handlingpagefault 處理時間長 MMU 會遇到「Address error」並對作業系統傳出「interrupt」。 作業系統收到中斷後，必須暫停該 Process 的執行且保存其狀態資訊於 PCB 中。 作業系統檢查 Process 之存取位址是否合法。若為非法，則終止該 Process；若合法，則作業系統判定為「Page fault」所導致。 作業系統吸到 RAM 中檢查有無空閒頁框 若無，則必須執行「Page replacement」工作，以空出一個頁框，以便將頁面移入記憶體之中。 作業系統再到硬碟中找出「Lost page」所在的位址，啟動 I/O 運作，將 Lost page 載入到 free frame 中。 最後作業系統修改分頁表，紀錄該分頁位於何頁框碼中，另外將 Invalid 改為 Valid。 作業系統恢復中斷之前 Process 的執行。 Ref P8.7 步驟六 …作業系統可將 CPU 分給… 計算 Effective memory access time ( Virtual memory ) 當 P 是「Page fault ratio」時，有效的記憶體存取時間為： \[ (1-p) \times Memory \;access \;time + p \times ( Page\; fault \;process \;time+Memory\;access\;time) \] Ex Memory access time：200 ns page fault process time：5ms 若 page fault ratio = 10 %，求出 Effective memory access time。 \[ Memory \;access \;time + p \times Page\; fault \;process \;time = 200\;ns + 0.1 \times 5ms = 500180 \;ns \] 若希望 Effective memory access time 不超過 2ms 則 page fault reatio 為？ \[ \begin{matrix} &amp;Memory \;access \;time + p \times Page\; fault \;process \;time &amp;\leq&amp; 2 \;ms \\ \Rightarrow&amp; 200 \;ns + p\times5 \;ms &amp;\leq&amp; 2 \;ms \\ \Rightarrow&amp; p\times5 \;ms &amp;\leq&amp; 1.9998 \;ms \\ \Rightarrow&amp; p &amp;\leq&amp; 0.39996 \end{matrix} \] 令 P 代表 TLB hit ratio，q 代表 page fault ratio \[ p \times (TLB \;time + Memory \;access \;time) + (1-p) \times (TLB \;time + \\ Memory\;access\;time_{查Page table} + Memory\;access\;time_{存取資料} + \\q \times Page\; fault \;process \;time) \] 欲降低有效記憶體存取時間降低，提升虛擬記憶體的效能，關鍵在於降低「Page fault ratio」。 影響 Page fault ratio 因素 Page replacement (頁面替換) 當 Page fault 發生且 RAM 無空閒之頁框，作業系統必須執行此工作，即要選擇一「Victim page」( 或 replaced page ) 將它搬出 ( swap out ) 至硬碟保存，以騰出一個空閒的頁框，所以遇到需要「Page replacement 」的情況時，會額外多出一個硬碟的 I/O 運作 ( Page fault process time 更久 )。 如何降低「Swap out」此一額外的「I/O運作」？ 在分頁表中多一個欄位「Modification bit」(Dirty bit)，用以表示上次分頁載入後到現在，內容是否被修改過。\(\left\{\begin{matrix} 1 &amp; ： &amp; 曾經修改過 \\ 0 &amp; ： &amp; 不曾修改過 \end{matrix}\right.\) 所以作業系統可以檢查 Victim page 的 Dirty bit。若為 0 ，則無需將該分頁「swap out」以降低 I/O 次數；反之，則要將該分頁「Swap out」至硬碟之中。 Dirty bit Memory management unit set \((0 \rightarrow 1)\) Operating system Reference and reset\((1 \rightarrow 0)\) Ex Page fault process time：8 ms ( 有可用頁框或是該犧牲頁框不用「swap back」至硬碟中 ) Page fault process time：20 ms ( 該犧牲頁框需「swap back」至硬碟中 ) Memory access time：100 ns 選定已修改過犧牲頁框之機率：70 % 若要使有效記憶體存取時間\(\leq 200 \;ns\) ，求 page fault ratio \(\leq ？\) \[ 100 \;ns + p\times page\;fault\;process\;time \leq 200 \;ns \\ \Rightarrow 100 \;ns + p\times (0.3 \times 8\;ms+0.7\times20\;ms) \leq 200 \;ns \\ \Rightarrow 100 \;ns + p\times 16.4 \;ms \leq 200 \;ns \\ \Rightarrow p \leq \frac{1}{164000} \] Ex 1 次 I/O time：10 ms Page fault ratio：10 % Victim page is modified ratio：60 % Memory access time：200 ns 求有效記憶體存取時間為何？ \[ 200 \;ns + 0.1 \times page\;fault\;process\;time \\ = 200 \;ns + 0.1 \times ( 0.4\times 10\;ms+0.6\times(10 \;ms \times 2) )......*需要兩次I/O運作 \] Replacement policy Local replacement policy ( 多數使用 ) 作業系統只能從發生「Page fault」的 Process 之所有分頁 ( in frame ) 之中挑選一個犧牲頁面，不可在其他 Process 之所有分頁 ( in frame ) 裡挑選犧牲頁面。 Cons 無法從其他不活躍的 Process 之所有分頁中挑選一個犧牲頁面，導致記憶體的利用度差。 Pros 若該 Process 發生「Page fault」的頻率極高，但也不會搶奪其它 Process 的頁框，所以可限縮「Thrashing」的範圍。 Global replacement policy 作業系統可從其他 Process 挑選犧牲頁面。 Cons 若該 Process 發生「Page fault」的頻率極高，因為可以搶奪其它 Process 的頁框，所以「Thrashing」的範圍會一直擴散。 Pros 可從其他不活躍的 Process 之所有分頁中挑選一個犧牲頁面，記憶體的利用度佳。 Page replacement schema ( 法則 ) Belady anomaly Process 分配到的頁框數增加，其「Page fault ratio」卻不減反增之異常現象。 Ex ( *FIFO法則 ) \[ 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5 \] 配置三個頁框： FIFO3frame 9 次「Page fault」 配置四個頁框： FIFO4frame 10 次「Page fault」 Stack property n 個頁框所包含的「Page set」保證是 n+1 個頁框所包含的「Page set」之子集合。 若具有「Stack property」保證不會有「Belady anomaly」。 若在 n 個頁框的「Page set」不會發生「Page fault」，那在 n+1 個頁框自然也不會發生「Page fault」；而如果在 n 個頁框的「Page set」會發生「Page fault」，那在 n+1 個頁框可能不會發生「Page fault」，這樣之下至少 n+1 個頁框會比 n 個頁框少一次「Page fault」。 具有 Stack property 的法則 ( 不會發生「Belady anomaly」 ) Optimal 法則 Least recently used 法則 stackproperty FIFO 法則 最早載入的頁面( Loading time 最小 )，作為犧牲頁面。 Pros 簡單、容易實作。 Cons 可能有「Belady anomaly」現象。 效能不是很好，Page fault ratio 相當高。 ＜Note＞ Page replacement 法則之中，只有最佳沒有最差 ( 在任何情況之下都要使 FIFO 的「Page fault」最高才能稱為最差 )。 Ex 給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「Page reference string」，請求取「Page fault」次數。 \[ 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1 \] 或是以頁框大小為 100 kB，目前有三個空頁框，存取下列位址： \[ 731, 008, 117, 258, 039, 331, 047 ... \] 或是「Logical address」為 12 bits，「Page no.」佔有 3 bits，存取位址如下： \[ FAF, 1DC, 21E, 147, 747, 0AF, 5D7... \] FIFOpagereplace 總共 15 次。 Optimal 法則 ( OPT ) 選擇將來長期不會使用到的分頁作為犧牲頁面。 Pros 「Page fault ratio」最低，所以稱之為「Optimal」。 不會有「Belady anomaly」現象。 Cons 因為需要未來的資訊，所以無法被實作出來。 通常做為理論研究時當作比較對象來使用。 Ex 給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「Page reference string」，請求取「Page fault」次數。 \[ 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1 \] pagereplacement_opt 總共 9 次。 Least recently used ( LRU ) 法則 選擇過去不常使用的分頁作為犧牲頁面，即挑選最後一次存取時間點最小的分頁，也就相當於是「反向 Optimal 法則」( 依照歷史資訊而作出決定的 OPT 法則 )。 Pros 「Page fault ratio」可以被接受。 不會發生「Belady anemaly」現象。 Cons LRU 的製作需要大量硬體支持，所以成本很高。 進而衍生出「LRU 近似法則」，以降低成本。 LRU 的製作方法 以 Counter 製作 程序 每次發生存取該頁面時，累進 Counter 的值。 將 Counter 的值複製至該存取頁面之「last reference time」欄位之中。 作業系統在挑選 LRU 分頁時，就挑選「last reference time」最小的分頁。 以 Stack 製作 最後一次存取之分頁必定置於 Stack 頂端。 Stack 之底端即為 LRU 分頁。 Stack 大小 = 頁框數量。 LRU_stack 3 個頁框有 10 次「Page fault」 注意：此時「FIFO」法加上三個頁框才 9 次「Page fault」 4 個頁框有 8 次「Page fault」 Ex 給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「Page reference string」，請求取「Page fault」次數。 \[ 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1 \] pagereplacement_LRU 總共 12 次。 Least recently used 近似法則 主要以「Reference bit」為基礎 \(\left\{\begin{matrix} 0 &amp; ： &amp; 此分頁未曾被修改過 \\ 1 &amp; ： &amp; 此分頁曾經被修改過 \end{matrix}\right.\)，但不確定何時被存取( 與 LRU 的差異 )。 Additional reference bit 每個分頁有一個欄位 ( 或暫存器； 8 bit … )，當發生記憶體存取時，該分頁之「Reference bit」會被設置為 1，系統每隔一段時間會將各分頁的暫存器值「右移」一位 ( 空出最高位元並將最右側位元捨去 )，並將各分頁之「Reference bit」值複製到暫存器之「最高」位元並重設各個分頁的「Reference bit」。 將來要挑選犧牲頁面時，挑選「暫存器最小值」之分頁，若多個分頁具有相同的值，則以「FIFO 法則」加以篩選。 Ex 給予 3 個頁框並且初始時全部皆為空 \[ 1, 2, 1, 1 ,1 ,1, 3, 1, 3, 3, 3, 3, 5 \] pagereplacement_addbit 遇到「Page 5」時，因為「Page 2」的暫存器值最小所以選擇該分頁為犧牲分頁。 Second chance 法則 以 FIFO 為基礎，搭配「Reference bit」以挑選犧牲頁面。 步驟 先以 FIFO 順序挑出一個分頁。 檢查此分頁的「Reference bit」值，\(\left\{\begin{matrix} case \;1： &amp; 0 &amp; 則該分頁即為犧牲者處理完後回到第一步。 \\ case\;2： &amp; 1 &amp; 跳至第三步。 \end{matrix}\right.\) 給予該分頁機會 ( 不挑選該分頁作為犧牲者 ) 重設該分頁之「Reference bit」為 0。 ☆將該分頁之「載入時間」設置成現在時間 ( FIFO 性質 )。( 載入時間有兩個地方會被更改，\(\left\{\begin{matrix} 1. &amp; 該分頁真的被載入至記憶體之中。 \\ 2. &amp; 給予該分頁機會不挑選為犧牲者時。\end{matrix}\right.\) ) 回到第一步。 ☆Ex ( 四個頁框中，依目前狀態挑一頁框為犧牲頁框 ) pagereplacement_secondchance 挑「Page 3」為犧牲頁框。 Ex ( 三個頁框 ) \[ 1, 2, 3, 4, 2, 5, 2, 6, 1, 2 \] pagereplecement_secondchoice_2 8 次「Page fault」。 當所有分頁之「Reference bit」皆相同時，則退化成 FIFO。 也稱為「Clock algorithm」。 Enhanced second chance 法則 以 ＜Reference bit, Modification bit＞ 配對值作為挑選犧牲頁面的依據，值最小者之分頁作為犧牲頁面。若多個分頁具有相同的值，則以 FIFO 為準。 Modificaion bit 該分頁曾經被修改過，若該分頁為犧牲品，要將該分頁寫回硬碟保存 ( Swap out )。 大小依據 ( 大小由上到下 ) \[ ＜Reference bit, Modification bit＞\\ ＜0, 0＞\\ ＜0, 1＞\\ ＜1, 0＞\\ ＜1, 1＞ \] LFU 與 MFU 法則 ( 無計算題 ) 以分頁的累計總參考次數為挑犧牲頁面的依據。 Cons 「Page fault reatio」相當高。 有「Belady anomaly」。 製作需大量硬體支持，所以成本非常高。 Least frequently used 挑選參考次數最小的分頁為犧牲品。 若多個分頁具有相同值，也是以 FIFO 為準。 Most frequently used 挑選參考次數最多的分頁為犧牲品。 若多個分頁具有相同值，也是以 FIFO 為準。 問題與討論 Ex Page Loading time Last reference time Reference bit Modification bit 參考次數 Page 1 493 800 0 0 410 Page 2 172 700 1 1 235 Page 3 333 430 0 1 147 Page 4 584 621 1 0 875 Page 5 256 564 0 1 432 則下面各法則之犧牲頁面為何？ FIFO：Page 2 LRU：Page 3 Second chance：Page 1 Page 5 要從最早載入( FIFO )的開始檢查。 Enhanced second chance：Page 1 Page 1 以 ＜Reference bit, Modification bit＞ 配對值作為挑選犧牲頁面的依據。 LFU：Page 3 MFU：Page 4 Page buffering 機制 挑選出犧牲頁面後，如果該分頁被修改過，則會 將犧牲頁面 Swap out 至硬碟之中。 載入「Lost page」。 讓 Process 恢復執行。 而以上處理的時間過於冗長，導致 Process 要恢復執行所需的時間拖太久而欲趕改善。 Free frame pool ( 作業系統的預留頁框，平常不配置給 Process 所用 ) 主要由作業系統維護。 當作業系統挑到曾修改過之分頁之後： 作業系統從「Free frame pool」中取出一個 Free frame，提供 Lost page 載入。 載入完成之後，Process 即可恢復執行。 作業系統稍後將犧牲頁面寫回硬碟，空出之頁框再還給作業系統，加入「Free frame pool」之中 freefreampool Modification list 作業系統維護一條「Modification list」，記錄所有曾被修改過的分頁資訊 ( 即為Modification bit 值 = 1 ) 作業系統等到「Paging I/O device」利用度低時 ( 裝置閒置；有空 )，將此串列中某些分頁寫回硬碟之中，同時自此串列移除這些分頁，接著重設該「Modification bit」為 0。 可以使選擇犧牲分頁時，會有較小的機率選到曾被修改過的分頁，也就能讓 Process 有較高的機會可以快速的恢復執行。 ☆ 強化 Free frame pool 以「Free frame pool」為基礎，針對 Pool 中每一個頁框記錄放的是哪個 Process 的哪個分頁 ( ＜Process ID, Page No.＞ )，因為這些分頁內容必定為最新值 ( 該值與存於硬碟中的值目前同調 )。 流程 作業系統選擇完犧牲頁面之後 ( 該頁面曾被修改過 )。 作業系統在「Free frame pool」中尋找有無該需要的「Lost page」存在，（a）若存在則直接將該頁框加入至「Resident frame pool」之中，Process 即可恢復執行 ( 不需任何一次的硬碟的 I/O 傳輸 )。（b）若不存在則再從硬碟取出該分頁寫入至「Free frame pool」並將該頁框加入至「Resident frame pool」中(需一次的硬碟的 I/O 傳輸)。 當作業系統將犧牲分頁寫回 ( Swap back ) 至硬碟之後，再將該頁框加入至「Free frame pool」中。 問題與討論 Ex (P. 8-90 ex89) 舉例說明 LFU 之「Page fault」次數少於 LRU 的可能。 給三個頁框一開始為空。 舉例說明 LFU 之「Page fault」次數多於 LRU 的可能。 給三個頁框一開始為空。 頁框數量分配多寡之影響 一般而言，Process 分配到的頁框數增加，其「Page fault ratio」理應下降。 作業系統分配 Process 頁框數量時，必須滿足最少及最多數量限制。( 由硬體限制，作業系統無權 ) 最大數量限制 實際頁框多寡( 實體記憶體大小 ) 最少數量限制 CPU 在「完成機器指令執行過程中」，可能最多對 RAM 讀寫的次數。( 否則 CPU 在讀取機器指令階段可能永遠無法完成。若讀寫需 3 次，則配給所有 Process 至少要 3 個頁框 ) Ex 假設指令的存取不需跨頁面。 存在於記憶體的運算元採用直接定址模式 則最多可能需要幾次的記憶體存取？ 3 次，則作業系統至少要給 Process 頁框數量大於等於三。 Ex 假設指令的存取需跨頁面。 存在於記憶體的運算元採用間接定址模式 則最多可能需要幾次的記憶體存取？ 6 次，則作業系統至少要給 Process 頁框數量大於等於六。 Thrashing 現象 thrashing 若 Process 分配到的頁框不足時，則此 Process 會經常「Page fault」，所以作業系統要作 Page replacement，若作業系統採用「Global replacement policy」，可能會挑選到其他 Process 所把持的頁框當作犧牲頁面，而如此一來也會造成其他 Process page fault 使得其他 Process 也發生 Page fault，最後又去搶奪其他 Process 的頁框來使用，導致所有 Process 皆發生 Page fault 且等待 Paging I/O 裝置運作完成 ( Swap out / Swap in )，此時 CPU 利用度下降，作業系統會企圖調高「Multiprogramming degree」，將導入更多 Process 進入執行，但是記憶體原本就不夠，所以這些 Process 也立刻發生「Page fault」，而作業系統又在調高「Multiprogramming degree」，不斷循環下去，此時系統呈現： CPU 利用度急速下降。 Paging I/O 設備異常忙碌。 Processes 花在 Page fault process time ( Blocked state )遠大於正常執行時間 ( Running state )。 解決與預防 Thrashing Decrease multiprogramming degree - 解決 當 Thrashing 發生時，作業系統必須將「Multiprogramming degree」降低。 選擇低優先權或完成度低的 Process 作 Swap out。 使用 Page fault frequency control 機制 - 預防 pagefaultfrequencycontrol 使用 Page fault frequency control 機制，來防止 Thrashing 發生。 作業系統會制定合理的「Process page fault ratio 上限與下限」 作業系統如果發現 Process 的「Page fault ratio」 高於「上限值」：作業系統應該多分配一些額外的頁框給該 Process，降低其「Page fault ratio」回到合理的區間。 低於「下限值」：作業系統應該收回一些該 Process 的頁框，分配給其他有需要之 Process 。 若作業系統能夠控制所有 Process 之「Page fault ratio」在合理的區間，則理當不會發生「Thrashing」。 ☆Working set model 技術 運用 Working set model 技術預估 Process 在不同時間執行時，所需之頁框數量，作業系統根據此資訊，分配 Process 足夠的數量，以防止 Thrashing。 此技術是基於「Locality model」( 集中模型 )之理論基礎之上。 workingsetwindow 相關名詞解釋 Working set window：\(\Delta\) 表示以「\(\Delta\) 次的 Page reference」作為依據參考。 Working set 在「\(\Delta\) 次的 Page Reference 」中所「Reference」到不同分頁之集合。 Working set size ( WSS ) Working set 之「元素個數」。 代表 Process 此時所需要頁框數量。 ☆☆ 作業系統應用的方法 假設 n 為 Processes 個數。 \(WSS_i\)：\(Process_i\) 在此時期的「Working set size」。 求 \(D = \sum_{i = 1}^n WSS_i = 頁框的總需求量\) ( Demand )。令 M = 實際記憶體頁框的總數 若\(D \leq M\)：則作業系統可以依照 \(WSS_i\) 之值分配給 \(P_i\) 足夠的頁框數量，也不會造成 Thrashing。 若\(D &gt; M\)：則作業系統會選擇一些 Process 並對他們作「Swap out」，以降低 D 直到 \(D \leq M\) 為止，作業系統再進行分配頁框。 Pros 可以防止「Thrashing」。 對於「Prepaging」有助益：事先猜測哪些資源 Process 會使用到哪些分頁，並預先載入至記憶體之中，如果猜測精準，則可以避免初期之大量「Page fault」。 Cons 不易制定精確的「Working set」。 若前後期的「Working sey」內容分頁差異很大，則 I/O 次數會上升。 Ex (P.8-58 39) 下列狀況增加「Multiprogramming degree」是否有助於提高「CPU utilization」？ （1）CPU 利用度：13%、硬碟利用度：97% （2）CPU 利用度：87%、硬碟利用度：3% （3）CPU 利用度：13%、硬碟利用度：3% （1）(thrashing)、（2）維持現狀； Ex (P.8-63 49) CPU 利用度：20 % Paging disk：97 % 下列哪些措施必 ( will )、可能 ( is likely to )、絕不 ( never ) 增進 CPU 的利用度？ （1）Increase multiprogramming degree （2）Decrease multiprogramming degree （3）Install faster CPU （4）Install more main memory （5）Install bigger disk （6）Install faster disk （7）Local replacement policy used （8）Prepaging used （9）Use bigger page size （10）Use smaller page size 目前正在「Thrashing」： (will) (2)；(4)；(9) (is likely to) (6)：因為 Page fault process time 可以降低；(7)；(8) (never) (1)；(3)；(5)；(10)：更差 Example（106清華大學資工計算機系統） Is it possible for a process to have two working sets, one representing data and another representing code? Explain your answer. 「Working set」是由多個正在執行的「Virtual memory page」組成，且並不包含不用執行的「Page」，所以不可能有兩個「Working set」分別記錄「Data」與「Code」 ☆Locality model localittmodel Process 執行時，對於所存取之「記憶體區塊」，並非是均勻的，而是具有某種 局部/集中 區域存取之特性。 Temporal locality ( 時間局部性 ) 目前所存取的區域不久後又會再度被存取。( 或者是此區域在最近經常被存取，如上圖所示 ) 可能導致的因素 Loop 敘述 Subroutine ( function, pure code… )：常被使用的一段程式碼片段。 Counter ：經常存取之變數。 Stack：頂端之元素。 Spatial locality ( 空間區域性 ) 目前所存取區域之鄰近區域也極有可能被再次存取。 可能導致的因素 陣列 Sequential code execution ( 鄰近程式碼 ) Common data area ( 集中的共享變數 ) Linear search Vector 的運算 ( 早期將向量視為陣列 ) 只要 Program 中用到的指令、資料結構、演算法符合「Locality model」，則此程式對於記憶體是友善的 ( Page fault ratio 應下降 )；若不符合則對記憶體不友善。 不友善的因素 Hashing：希望資料不要靠太近，會發生碰撞。 Binary search：會在記憶體跳來跳去。 Link list goto , jump 指令 間接定址模式：會容易跨頁面存取。 Ex (p.8-55 ex32) Page size 的影響 若 Page size 愈小，則 Pros Page fault ratio ( 效能的關鍵，一旦發生「Page fault」必須要執行「Swap」 )：越大(因為跨不同分頁的機率增加) Page table size：愈大 I/O 次數 ( Total time )：增加 ( 因為會有更多頁面需要載入 ) Cons 內部碎裂：輕微 I/O Transfer time ：越小 ( 因為單一頁面小，I/O的傳輸量就可以降低 ) Locality：越佳 ＜主流趨勢＞ 朝向大的 Page size 設計。 Program structure 對於記憶體存取之影響 workingset 若 Program 中使用的指令、資料結構、演算法符合「Locality model」，則有助於降低「Page fault ratio」。 反之，則無助於降低「Page fault ratio」。 程式中對於陣列元素的處理程序最好與陣列元素在記憶體中的儲存方式 ( Row-major 或 Column-major )對應，有助於降低「Page fault ratio」 Ex A：array [1… 128, 1 … 128] of int 每個 int 佔有 1 B A 以 Row-major 方式存於記憶體中 Page size = 128 B 給該 Process 三個頁框，且程式已經在記憶體之中，採用 FIFO replacement policy 求下列程式碼的「Page fault」次數。 （1） 12345for (i = 1 to 128) &#123; for (j = 1 to 128) &#123; A[i, j] = 0 &#125;&#125; 每一列發生 1 次「Page fault」，共 128 列，所以總共發生 128 次「Page fault」。 （2） 12345for (j = 1 to 128) &#123; for (i = 1 to 128) &#123; A[i, j] = 0 &#125;&#125; 每一行發生 128 次「Page fault」，共 128 行，所以總共發生 128 \(\times\) 128 次「Page fault」。 Ex A：array [1… 100, 1 … 100] of int 每個 int 佔有 1 B A 以 Row-major 方式存於記憶體中 Page size = 200 B 給該 Process 三個頁框，且程式已經在記憶體之中，採用 LRU replacement policy 求下列程式碼的「Page fault」次數。 （1） 12345for (i = 1 to 100) &#123; for (j = 1 to 100) &#123; A[i, j] = 0 &#125;&#125; 每兩列發生 1 次「Page fault」，共 100 列，所以總共發生 100 / 2 次「Page fault」。 （2） 12345for (j = 1 to 100) &#123; for (i = 1 to 100) &#123; A[i, j] = 0 &#125;&#125; 每一行發生 100 / 2 次「Page fault」，共 100 行，所以總共發生 50 \(\times\) 100 次「Page fault」。 Copy-on-write 主要談論到三種 fork() 的差異。 copyonwrite fork() without「copy-on-write」 Parent process 使用 fork() 建立 child process，作業系統會配置新頁框給予 Child process。( Child 與 parent 占用不同的記憶體空間 ) 同時，作業系統會複製 Parent process 內容( Code section, data section )給 Child process。 Cons 記憶體頁框需求量大增。( 與 Parent process 頁框一致 ) 建立 Child process 的時間慢。( 需複製 Parent process 資料 ) ☆ 在 Child 生出之後立即執行 execkp() 作其他的工作時，更加顯得不必要作上面兩件事。 fork() with「copy-on-write」 當 Parent process 建立 Child process 時，作業系統讓 Child 一開始共享 Parent process 之記憶體頁框空間，所以不需要配置給 Child process 新的頁框與複製 Parent 的內容給 Child process。 若 Child process 想要更改某分頁的內容，則作業系統會配置一個新的分頁給 Child ，且複製該分頁內容到新頁框中( 並修改 Child 的分頁表指向新頁框 )，供 Child 使用與修改，就不會影響 Parent process 的資料。 有可能會修改 ( modified ) 的 分頁需標示「copy-on-write bit」為 1。( Read-only code / data 無須標示 ) Pros 可降低頁框需求量 加速 Process 的建立。 vfork() ( Virtual memory fork() ) Parent process 建立 Child process 時，Child process 會共享 Parent process 相同的頁框，但是並無提供「Copy-on-write 技術」，所以任何一方改變了某分頁內容會使另一方受到影響。( 須小心使用 ) 特別適合用於 Child process 的建立是要立刻執行 execlp() 要去作其他工作時，只需要將 Child process 的分頁表指向新頁框的位址即可讓效率提升。 通常用於 Command interpreter 的製作。( UNIX shell ) TLB reach 經由 TLB 的對應，所能存取到的「記憶體空間」大小，則「TLB reach」愈大愈好。 \[ TLB \; reach = TLB \;entry \;數量 \times Page \;size \] Ex TLB 有 8 個 entry Page size = 16 kB TLB reach = 128 kB 增加「TLB reach」的方式 提高 TLB entry 數量 Pros TLB reach 增加 TLB hit ratio 提高 Cons 價格成本高 有時候 TLB entry 的提升仍不足以涵蓋 Process 的「Working set」 增加「Page size」 Pros TLB reach 增加 成本可以接受 Cons 內部碎裂愈嚴重 解決方法：現代的硬體均會提供不同大小的分頁( multiple page size )來使用；E.g. 提供 2 組不同大小的「Page size」 - 4 kB、2 kB所以 TLB 的紀錄項目就會增加一個「Page/Frame size」的欄位紀錄；此外，目前 TLB 的管理從硬體改成作業系統管理，雖然會因為中斷使效能降低，但獲得的好處可以抵消。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Virtual Memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Memory Management]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F08%2FOperating-System-Memory-Management%2F</url>
    <content type="text"><![CDATA[Memory Management Binding 為決定程式( 或 Process ) 執行的起始位址的動作。 時機分類 Compiling time：由編譯器主導 Binding，也稱為 Static binding。(通常用在作業系統的命令檔之中 ) 產生的 Object code 又稱為「Absolute object code」；而在之後的 Loader 稱為「Abslolute Loader」，先做完 Loading 的工作之後，會將指定位址的程式碼對作業系統進行詢問( Allocation )，若該位址不可擺放，會對開發者丟出錯誤回報。 Cons Process 若要改變執行檔的起始位址，必須要重新對原始碼重新編譯，非常不便。 Note：通常用於 .com ( 作業系統命令檔 )。 Loading time 或 Linking loading time：由 Linking loader 或 Linkage editor 主導 Binding，也稱為 Static binding。 Compiler 所產生出的 Object code 稱為 「Relocatable object code」( 可重新定位目的碼 ) Pros 程式起始位址若要修改，只要重新做「Relocation loading」，而無須重新編譯。 Cons 程式充新執行時，若「Module ( 外部參考 )」的數量很多，則會花很多時間在「Re-linking」上。 Process 執行期間，不可以更改程式在記憶體的起始位址。 Execution time：由作業系統動態決定起始位址，也稱為 Dynamic binding。 決定 Process 起始位址之工作，延到執行時期 ( execution time )才動態執行，也就是說 Process 在執行期間可以任意變更起始位址且 Process 仍能正確執行。 需要硬體額外的支持。 Pros：Process 的起始位址可在執行期間任意更動且能正確地執行，有助於作業系統在記憶體管理上的彈性度，像是「Compaction」、「Process 的 Swap out 與Swap in」都很需要這種技術才能完美的執行。 Cons：需要硬體額外的支持；Process 在執行時需時較久，效能較差。 Relocation relocation Linking linking Relocation relocation_2 Dynamic relocation dynamicrelocation ＜補充＞ Relocation－修正：當程式執行起始位址改變，某些 Object code 內容必須隨之修正，才能正確執行。 當有採用「直接定址 ( Direct addressing mode )」指令時，當起始位址改變，就必須改變其地址。 Linking－修正：解決「外部參考 (External symbol reference)」之修正。 屬於「外部符號；外部參考」：副程式名稱、外部變數 ( entern )、函式庫 ( Librery )…。 「Linking loader」負責： Allocation：向作業系統要求起始位址。 Loading：將目的碼載入到記憶體之中。 Linking：依照編譯器所交辦的「Linking 修正資訊」，執行 Linking 修正。 Relocation：做重新定位的目的碼相關修正。 ＜Note＞凡是以「Static binding」的方式定位程式碼，皆無法在執行的期間更改該 Process 在記憶體的起始位址。 Relocatable object code relocatiableobjectcode 記憶體位址探討 Logical address：generateby CPU Phosical address：時竟去 Physical memory ( i.e. RAM ) 存取之位址。 若發生\(\left\{\begin{matrix} Logical\; address = physical\; address \Rightarrow Static\; binding \\ Logical\; address \neq physical\; address \Rightarrow {\left\{\begin{matrix} Dynamic\; binding \\ Page \\ Segement \\ Page—segement \end{matrix}\right.} \end{matrix}\right.\) 當電腦要將「Logical address」要轉成「Physical address」時，會交由硬體的 Memory Manegement Unit (MMU) 負責完成。( 不適合交給作業系統處理，因為一直不斷的中斷很浪費效能。 ) compilingflow Dynamic Loading 也稱為「Load-on-call」，在執行期間時，若「Mudule」真正被呼叫到而且不在記憶體中，則當下「Loader」才能將它載入到記憶體中。 Pros 節省記憶體空間。 不需要作業系統額外的支持。 Cons Process 執行的時間比較久。 ＜Note＞ 早期稱為「Overlay 結構」技巧，是開發人員的責任，而作業系統無介入管理。 現在的技術都已經交給作業系統提供的「虛擬記憶體 ( Vrtual memory )」。 Dynamic Linking 在執行期間時，若「Module」被呼叫到，才將之載入並且與其他「Module」進行「Linking - 修正」( 解決外部符號參考 )。 Pros 適用在「函式庫鏈結 ( Library linking )」，如：Dynamic linking library。 節省不必要的 Linking time。 Cons 需要作業系統的支援。 執行所需時間比較久。 Memory Allocation External Fragmentation 情形 在連續性配置的要求下，目前 AV-list 中任何一個 Hole 的大小均小於某個 Process 的大小，但是當這些 Holes 大小的加總時，卻大於等於 Process 大小，而這些零碎的可用記憶體空間因為不連續，所以仍然無法配置給 Process，這種情況就稱為「External Fragmentation」。 空閒空間不能使用，記憶體使用度低 ( Low memory utilzation )。 ＜Note＞ 一般而言，每當配置 N 大小的空間給 Process 時，會有大約 0.5N 的外部碎裂，所以外部碎裂的比例為 \(\frac{0.5 \times N}{N + 0.5 \times N} = \frac{1}{3}\) 稱為「One third rule」，顯現出外部碎裂是非常嚴重的問題。 解決方法 使用「Compaction ( 壓縮；聚集 )」技術 compaction 移動執行中的 Process，使得原本非連續的可用記憶體空間 ( Hole )，可以聚集形成一個夠大的連續可用的記憶體空間。 演算法難以實作 不易在最段時間制定最佳的 Compaction 策略。 Processes 必須為「Dynamic binding」才可於執行期間移動。(大多數程式傾向於 Static binding) ☆使用 Page Memory Management (分頁記憶體管理) 將「Physical memory」( RAM ) 視為一組 Frame (頁框) 的集合，且個各個 Frame size 相同。 注意：Frame size 是硬體決定，作業系統只是配合，Paging 使採用「Physical」的觀點。 「Logical memory」( User process 大小 ) 視為一組 Paging ( 頁面 )的集合，且 Page size 要使它等於 Frame size。 作業系統以「非連續性」的配置原則，即若 Process 大小等於 n 個 Pages ，則作業系統只需在「Physical memory」中找出n 個可用的頁框(不一定要連續)，即可配置給 Process。 作業系統會針對每一個 Processe 建立一個Page table ( 分頁表 )，紀錄各個 Page 實際置於哪個編號的頁框，當 Process 大小等於 n 個頁面，則他的分頁表就有 n 個 entry。 注意：分頁表被儲存於 PCB ( Process control block ) 之中。 圖示 paging Logical address 轉譯 physical address ( 使用 Memory Manegemeny Unit ) Logical address 初始是單一量，CPU 自動拆解成 p d(如下圖)，其中 P 代表分頁編號， d 代表 Page offset ( 偏移量 )。( Note：\(單一量位址 = Page\;size \times &quot;p&quot; + &quot;d&quot;\) ) 依據 P 查詢分頁表，取得該 Process 的頁框編號 f 。 f 與 d 合成為 f d (如下圖) 即為「Physical address」或 $ f Page ; size + d $。 logical2physicaladdress Pros 沒有外部碎裂問題。 可以支援記憶體共享( Memory sharing )與記憶體保護( Memory protection )的實施。 可支持 Dynamic loading 、Dynamic linking 與 Virtual memory 的實現。 Cons 由於 Process 的大小不一定會是分頁大小的整數倍數，所以會發生內部碎裂的問題 ( Internal fragementation )。 ＜Note＞：若分頁大小愈大，則內部碎裂愈嚴重。 需要額外的硬體支援。 分頁表的製作。 邏輯位址利用 MMU 轉換成實體位址。 因為要轉換記憶體位址，所以「Effective memory acess time」比較長( 與連續記憶體配置比相比)。 Memory sharing memorysharing 若多個 Process 彼此具有共通的唯讀分頁( Code、Data )，則我們可以藉由 Process 各自的分頁表將共通的分頁映射 到同一個頁框，如此可以節省記憶體空間。 Copy on write Memory protection 在分頁表中多加一個「Protection bit」欄位，\(\left\{\begin{matrix} R：Page \; 唯讀。 \\ W： Page \; 可以讀寫。 \end{matrix}\right.\) Multiple base/limit regisers (不建議) 拆解 Process 的記憶體為「Code section」與「Data section」，分開連續配置的空間 ( Hole ) ，以降低外部碎裂發生的機率(非解決外部碎裂為題)。 因為每個 Process 需要兩套的 Base 與 Limit 暫存器，分別記錄「Code section」與「Data section」的起始位址與大小。 Internal Fragmentation 情形 配置的記憶體空間超過 Process 大小，而該差值的記憶體空間無法給該 Process 使用，亦其他 Processes 無法使用，這種情況稱為「Internal Fragmentation」。 Contiguous Memory Allocation - 連續性記憶體配置 也稱為 Dynamic Variable Parition Memory Managememt ( 動態變動分區記憶體配置 )。 作業系統配置 Process 一個連續的可用記憶體空間 ( Free memory space )。 Dynamic Variable Parition Memory Managememt 名詞解釋 Partition ( 分區 )：Process 所占用的記憶體空間。 Partition 數量等價於「Process 數量」亦等價於「Multiprogramming Degree」。 不同時間點，系統內 Process 數量不固定，所以Partition 數量不固定而稱為「Dynamic」。 由於各個 Process 大小不盡相同，所以各個 Partition 大小也就不一定相同而稱為「Variable」。 記憶體中會有一些可用的記憶空間 ( Free memory space or Free memory block ) 稱之為「Hole」，通常作業系統會使用「鏈結串列」的概念管理 Holes ，稱為可用空間串列 ( Available list；AV-list )。 avlist 配置方法 First-fit：從 AV-list 的開頭找，直到找到第一個 Hole ，其大小大於等於 Process 的大小，即可配置之；若找完串列中，所有 Hole 沒有一個適合的則終止。 Best-fit：必須檢查 AV-list 中所有 Holes ，找出一個符合「其大小大於等於 Process 的大小」且「其大小與 Process 大小的差值為最小」的 Hole 配置給 Process。 Worst-fit：必須檢查 AV-list 中所有 Holes ，找出一個符合「其大小大於等於 Process 的大小」且「其大小與 Process 大小的差值為最大」的 Hole 配置給 Process。 Ex ( 依上圖 ) 有一 Process 為 90 K 則使用「First-fit」，會配置 （A） Block 之 90 K 給Process，剩下 210 K。 則使用「Best-fit」，會配置 （B） Block 之 90 K 給Process，剩下 10 K。 則使用「Worst-fit」，會配置 （C） Block 之 90 K 給Process，剩下 410 K。 比較表 綜合比較 時間效率 空間利用度 佳 First-fit 最佳 佳 Best-fit 差 最佳 Worst-fit 差 差 問題與討論 Ex Page size：10 kB Process 大小：32 kB \[ \because 需要配置 4 個分頁給 \;Process \\ \therefore 內部碎裂 = 4\times10 - 32 = 8 \;kB \] 分頁表的實現 使用暫存器保存分頁表 使用暫存器保存分頁表中每個 Entry 的頁框編號。 Pros 存取分頁表時無須記憶體存取，速度最快。 Cons 因為數量有限，不適合用於大型的分頁表( 大型 Process )。 使用記憶體保存分頁表 ( 不太採用 ) 用兩個個暫存器 ( PTBR；Page table base register 、PTLR；Page table length register ) 紀錄該分頁表位於記憶體中的位址與分頁表大小。 Pros 適用於大型分頁表。 Cons 需額外多一次的記憶體存取，所以速度很慢。 使用 TLB ( Translation lookasdie buffer ) 加速 使用 TLB ( Translation lookasdie buffer ) register ( or Associative register ) 保存分頁表中經常被存取之分頁編號與頁框編號，而完整的分頁表還是置於記憶體之中。 圖示 TLB 使用 TLB 的「Effective memory acess time」 = \(P \times ( TLB\; time + Memory \;acess \;time + (1-P) \times (TLB + 2 \times Memory \;acess \;time) )\) P 為 TLB 的 hit ratio。 問題 使用 TLB 之「Effective memory aceess time」 Ex Register acess time：0 ns ( ignored )。 Memory access time：200ns。 TLB time：100 ns TLB hit ratio：90% 求 Effective memory acess time 當分頁表儲存於： 暫存器：200 ns 記憶體：400 ns 記憶體、TLB 加速：\(0.9 \times (100 +200) + 0.1 \times (100 + 0.1\times200) = (100 + 200) + 0.1 \times 200\) = 320 ns。 Logical address 與 Physical address bit 數量計算 Page size = 1KB。 Process 最大有 8 個 Pages。 Physical memory 有 32 個 frames。 求取 Logical memory 需要多少 bits。 Physical memory 需要多少 bits。 Logical address 因為一個分頁大小為 1 KB 也就是 \(2^{32}\) bytes，所以 d 佔有 10 bits； Process 最多 8 個分頁也就是 \(2^3\) 個分頁，p 需要 3 個 bits 紀錄，所以需要 3 + 10 = 13 bits ( Logical )。 Physical memory 有 32 個頁框，也就是 \(2^5\) 個頁框， f 需要 5 個 bits 紀錄，所以總共需要 5 + 10 = 15 bits ( Physical )。 Page table 大小計算 Ex1 Page size = 8 KB。 Process 大小 = 2MB。 Page table entry 佔有 4 bytes。 求此 Process 的 Page table size。 一個 Process 中最多有 \(\frac{2 \; MB}{8 \;KB} = 2^8\) 個分頁，也就是說每個 Process 的分頁表都有 \(2^8\) 個 Entry ，所以分頁表大小為 \(2^8 \times 4 \; B = 1 \; KB\)。 Ex2 Logical address = 32 bit。 Page size = 16 KB。 Page table entry 佔有 4 B。 求 Max page table size。 一個 Process 中最多有 \(\frac{4 \; GB}{16 \;KB} = 2 ^{18}\) 個分頁，也就是說每個 Process 的分頁表都有 $2^{18} $ 個 Entry ，所以分頁表大小為 \(2^{18} \times 4 \;B = 1 \; MB\)。 承上，若 Logical address 改為 48 bit 。 一個 Process 中最多有 \(\frac{ 2^{48}\;B}{16 \;KB} = 2 ^{34}\) 個分頁，也就是說每個 Process 的分頁表都有 $2^{34} $ 個 Entry ，所以分頁表大小為 \(2^{34} \times 4 \;B = 64 \; GB\)。 ＜Note＞：Page table 太大。 Ex3 Page size = 16 KB Page table entry 佔有 4B Max page table size 恰為 one page。 求 Logical address length。 因為一個分頁表的大小為一個分頁的大小 ( 16 KB ) ，而一個 Page entry 的大小為 4 B ，所以總共會有 \(\frac{16\;KB}{4 \; B} = 4K\) entries (\(2^{12}\))，所以 p 為 12 bits，而每個分頁的大小為 16 KB (\(2^{14}\))所以 d 為 14 個 bits，最後羅技位址的長度為 12 + 14 = 26 bits。 解決 Page table size 過大的問題 下一節細述。 ☆處理過大分頁表 ☆☆Multilevel paging ( Hierarchical paging; Paging the page table; Forward mapping ) 並不是將分頁表縮小，而是將不需要的分頁表先存在磁碟之中，縮小分頁表在 RAM 佔有的空間，所以提出多層次的分頁，藉由此作法，不須將整個分頁表全部載入 RAM ，而是載入部分所需的內容，。 twolevelpaging Ex ( Two-level paging ) 下圖 Level-1 page table：有 \(2^x\) 個 Entries，每個 Enteries 記錄某個 level-2 page table 的指標 (位址)。 Level-2 page table：有 \(2^y\) 個 Entries，每個 Enteries 紀錄著頁框的編號。 可以將原本分頁表為 \(2^{x+y}\) 大小，拆成同樣可以記錄一樣多頁框編碼的 Multilevel page table (outer：\(2^x\), inner：\(2^y\)、total：\(2^x\times2^y\)) 雖然要記載頁框編號的分頁表容量(存於硬碟)變多，但是每次需載至 RAM 的容量大幅減少 (Process 在執行時，只需要一個 Level1-page table 與某一個 Level2-page table 在 RAM 中即可)。 twolevelpaging_2 Ex( Three-level paging ) threelevelpaging Cons Effect memory access time 更久：需要更多次的存取在記憶體的分頁表。 Ex two-level paging 需要 3 次的記憶體存取，three-level paging 需要 4 次的記憶體存取。 相關計算題 Ex1 TLB time：100 ns TLB hit ratio：80 % Memory access time：200 ns 採用 Two-level paging 求出 Effect memory access time 則 $ ( 100 ;ns+ 200 ; ns ) + 20％ (100 ; ns + 3 200 ; ns) = 420 ;ns$ Ex2 Logical address = 32 bits Page size = 4 kB Page table entry 佔有 4B 求 Max page table size Single-level paging 在 level-1 page table 與 level-2 page table 大小相等之下的 Two-level paging Single-level paging 因為 Page size 為 \(4 KB = 2^{12} B\) 所以會有 \(\frac{2^{32} B}{2^{12} B} = 1M \; entries\) ，而每個 Entry 佔有 4B，所以分頁表總量為 \(1 \;M \times 4 \;B = 4 \;MB\)。 Two-level paging 每次要抓入 RAM 的 Page table 大小為 \((1 \;K + 1 \; K) \times 4B = 8KB\)。 因為 Page size 為 \(4 KB = 2^{12} B\) 所以會有 \(\frac{2^{32} B}{2^{12} B} = 1M \; entries\) ，解著，將分頁表分成兩層，也就是 level 1 應有 \(2^{10}\) 個 entries ，level 2 也有 \(2^{10}\) 個 entries，但是總共有 \(2^{10}\) 個 level 2 page table，而每個 Entry 佔有 4B，所以分頁表總量為 \((1 \;M + 1K) \times 4 \;B = 4.004 \;MB\)。 ☆Ex 3 Logical address = 64 bits page size = 16 KB Page table entry 佔有 4 B 任一 level paging 之 Max page table size 頂多為一個分頁，則至少分幾層 (？-level paging)。 總共有 \(\frac{2^{64} \;B}{2^{14} \;B} = 2^{50} \;entries\) ，然而任一 level paging 之 Max page table size 頂多為一個分頁(16 K)，所以任一 level 之分頁表最多有 \(\frac{16 \; KB}{4 \;B} = 2^{12} entries\)，最後 \(\lceil \frac{50}{12} \rceil = 5 \;levels\) 所以最少可以分 2 層。 Hashing page table hashpagetable 利用雜湊的技巧將分頁表視為雜湊表，具有相同雜湊碼(位址)的分頁碼與它的頁框碼資訊會置於同一個 Entry ( bucket ) 中，且以「Link list」(chain) 串接。 一開始先將雜湊表(指標陣列) 載入到 RAM ，算完雜湊函數之後，將該雜湊串列載入至 RAM 中，最後，當 RAM 位址不夠時，可將先前載入 RAM 的串列移除。 Cons 在「Link list」中使用線性搜尋找尋符合的分頁編號是很耗時的工作。 相關計算題 Ex \(H(x) = x \;％\; 53\) Page table entry 佔有 4 B 求 Hashing Page table size？ 總共應有 53 個 Entries ，所以 \(53 \times 4 B= 212 B\)。 ☆Inverted page table ( 反轉分頁表 ) invertpagetable 以實體記憶體為記錄對象，並非以 Process ( 虛擬記憶體 ) 為對象，即若有 n 個頁框，則此表就有 n 個 entry，每個 entry 紀錄（Process id, Page no.）之配對資訊，代表這個頁框存放哪個 Process 之 Page相對於該分頁標號。 整個作業系統只需要一份表格( 不同的 Process 之間) 即可。 Cons 必須使用（Process id, Page no.）資訊一一比對查詢分頁表相當耗時。 ☆因為還需多比對「Process id」才能找到該頁框，所以當同時有兩個 Process 共享同一塊程式碼時，是必須要多使用一個 entry 來放置該對應的頁框碼，然而一個 entry 即是一個頁框，所以對應到同一塊位址的區塊會存於相異的頁框，無法實現「Memory sharing 」的功能。( 下圖 ) invertpagetable2 相關計算題 Ex Page size = 8 KB Physical memory = 16 KB Page table entry 佔有 4 B 求 Inverted page table size？ 現在有 \(\frac{16\;GB}{8\;KB} = 2\;M \;entries\)，也就是有 2 M 個頁框，所以 Inverted page table 大小為 \(2 \;M \times 4 \;B = 8 MB\)。 Segement memory management segementation 將實體記憶體視為一個夠大的連續可用空間。 將邏輯記憶體 ( Process ) 視為一組 Segement 的集合，且各 Segement 大小不一定相同。 CPU 以「Logical address」看待該 Process 的所有 Segement。( User 相對於 RAM ) Code segement、Data segement、Stack segement … 配置原則 Segement 之間可以是非連續性記憶體配置。 每一個 Segement 必須占用連續的記憶體空間。 作業系統會替每個 Process 建立分段表 (Segement table)，紀錄每個 Segement 的大小( limit )與起始位址( Base )。 邏輯位址轉換實體位址。 邏輯位址有兩個變量 ( 變量為獨立不相關，因為不同分段之間大小不等 )。 s：分段編號 d：該分段的偏移量 ( offset ) 依照 s 在分段表查找，取得該分段的大小與起始位址。 必須檢查偏移量是否小於該分段大小。 若成立則將該實體位址返回給正在執行的 Process。( Physical address = base + d ) 若不成立則「MMU」會產生一個非法存取的 exception 給作業系統，將該 Process 終止。 Pros 沒有內部碎裂。 可以支持「Memory sharing」與「Memory protection」。 可以支持「Dynamic loading」、「Dynamic linking」與「Virtual memory」的實現。 因為 Segement 以邏輯位址查找，比起「Paging」更容易實現「Memory sharing」與「Memory protection」。 以 Protection 為例： 分段 segementprotection 分頁 ( Page size = 100 K ) pageprotection segementhw Cons 有外部碎裂。 需要有額外硬體的支持。 分段表的保存。 邏輯位址轉換需要「MMU」 的協助。 Effective memory access time 更久。 需檢查分段偏移量是否小於該分段大小。 相關計算題 Limit Base 0 100 4200 1 500 80 2 830 7300 3 940 1000 Ex 給一分段表如上圖，求出下列相對於該邏輯位址的實體位址為多少？ （1）(0, 90) （2）(1, 380) （3）(2, 900) （4）(3, 940) Ans： （1）4290 （2）460 （3）非法存取 （4）非法存取 分頁分段比較表 Page Segement 各個 Page size 均同 各個分段大小不一定相同 以「Physical address」的觀點處理 以「Logical address」的觀點處理 無外部碎裂，有內部碎裂 有外部碎裂，無內部碎裂 「Memory protection」與「Memory sharing」較難以實施 「Memory protection」與「Memory sharing」較容易以實施 無須檢查分頁偏移量 需要檢查分段偏移量 邏輯位址為「單一變量」 邏輯位址為「雙變量」(分段編號、分段偏移量) 分頁表紀錄「頁框編號」 分段表紀錄分段的「起始位址」與「大小」 ☆Page segement memory management (分頁式分段) \[ Process \rightarrow Segement \rightarrow Page \] segementpaging 希望保有分段的優點「Logical viewpoint」，並解決外部碎裂，所以先將 Process 先分段再分頁。 結論 Continue allocation Page Segement Page segement 外部碎裂 有 無 有 無 內部碎裂 無 有 無 有]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Recurrence]]></title>
    <url>%2Fwillywangkaa%2F2018%2F09%2F01%2FAlgorithm-Recurrence%2F</url>
    <content type="text"><![CDATA[Recurrence ＜外傳＞ 某些問題隨輸入資料大小成指數成長是無法避免的 雖然「Divide-and-conquer」無法獲致良好的執行效率但仍可採用 河內塔問題 每呼叫一次就需搬動圓盤一次 當圓盤的個數 n 為 64 總共需要搬動圓盤 \(2^{64}-1\) 次 演算法的複雜度等級是 \(O(2^n)\) 河內塔問題圓盤搬動次序與 n 成指數關係 經過証明，上述河內塔問題的演算法 為該問題的限制下最佳的演算法 Substitution method Concept 以經驗猜測一個邊界(bound)。 假設子問題符合此邊界，證明母問題也符合此邊界。 適用時機 題目比分重。 單向；單邊：只需要證明 \(O, \Omega\) 單向，不必證明 \(\Theta\) 。 題目要求。 經典範例 Example - \(T(n) = 2 T(\lfloor\frac n2\rfloor)+n\)，\(T(n) = O(？)\) （Substitution method）猜：\(T(n) = O(n \lg n)\) 已知 \(g(n) = 2 g(\frac n2)+n = O(n\lg n)\) 欲證 \(T(n) = O(n \lg n)\)，即證明 \(\exists C, n_0&gt;0 \ni n \geq n_0, T(n) \leq C \cdot n\lg n\) 假設子問題 \(T(n) \leq C \cdot \lfloor\frac n2\rfloor\lg \lfloor\frac n 2\rfloor\) 成立 考慮 \(T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq 2 \cdot C \cdot \lfloor\frac n2\rfloor\lg \lfloor\frac n2\rfloor+n\) \(\Rightarrow T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq 2 \cdot C \cdot \frac n2\lg \frac n2+n\) \(\Rightarrow T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq C \cdot n(\lg n - \lg2)+n = C \cdot n\lg n + (1 - C)n\) 取 \(C \geq 2, T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq C \cdot n \lg n\) \(\therefore T(n) = O(n\lg n)\) Example（97成大資工） - 解 \(T(n) = 2T(\lfloor \sqrt n \rfloor)+\lg n\), 用 O 表示 - （比分重、單邊、\(\lfloor\rfloor\)） - 考慮使用「Substitution method」而不使用疊代法 \(\lg n \lg \lg n\) Recurrence tree 名詞解釋 \(T(n) = T(\frac n3)+T(\frac 23 n) + n\) \(r = \frac 13+\frac 23 = 1\)：子問題的 n 係數的相加。 \(T(n)\)：母問題。 \(T(\frac n3), T(\frac 23n)\)：子問題。 \(n\)：Cost，將子問題合併的代價。 適用時機 子問題個數大於二 子問題型態為\(T(\frac n a)\) 經典範例 tree_1 \(r &lt; 1\) Ex ( 94 成大資工 ) \(T(n) = T(\frac n2) + T(\frac n4) + T(\frac n8) + n\)，求 \(\Theta\) Sol \(r = \frac n 2 + \frac n 4 + \frac n 8 = \frac 7 8 &lt; 1\) 建立遞迴樹 \(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l\) (等比級數) 求取其邊界 (夾擠法) 求上邊界：\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \leq n + \frac 78 n +\frac{49}{64}n + \ldots + (\frac 78)^h\) (有限等比級數小於無限等比級數) \(\Rightarrow \frac{n}{1 - \frac 7 8} = 8 n \Rightarrow T(n) = O(n)\) 求下邊界：\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \geq n \Rightarrow T(n) = \Omega(n)\) \(\Rightarrow T(n) = \Theta(n)\) tree_1 \(r = 1\) Ex (100 政大)(90 ,91 台大) \(T(n) = T(\frac n3) + T(\frac 23) + n\) Sol \(r = \frac 13+\frac{2}{3} = 1\) 建立遞迴樹 \(T(n) = n+n+n+\ldots+C_l\) 求取其邊界 求上邊界：因為\((\frac23)^k*n= 1 \Rightarrow k = \log_{\frac32}n \Rightarrow 高度 = k + 1\) ，所以\(T(n) = n+n+n+\ldots+C_l \leq n \cdot \log_{\frac32}n+1\) \(\Rightarrow T(n) = O(n\log n)\) br&gt;求下邊界：\(T(n) = n+n+n+\ldots+C_l \geq n \cdot \log_3n + 1\) \(\Rightarrow T(n) = \Omega(n\log n)\) \(\Rightarrow T(n) = \Theta(n\lg n)\) \(r &gt; 1\) 無，因為子問題的數量比母問題大。 Master theorem 令 \(T(n) = aT(\frac{n}{b})+f(n), a \geq 1, b &gt; 1\) 。 若 \(\exists \epsilon &gt; 0 \ni f(n) = O(n^{\log_ba-\epsilon})\) ，則 \(T(n) = \Theta(n^{\log_ba})\)。 若 \(\exists \epsilon &gt; 0, 0 &lt; c &lt; 1 \ni f(n) = O(n^{\log_ba+\epsilon}) \;and\; af(\frac nb) &lt; cf(n)\)，則 \(T(n) = \Theta(f(n))\)。 ☆若 \(f(n) = \Theta(n^{\log_ba}\cdot \lg^kn), k \geq 0\)，則 \(T(n) = \Theta(n^{\log_ba}\cdot\lg^{k+1}n)\) (與 f(n) 相差 \(lg\) 的次方)。 經典例題 Ex ( 100 政大 ) \(T(n) = 7T(\frac n2) + n^2\) sol By master theorem \(\Rightarrow \exists \epsilon = \lg 7 - 2 \ni n^2 = O(n^{\log_27-\epsilon})\)，所以\(T(n) = \Theta(n^{\lg 7})\)。 Ex ( 99 交大 ) \(T(n) = 3T(\frac n4) + n\lg n\) sol By master theorem \(\Rightarrow n^{log_43} = n^{1-\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)\(\Rightarrow n\log n = \omega(n) = \omega(n^{1-\epsilon})\)，所以\(T(n) = \Theta(n\log n)\)。 Ex ( 98 交大 ) \(T(n) = 3T(\frac n2)+ n \lg n\) sol By master theorem \(\Rightarrow n^{log_23} = n^{1+\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)\(\Rightarrow n\log n = o(n^{1+\epsilon})\)，所以\(T(n) = \Theta(n^{\log_23})\)。 \(T(n) = 4T(\frac n2) + n\lg n\) sol By master theorem \(\Rightarrow n^{log_24} = n^2\)\(\Rightarrow n^{2} = \omega(n\log n)\)，所以\(T(n) = \Theta(n^2)\)。 ＜Note＞ ☆ 與 \(f(n)\) 比較，\(f(n)\) 多了\(\frac{1}{\lg n}\) $T(n) = 4 T(n2) + $ sol 不可使用 Master Theorem。 \(n^{\log_ba = n^2}, f(n) = \frac{n^2}{\lg n} \Rightarrow T(n) = n^2\lg \lg n\) ＜Note＞ ☆ 與 \(f(n)\) 比較，\(f(n)\) 多了\(\frac{1}{\lg^a n} , a &gt; 1\) 直接為 \(O(n^{\log_ab})\) 進階遞迴問題 Ackermann’s function \[ \left\{\begin{matrix} A(0, n) &amp; = &amp; n+1 &amp; (1)\\ A(m , 0) &amp; = &amp; A(m-1, 1) &amp; (2)\\ A(m , n) &amp; = &amp; A(m-1, A(m, n-1)) &amp; (3) \end{matrix}\right. \] 求取 \(A(1, n)\) 的通解 \[ \begin{matrix} 令 \; a_n &amp;=&amp; A(1, n) &amp; \\ &amp; = &amp; A(0, A(1, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(0, a_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; a_{n-1} + 1 &amp; By \; (1) \\ \end{matrix} \] 且 \[ a_0 = A(1, 0) = A(0, 1) = 2 \] 所以 \[ \begin{matrix} a_n &amp; = &amp; a_{n-1} + 1 \\ &amp; = &amp; (a_{n-2} + 1) + 1 \\ &amp; = &amp; ((a_{n-3} + 1) + 1) + 1 \\ &amp; \ldots &amp; \\ &amp; = &amp; a_0 + \sum_{i = 1}^{n-1} + 1 \\ &amp; = &amp; 2 + n &amp; \forall n \geq 0 \end{matrix} \] 求取 \(A(2, n)\) 的通解 \[ \begin{matrix} 令 \; b_n &amp;=&amp; A(2, n) &amp; \\ &amp; = &amp; A(1, A(2, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(1, b_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; a_{b_{n-1}} &amp; By \; 第一題結論 \\ &amp; = &amp; b_{n-1} + 2 \\ &amp; = &amp; (b_{n-2} + 2) + 2 \\ &amp; = &amp; ((b_{n-3}+2) + ) + 2 \\ &amp; \ldots &amp; \\ &amp; = &amp; b_0 + \sum_{i = 1}^{n-1}2 + 2 \\ &amp; = &amp; b_0 + 2n &amp; b_0 = A(2, 0) = A(1, 1) = a_1 = 3\\ &amp; = &amp; 2n + 3 &amp; \forall n \geq 0 \end{matrix} \] 求取 \(A(3, n)\) 的通解 \[ \begin{matrix} 令 \; c_n &amp;=&amp; A(3, n) &amp; \\ &amp; = &amp; A(2, A(3, n-1)) &amp; By\;(3) \\ &amp; = &amp; A(2, c_{n-1}) &amp; By\; 自定義的a_n\\ &amp; = &amp; b_{c_{n-1}} &amp; By \; 第一題結論 \\ &amp; = &amp; 2c_{n-1} + 3 \end{matrix} \] 先求出 \(c_0 = A(3, 0) = A(2, 1) = b_1 = 5\) ，再來 \(c_n\) 特徵多項式為 \(\alpha - 2= 0 \Rightarrow \alpha = 2\)，所以令齊次解為 \(c_n^{(h)} = C_0\times2^n\)，接著 \(c_n\) 的特解為 \(c_n^{(p)} = C_1\times (1)\) 代回求 \(C_1\) \[ \begin{matrix} \Rightarrow C_1 = 2\times C_1 + 3 \\ \Rightarrow C_1 = -3 \\ \therefore c_n = c_n^{h} + c_n^{(p)} = C_0\times2^n - 3 \\ c_0 = 5 = C_0 - 3 \\ \Rightarrow C_0 = 8 \\ \therefore c_n = 2^{n+3} - 3, \forall n \geq 0 \end{matrix} \] Strassen 演算法（分治矩陣乘法） 長久以來人們普遍認為矩陣乘法定義本身即為最佳的算法，這個迷思直到1969年才被施特拉森打破──他提出了一個更快捷的分治（Divide-and-conquer）矩陣乘法，為 Strassen 演算法 給定兩個方陣 A、B 其大小均為 n×n n = 2k 若 n 非 2 的冪次方 可將 A 和 B 擴充為 \(\begin{bmatrix} A&amp;0\\ 0&amp;I \end{bmatrix}\) 和 \(\begin{bmatrix} B&amp;0\\ 0&amp;I \end{bmatrix}\) 考慮 2×2 階分塊矩陣乘法 \(\begin{bmatrix} C_{11}&amp;C_{12}\\ C_{21}&amp;C_{22} \end{bmatrix}=\begin{bmatrix} A_{11}&amp;A_{12}\\ A_{21}&amp;A_{22} \end{bmatrix}\begin{bmatrix} B_{11}&amp;B_{12}\\ B_{21}&amp;B_{22} \end{bmatrix}\) 傳統矩陣乘法 \(C_{ij}=A_{i1}B_{1j}+A_{i2}B_{2j}\) 1549349573405 \(C_{11} = A_{11}B_{11} + A_{12}B_{21} \\ C_{12} = A_{11}B_{12} + A_{12}B_{22} \\ C_{21} = A_{21}B_{11} + A_{22}B_{21} \\ C_{22} = A_{21}B_{12} + A_{22}B_{22}\) 遞迴式為：\(T(n) = 8T(\frac n2) + cn^2\) 8 個分塊矩陣乘法 4 個分塊矩陣加法 \(cn^2\Rightarrow 3\times2^2\) 「Master theorem」 \(T(n) = \Theta(n^3)\) Strassen 演算法 \(\begin{aligned} P_1&amp;=(A_{11}+A_{22})(B_{11}+B_{22})\\ P_2&amp;=(A_{21}+A_{22})B_{11}\\ P_3&amp;=A_{11}(B_{12}-B_{22})\\ P_4&amp;=A_{22}(B_{21}-B_{11})\\ P_5&amp;=(A_{11}+A_{12})B_{22}\\ P_6&amp;=(A_{21}-A_{11})(B_{11}+B_{12})\\ P_7&amp;=(A_{12}-A_{22})(B_{21}+B_{22})\\ C_{11}&amp;=P_1+P_4-P_5+P_7\\ C_{12}&amp;=P_3+P_5\\ C_{21}&amp;=P_2+P_4\\ C_{22}&amp;=P_1+P_3-P_2+P_6 \end{aligned}\) 遞迴式為：\(T(n) = 7T(\frac n2) + cn^2\) 7 個分塊矩陣乘法 18 個分塊矩陣加法 「Master theorem」 \(T(n) = \Theta(n^{\log_27}) \approx \Theta(n^{2.807})\) 根據 2000 年的硬體架構 矩陣尺寸必須超過1000，Strassen 演算法才可能擊敗經過高度優化的傳統算法 即便矩陣尺寸增大至 10000 相較於傳統算法 Strassen 演算法所能提昇的運算效率依然十分有限（約小於10%） 算法推導 考慮 2×2 階矩陣 \(\begin{bmatrix} w&amp;x\\ y&amp;z \end{bmatrix}=\begin{bmatrix} a&amp;b\\ c&amp;d \end{bmatrix}\begin{bmatrix} p&amp;q\\ r&amp;s \end{bmatrix}\) 乘開後 \(\begin{aligned} w&amp;=ap+br\\ y&amp;=cp+dr\\ x&amp;=aq+bs\\ z&amp;=cq+ds \end{aligned}\) 將四個式子合併成矩陣表達式 \(\begin{bmatrix} w\\ y\\ x\\ z \end{bmatrix}=\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}\begin{bmatrix} p\\ r\\ q\\ s \end{bmatrix}\) 欲將 4×4 階的矩陣分解成數個矩陣之和以減少乘法運算 分解出來的矩陣至多僅含4個非零元，且所有非零元都位於一 2×2 階子陣 如：\(\begin{bmatrix} \ast&amp;\ast&amp;0&amp;0\\ \ast&amp;\ast&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix} 、\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;\ast&amp;0\\ 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;\ast&amp;0 \end{bmatrix}、\begin{bmatrix} \ast&amp;0&amp;0&amp;\ast\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;0&amp;\ast \end{bmatrix}\) 考慮三種分解型態 型態 I 子陣有相同的元 需要一個乘法運算 \(\begin{bmatrix} a&amp;a\\ a&amp;a \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} a(u+v)\\ a(u+v) \end{bmatrix}\) 型態 II 子陣的元有相同的絕對值 兩行或兩列不同號 需要1個乘法運算 \(\begin{bmatrix} a&amp;-a\\ a&amp;-a \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} a(u-v)\\ a(u-v) \end{bmatrix}\) 型態 III 子陣為上或下三角矩陣 （非零）非主對角元等於兩主對角元之差 需要2個乘法運算 \(\begin{bmatrix} a&amp;0\\ a-b&amp;b \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} au\\ au+b(v-u) \end{bmatrix}\) 可分解為兩個退化的型態 I和型態 II（退化是指存在零行或零列） \(\begin{bmatrix} a&amp;0\\ a-b&amp;b \end{bmatrix}=\begin{bmatrix} a&amp;0\\ a&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0\\ -b&amp;-b \end{bmatrix}\) 分解矩陣製造型態 I和型態 II \(\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}=\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}+\begin{bmatrix} a+d&amp;b-d&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;c-a&amp;a+d \end{bmatrix}\) 等號右邊的第一個矩陣 \(\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}\) 令 \(M_1\) 表示上式等號右邊的第二個矩陣 觀察發現 $(M_1){11}=(M_1){44}=a+d $ \(M_1=\begin{bmatrix} a+d&amp;0&amp;0&amp;a+d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ a+d&amp;0&amp;0&amp;a+d \end{bmatrix}+\begin{bmatrix} 0&amp;b-d&amp;0&amp;-(a+d)\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ -(a+d)&amp;0&amp;c-a&amp;0 \end{bmatrix}\) 令 \(M_2\) 表示上式等號右邊的第二個矩陣 觀察發現 \(M_2\) 可分解成兩個型態 III \(M_2=\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ (c-a)-(c+d)&amp;0&amp;c-a&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;b-d&amp;0&amp;(b-d)-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\) 等號右邊的第一個矩陣 \(\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ -(c+d)&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ c-a&amp;0&amp;c-a&amp;0 \end{bmatrix}\) 等號右邊的第二個矩陣 \(\begin{bmatrix} 0&amp;b-d&amp;0&amp;b-d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\) 整理所有的分解矩陣，按照「Strassen 演算法」給定的排序 \(\begin{aligned} \begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}&amp;=\begin{bmatrix} a+d&amp;0&amp;0&amp;a+d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ a+d&amp;0&amp;0&amp;a+d \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ -(c+d)&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}+\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;0&amp;0&amp;-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ c-a&amp;0&amp;c-a&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;b-d&amp;0&amp;b-d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix} \end{aligned}\) 可以表示為「行列展開」的矩陣乘法 \(\displaystyle\begin{aligned} \begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}&amp;=\begin{bmatrix} 1\\ 0\\ 0\\ 1 \end{bmatrix}(a+d)\begin{bmatrix} 1&amp;0&amp;0&amp;1 \end{bmatrix}+\begin{bmatrix} 0\\ 1\\ 0\\ -1 \end{bmatrix}(c+d)\begin{bmatrix} 1&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0\\ 0\\ 1\\ 1 \end{bmatrix}(a)\begin{bmatrix} 0&amp;0&amp;1&amp;-1 \end{bmatrix}+\begin{bmatrix} 1\\ 1\\ 0\\ 0 \end{bmatrix}(d)\begin{bmatrix} -1&amp;1&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} -1\\ 0\\ 1\\ 0 \end{bmatrix}(a+b)\begin{bmatrix} 0&amp;0&amp;0&amp;1 \end{bmatrix}+\begin{bmatrix} 0\\ 0\\ 0\\ 1 \end{bmatrix}(c-a)\begin{bmatrix} 1&amp;0&amp;1&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 1\\ 0\\ 0\\ 0 \end{bmatrix}(b-d)\begin{bmatrix} 0&amp;1&amp;0&amp;1 \end{bmatrix} \end{aligned}\) \(\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}\) 乘上\(\begin{bmatrix} p\\ r\\ q\\ s \end{bmatrix}\) \(\begin{aligned} \begin{bmatrix} w\\ y\\ x\\ z \end{bmatrix}&amp;=\begin{bmatrix} 1\\ 0\\ 0\\ 1 \end{bmatrix}(a+d)(p+s)+\begin{bmatrix} 0\\ 1\\ 0\\ -1 \end{bmatrix}(c+d)(p)\\ &amp;+\begin{bmatrix} 0\\ 0\\ 1\\ 1 \end{bmatrix}(a)(q-s)+\begin{bmatrix} 1\\ 1\\ 0\\ 0 \end{bmatrix}(d)(-p+r)\\ &amp;+\begin{bmatrix} -1\\ 0\\ 1\\ 0 \end{bmatrix}(a+b)(s)+\begin{bmatrix} 0\\ 0\\ 0\\ 1 \end{bmatrix}(c-a)(p+q)\\ &amp;+\begin{bmatrix} 1\\ 0\\ 0\\ 0 \end{bmatrix}(b-d)(r+s) \end{aligned}\) \(\begin{bmatrix} a&amp; b&amp; c&amp; d \end{bmatrix}\) 代 \(\begin{bmatrix} A_{11}&amp; A_{12}&amp; A_{21}&amp; A_{22} \end{bmatrix}\) \(\begin{bmatrix} p&amp; q&amp; r&amp; s \end{bmatrix}\) 代 \(\begin{bmatrix} B_{11}&amp; B_{12}&amp; B_{21}&amp; B_{22} \end{bmatrix}\) \(\begin{bmatrix} w&amp; x&amp; y&amp; z \end{bmatrix}\) 代 \(\begin{bmatrix} C_{11}&amp; C_{12}&amp; C_{21}&amp; C_{22} \end{bmatrix}\) 即為「Strassen 演算法」 補充例題 Example（100 交通大學資料結構與演算法） Let d and k be two non-negative integers, where k &gt; d ≧ 0. A dk-binary sequence is a binary sequence that satisfies the following two constraints： d constraint：two 1’s are separated by a run of consecutive 0 of length at least d k constraint：any run of consecutive 0’s is of length at most k For example, 010010001001 is a dk-binary sequence of length 12 width d=0 and k=3. Let n indicate the length of dk-binary sequence Given n=6, d=0, k=6, then how many dk-binary sequences are there? （A）8 （B）16 （C）32 （D）64 （E）128 由 0、1 組成長度為六的字串個數 \(\Rightarrow 2^6\) Given n=10, d=4, k=5, then how many dk-binary sequences are there? （A）8 （B）6 （C）12 （D）10 （E）11 （參考：Re: [理工] [DS&amp;algo] 100交大） 在序列中有 0 個 1 不可能發生 在序列中有 1 個 1 0000010000 0000100000 在序列中有 2 個 1（兩個 1 最多只能將序列切成 3 段） 轉換題目成整數分割 字串長度為 10 兩個位子置 1 剩下 8 個位子置 0 必須有連續 4 個零或 5 個零出現 在序列中有連續 4 個 0（必有連續 4 個 0 出現，則必有一個 4 在此整數分割） 8=4+4’ 序列：0000100001 8=4+3+1 序列：0001000010 8=4+2+2 序列：0010000100 8=4+1+3 序列：0100001000 8=4’+4 序列：1000010000 有連續5個零的狀況 8=5+3 序列：0001000001 8=5+2+1 序列：0010000010 8=5+1+2 序列：0100000100 8=3+5 序列：1000001000 Given n=14, d=1, k=14, then how many dk-binary sequences are there? （A）81 （B）160 （C）821 （D）987 （E）1024 由 0、1 組成長度為十四且 1 不得連續出現的字串個數 \(a_n = a_{n-1}+a_{n-2}\) \(a_1 = 2、a_2 = 3\) \(a_{14} = 987\)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recurrence</tag>
        <tag>Ackermann</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm - Time Complexity]]></title>
    <url>%2Fwillywangkaa%2F2018%2F08%2F28%2FAlgorithm-Time-Complexity%2F</url>
    <content type="text"><![CDATA[Time complexity 重點 Asymptotic notation 考點著重 定義 特性 證明題、選擇題 Time complexity 的比較 定義法 極值法 ( limit )：以大資料的手法比較演算法的優劣 對數法 ( log )：當該算法的等級差距大時方便判斷與解釋 計算題要點 ( 離散數學 ) \(H _n = \Theta(\lg n)\) \(\log (n !) = \Theta (n \lg n)\) \(( \log_a n )^b = o (n ^k), k &gt; 0\) Asymptotic notation 當輸入資料變大時，程式執行的時間以何種趨勢成長 符號定義 \(f(n) = O(g(n))\) \(\exists C, n_0 &gt; 0 , \ni f(n) \leq C \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic upper bound f(n) 的 Order 會小於 g(n) 的 Order $f(n) = (g(n)) $ \(\exists C , n_0 &gt; 0 \ni f(n) \geq C \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic lower bound f(n) 的 Order 會大於 g(n) 的 Order $f(n) = (g(n)) $ \(\exists C_1 , C_2, n_0 &gt; 0 \ni C_1 \times g(n) \leq f(n) \leq C_2 \times g(n) , n \geq n_0\) 稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic tight bound f(n) 的 Order 會等於 g(n) 的 Order $f(n) = o (g(n)) $ 以比較 Order 的上面來看，是絕對小於的意義 用極值法的方式方便解釋 Ex：true or false \(n = o(2n)\)：false \(n = o(n^2)\)：true \(n = O(2n)\)：true $n = O(n^2) $：true \(f(n) = \omega(g(n))\) 以比較 Order 的上面來看，是絕對大於的意義 用極值法的方式方便解釋。 \(2n = \omega(n)\)：false \(n^2 = \omega(n)\)：true ＜Note＞ ？若固定 \(g(n)\)，可以將所有函數作以下分類： Ex：\(g(n) = n^3\) 考古題 ( 99政大資料科學 ) Q 寫出 2 個在 \(O(n^3)\) 中但不在 \(o(n^3)\) 的函數 A 題目亦等於在問舉出兩個函數在 \(\Theta(n^3)\) 的函數 ，所以 \(f(n) = n^3、2n^3\) 考古題 ( 100 交大 ) Q NCTU：\(\Theta(n)\)、CS：\(\Omega(n)\) 下列何者正確？ （a） NCTU 總是比 CS 快 （b） 當 n \(\geq\) 1000000000000 時 NCTU 比 CS 快 （c） 兩者執行時間相同 （d） 稱 CS 的複雜度為 \(\Theta(n)\) （e） 以上皆非 A （e） 特性 \(f(n) = O (g(n)) \Rightarrow f(n)+g(n) = O(g(n))\) Ex (98 交大資工) \(P(n) = \sum_{i = 0}^{d} a_in^i\) 是 d 次多項式，下方表格何者正確？ 是否屬於右側集合 \(O(n^k)\) \(o(n^k)\) \(\Omega(n^k)\) \(\omega(n^k)\) \(\Theta(n^k)\) P(n) \(k&gt;d\) true true P(n) \(k &lt; d\) true true P(n) \(k = d\) true true true Ex (98 交大資工) 寫出 \(O(n^2) + \Theta(n^2)\) 最適合的等級 (理解： \(\exists f(n) \in O(n^2) , \exists g(n) \in \Theta(n^2) \quad f(n) + g(n) \in ？\)) \[ O(n^2) + \Theta(n^2) = \Theta(n^2) \] Ex (100 中央) Prove or disprove：\(f(n) + g(n) = \Theta(\;max｛f(n), g(n)｝)\) Proof：(以定義證明) \[ \exists C_1 = 1, C_2 = 2, n_0 = 1 \\ \ni n \geq n_0, C_1(\;max｛f(n), g(n)｝) \leq f(n) + g(n) \leq C_2(\;max｛f(n), g(n)｝) \] \(f(n) = O(g(n)) 且 f(n) = \Omega (g(n)) \Leftrightarrow f(n) = \Theta(g(n))\) Ex (95 台大資工) (離散數學) Q \(\sum_{i = 0}^n i^5 = \Theta(n^a), a = ？\) A Prove：\(\sum_{i = 0}^n = O(n^6)\) Prove：\(\sum_{i = 0}^n = \Omega(n^6)\) 函數比較等級 L’Hôpital’s rule 的使用 若 \(\lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}\) 是不定型 (相除為 0 或 無限大)，則該函數等於 \(\lim_{n\rightarrow\infty}\frac{f&#39;(n)}{g&#39;(n)}\) \((\ln x)&#39; = \frac{1}{x}\) log n 的底只要是常數其等級均相同。 Ex \(\ln n, \lg n, \log n, \log_{100}n\)等級均相等 定義法 適用時機 題目分數多。 函數的型態簡單帶值可算。 Ex (96 成大資工) True or false (10%) Q \(n^2 + n\lg n + \frac{n}{2} = O(n^8)\) A \(\exists C = 5, n_0 = 10\ni n\geq n_0, n^2 + n \lg n + \frac{n}{2} \leq c \times n^8\) Ex (91 交大資工) Prove the following is incorrect Q \(\frac{n^2}{\log n} = \Theta(n^2)\) A (矛盾證明法) \(\frac{n^2}{\log n} = \Theta(n^2) \Rightarrow \frac{n^2}{\log n} = O(n^2), \frac{n^2}{\log n} = \Omega(n^2)\) ，後者明顯錯誤所以從後者開始證明。 設\(\frac{n^2}{\log n} = \Omega(n^2)\)成立，則 \(\exists C, n_0 &gt; 0 \ni n &gt; n_0, \frac{n^2}{\log n} \geq C \times n^2\) \(\Rightarrow \frac{1}{\log n} \geq C (\rightarrow\leftarrow)\)，當 \(n\) 成長時\(\frac{1}{\log n}\) 會無限靠近 0 ，導致不存在 C &gt; 0 所以矛盾。 Ex (100 中央資工) Prove or disprove \(f(n) = \Theta(g(n)) \Rightarrow h(f(n)) = \Theta(h(g(n)))\)，其中 \(h(*)\) 為遞增函數。 false， 直接舉例 \(f(n) = 2n, g(n) = n \Rightarrow f(n) = \Theta(g(n))\) 而取 \(h(n) = 2^{n}\) 為遞增函數，但 \(h(f(n)) \ne O(h(g(n)))\) 極值法 適用時機 函數型態複雜，但可藉由微分使之容易分析。 證明 \(o, \omega\) 時可當作該集合之定義以分析。 使用方法 \(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = 0 \Leftrightarrow f(n) = o(g(n))\) \(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \infty \Leftrightarrow f(n) = \omega(g(n))\) $ L &gt; 0 ;is ;constant _{n} = L f(n) = (g(n))$ Ex \(f(n) = \log_34n, g(n) = \log_43n\)，問 \(f(n)\) 在 \(g(n)\) 的會在哪個等級集合 (\(O, \Omega, \Theta\)) 之中？ \(\lim_{n\rightarrow\infty}\frac{log_34n}{\log_43n} =_{微分} \lim_{n\rightarrow\infty}\frac{(\frac{\ln 4n}{\ln3})&#39;}{(\frac{\ln 3n}{\ln 4})&#39;}\) \(\Rightarrow lim_{n \rightarrow \infty} \frac{ \frac{4}{4n\ln3} }{\frac{3}{3n\ln4}} \Rightarrow \frac{\ln4}{\ln3}\) 為常數，所以 \(f(n) = \Theta ,\Omega , O (g(n))\)。 Ex ( 96 成大資工 ) (10%) True or false \(n^b = o(a^n)\), 其中 \(a &gt; 1, b \in \mathbb{R}\) true，\(\lim_{n\rightarrow \infty} \frac{n^b}{a^n} =_{兩邊取微分} \lim_{n\rightarrow \infty} \frac{b \times n^{b-1}}{\ln a\times a^n} = \ldots = \lim_{n\rightarrow\infty} \frac{b!}{(\ln a)^n\times a^n} = 0\) 所以正確。 Ex ( 98 台大電機 ) true or false 對任何正數 a, b 而言 \(n^b = o(a^n)\) 。 False，陷阱！因為題目只有說 a, b 為正數而非正整數，所以當 a 為分數時，此命題錯誤。 對數法 適用時機 題目分數少的計算題。 函數為指數函數型態。 函數為階乘型態。(\(\log n! = \Theta(n\log n)\)) 定義 \(\log(f(n)) = o, \omega(\log(g(n))) \Rightarrow f(n) = o, \omega (g(n))\) 而 \(\log(f(n)) = \Theta(\log(g(n)))\) 則無法判斷等級，因為等級過於相同 ，取對數後無法判斷，要使用別的方法。 Ex 比較 \(f(n) = 1.1^{0.01n}, g(n) = n^{100}\) 的等級。 \(\log(f) = 0.01n \times log 1.1, log(g) = 100 \times log n \Rightarrow \lim_{n\rightarrow\infty}\frac{\log(f)}{\log(g)} = \infty\)，所以 \(f(n) = \omega(g(n))\)。 Ex (98 交大) Prove：(log n)! 不是 Polyniminally bounded ( = O(\(n^k\)))。 ＜分析＞ 若 f(n) 是 Polyniminally bounded，則 \(\exists k \in R \ni f(n) = O(n^k)\)； \(\log f = O(\log n^k) = O(\log n)\) ，若為 Polyniminally bounded 則等級小於 log n \(\log((\log n)!) = \Theta(\log n (\log\log n))\) 其等級大於 log n 也就是 \(\log(\log n)! = \omega(\log n)\) 複雜度計算 \(\Theta\) 集合的求取 Close form 的求取 Close form 最高次項即為其 Tight bound。 \(T(n) = 1 + ...+n = \frac{n(1+n)}{2} = \frac{n^2+n}{2} = \Theta(n^2)\) 並不是所有函數都有 Close form。 使用 Upper bound 與 Lower bound 的夾擊 若 \(f(n) = O, \Omega (g(n))\) 同時成立，稱 \(g(n)\) 為 \(f(n)\) 的 Asymptotic tight bound。 Ex \(T(n) = \sum_{i=1}^n i^5 = \Theta(n^a)\)，求 a = ？ 先證明 \(T(n) = \sum_{i=1}^n i^5 = O(n^6)\)、再證明\(T(n) = \sum_{i=1}^n i^5 = \Omega(n^a)\) 即可。 調和級數( \(\mathbb{H}_n = 1 + \frac{1}{2} + \frac{1}{3} + ... +\frac{1}{n}= \Theta(\lg n)\) )因為調和級數沒有 Close form，必須使用夾擠法 \(\because \mathbb{H}_n - 1 = \sum_{i = 1}^n \frac{1}{i} - 1 \leq \int_1^n \frac{1}{n} dx = (\lg n - \lg 1) = \lg n \\ \therefore \mathbb{H}_n \leq \ln n + 1 \leq 2 \times \ln n \Rightarrow \exists C = 2, n_0 \geq 3 \ni n \geq n_0 , \\ \mathbb{H}_n \leq C \times \lg n \\ \Rightarrow \mathbb{H}_n = O(\lg n) \\ \because \mathbb{H}_n = \sum_{i = 1}^n \frac{1}{n} \geq \int_1^n \frac{1}{n} dx = \ln n \\ \therefore \mathbb{H}_n \geq \ln n \Rightarrow \exists C = 1, n_0 \geq 1 \ni n \geq n_0 , \mathbb{H}_n \geq C \times \lg n \\ \Rightarrow \mathbb{H}_n = \Omega(\lg n) \\ \Rightarrow \mathbb{H}_n = \Theta(\lg n)\) ＜Note＞ 收斂(Converge)的級數 \(T(n) = 1^a + \frac{1}{2^a} + \frac{1}{3^a} + \ldots = \sum_{i = 1}^n \frac{1}{i^a} = \frac{\pi^2}{6}, for\; some\; a = 2, 3 ...\) \(\Rightarrow T(n) = \Theta(1)\) 複變分析證明 \(\log n! = \Theta(n\lg n)\) 證明： Prove \(\log(n!) = O(n\lg n)\) \(\log n! = \log ( \Pi_{i = 1}^n i ) = \sum_{i = 1}^n \log i \leq \sum_{i = 1}^n \log n = n \log n\) \(\therefore \exists C = 1, n_0 = 1 \ni n\geq n_0, \log n \leq n \log n \Rightarrow \log n! = O(n\lg n)\) Prove \(\log(n!) = \Omega(n\lg n)\) ( 離散筆記本 P.118 ) \(\log n! = \log ( \Pi_{i = 1}^n i ) \\ = \sum_{i = 1}^n \log i \geq \sum_{i = 1}^{ceil(\frac{n}{2})} \log ceil( \frac{n}{2}) \geq \frac{n}{2} \log \frac{n}{2} \\ = \frac{n}{2} (\log n - \log 2)\approx \frac{1}{2}n\log n\) \(\therefore \exists C = \frac{1}{2}, n_0 = 1 \\ \ni n\geq n_0, \log n \geq \frac{1}{2}n \log n \Rightarrow \log n! = \Omega(n\lg n)\) \(\therefore \log n! = \Theta(n\lg n)\) Ex (96 台大資工) \(T(n) = \sum_{k = 1}^n k^2(\log k)^3 = \Theta(n^d(\log n)^e)\)，d = ？、e = ？ ＜想法＞：拆開 \(1^2(\log 1)^3 + 2^2(\log 2)^3 + ... +n^2(\log n)^3 \Rightarrow_{\leq} 1^2(\log n)^3 + 2^2(\log n)^3 + ... +n^2(\log n)^3\) 提出 \((\log n)^3 \times \sum_{i = 1}^n i^2 = O(n^3(\log n)^3)\) 所以 d = 3, e = 3 \((\log_an)^b = o(n^k), k &gt; 0\) Ex：\((\lg n)^{100} = o(n^{0.0000001})\) Ex (96 輔大資工) Prove \((\log n)^3 = O(n^\frac{1}{16})\) (函數型態複雜不適合使用定義證明，這裡採取極值法) \(\lim_{n\rightarrow\infty} \frac{(\log n)^3}{n^{\frac{1}{16}}} \\ =_{同取微分} \lim_{n\rightarrow\infty} \frac{\frac{3}{n (\ln 10)^3}\cdot (\ln n)^2}{\frac{1}{16}\cdot n^{\frac{-15}{16}}} \\ =_{整理} Constant\cdot \lim_{n\rightarrow\infty}\frac{(\ln n)^2}{n^{\frac{1}{16}}} =\ldots \\ \Rightarrow_{趨近於, n \rightarrow \infty} 0 \\ \Rightarrow (\log n)^3 = o(n^\frac{1}{16}) \Rightarrow_{?} (\log n)^3 = O(n^\frac{1}{16})\) Ex 比較 \(n^{1 + \epsilon}\) 與 \(\frac{n^2}{\log n}\) 的等級，其中 \(0&lt;\epsilon &lt; 1\)。 ＜猜測＞：後者比較大 ＜分析＞：\(n^{1+\epsilon} = n^{2-\delta}, 0&lt;\delta&lt;1 \Rightarrow \frac{n^2}{n^\delta} \\ \because \log n = o(n^\delta) \\ \therefore n^{1 + \epsilon} = O(\frac{n^2}{\log n})\)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time Complexity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Synchronization 2]]></title>
    <url>%2Fwillywangkaa%2F2018%2F08%2F04%2FOperating-System-Process-Synchronization-2%2F</url>
    <content type="text"><![CDATA[Process Synchronization ( Process Communication, Inter Process Communication ) Race Condition Problem in Memory Communication thesolutionofracecondition Monitor thestructofmonitor monitor 是一個用來解決同步問題的高階「資料結構」，是一種 ADT ( Abstract data type )。 組成架構 共享變數宣告區 一組 local funtions or procedures 初始區 ( Initialization area ) 語法架構 12345678910111213141516type Monitor-Name = Monitorvar 共享變數宣告procedure entry fun1-Name begin BODY; end ...procedure entry fun2-Name begin BODY; end begin 初始區end Pros Monitor 本身已保證互斥( mutual exclusive )，即「任和時間點，最多只允許 1 個 Process 在 Monitor 內進行活動 ( active )」：在任何時間點，最多只允許 1 個 Process 呼叫 ( calling ) Monitor 的某一個 function or procedure 執行，不可有多個 processes 同時呼叫 Monitor 的 funciton 執行。 上述的互斥性質，是將「共享變數區的共享變數」設成只能以 Monitor 的 local function 存取，而不能直接從 Process 直接存取，而 Monitor 保障互斥，所以也會不會造成「Race condition」，完全無需再在意額外的演算法以防止 Race condition，只需專心解決同步問題即可( 在這一點比起 semaphore 好用很多，因為 semaphore 並不會保證 mutex 存取變數還須要演算法以輔助之 )。 Ex. 當我們在解決同步問題時，Semaphore 比起 Monitor 容易使用？ False。 Condition ( 資料型別 ) Condition 型別是用在 Monitor 中，提供給開發者解決同步問題之用。 Operatior：令 \(x\) 為一 Condition type 變數。 wait ( x.wait )：因為某些同步條件而被卡住時，執行此運作的該 Process 會 Blocked，並且置入 Monitor 內該資料變數的所屬之等待佇列( Waiting Queue：預設為 FIFO ) signal ( x.signal )：如果先前有 Processes 卡在該變數 ( x ) 的「Waiting queue」中，則此運作會自此「Waiting queue」移走一個 Process 並且恢復 ( Resume ) 其執行，否則無任何作用。 解決 Dining-philosophers Problem 先定義所需的 Monitor ADT。type Dining-ph = Monitorvar state：[0…4] of ｛ think, hungry, eating ｝。 self：[0…4] of condition 12345procedure entry pickup(i:0...4) state[i] = hungry test(i); if(state[i] != eating) then self[i].wait // 繼續餓著，將該 Process blocked 1234567procedure test(k:0...4) if(state[(k+4)%5]!= eating &amp;&amp; // 左邊哲學家沒吃飯 state[k] == hungry &amp;&amp; // 由於 putdown 會要讓左右邊的哲學家是否要吃飯，所以必須存在 state[(k+1)%5] != eating // 右邊哲學家沒吃飯 ) then state[k] = eating // 改為正在吃飯 self[k].signal // *將自己喚醒 ＜Note＞： state[...]!= eating 為何是測試「是否正在吃飯而不是測試是否飢餓」？因為能呼叫到目前的函式代表該 Process 是正在進行的 ( Active )。 1234procedure entry putdown(i:0...4) state[i] = thinking test((i+4)%5) // 給左右邊哲學家機會使用 test((i+1)%5) 123init() for(i = 0; i &lt; 4; i++) state[i] = thinking 使用方式 共享變數宣告： dp：Dining-ph 12345678// P_i repeat // hungry dp.pickup(i); // active in monitor // eating dp.putdowm(i); // active in monitor // thinking until false Conditional Monitor Condition 變數所屬的 Waiting queue 一般皆是 FIFO queue ( 甚至 Monitor 的 entry queue 也是 FIFO )，可是有時候我們會需要「Priority queue」優先移除高優先權的 Process ，恢復執行或讓他進入 Monitor 內進行活動，此時我們就會需要 Conditional monitor。 Operatior：令 \(x\) 為一 Condition type 變數。 wait ( x.wait(c) )：c 為此 Process 的 Priority number。 解決互斥問題之應用 互斥資源配置問題 Process ID 越小者優先權越高可以優先取得資源。 定義 Monitortype ResourceAllocator = Monitorvar busy：boolean // 代表資源已經配置與否var x：condition // 用以將 Process blocked 想法 \(\left\{\begin{matrix} 非優先權需求 \Rightarrow 寫入\; Monitor \; 的函式定義中處理。 \\ 優先權需求 \Rightarrow 只須告知閱卷人你的\; Monitor \; 是以 \;Priority \; queue\; 實現的。 \end{matrix}\right.\) \(此題之分析\left\{\begin{matrix} 非優先權需求 \Rightarrow 互斥資源配置。\\ 優先權需求 \Rightarrow Process \;ID \;之優先權。 \end{matrix}\right.\) 12345procedure entry Apply(pid:int) if(Busy) then x.wait(pid) else Busy = true 123procedure entry Release() Busy = false x.signal 12init() Busy = false 使用方式 共享變數 RA：ResourceAllocator Pi ( i 代表 ProcessID ) 123456// P_i ... RA.Apply(i) // 使用資源 RA.Release() ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 共享檔案問題 有一個「檔案」可以被多個 Processes 所使用，每一個 Process 有唯一的優先權值( Unique priority number )，存取檔案時必須要： 1. 所有正在存取此檔案的 Process 的優先權值加總必須 \(&lt; n\)。 2. 優先權值小的優先權越高。 定義 Monitortype FileAccess = Monitorvar sum：int\(x\)：condition 123procedure entry Access(i:priorityNum) while((sum+i) &gt;= h) do x.wait(i) // !! sum += i 123procedure entry Leave(i:priorityNum) sum -= i x.signal() 12init() sum = 0 使用方式 共享變數 FA：FileAccess Pi ( i：process priority number ) 程式 123456// P_i ... FA.Access(i) // 使用檔案 FA.Leave(i) ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 印表機使用權問題 (P.6-72) 有三部 Printer 被 processes 使用且規定 process ID 越小優先權越高。 定義 Monitortype Allocator = Monitorvar p：[0…2] of booleanx：condition 12345678910111213int Acquire(i:processID) if(p[0] &amp;&amp; p[1] &amp;&amp; p[2]) x.wait(i) if(!p[0]) tmp = 1 else if(!p[1]) tmp = 1 else tmp = 2 p[tmp] = true return tmp 123void Release(y:printerNum) p[y] = false x.signal() 123init() for(i = 0; i &lt; 2; i++) p[i] = false 使用方式 共享變數 RA：Allocator Pi (i = Process ID) 1234567// P_i ... pno: printer number pno = PA.Acquire(i) // 使用編號 pno 的印表機 PA.Release(pno) ... 此 Monitor 的 \(x\) condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。 使用 Monitor 定義 Semaphore？ 定義 Monitor type semaphore = Monitorvar value：int // 號誌值\(x\)：condition 123procedure entry wait() value-- if(value &lt; 0) then x.wait() 123procedure entry signal() value++ x.signal() 12init() value = 1 Monitor 的種類 ( 3種 ) 探討 假設 Process Q 目前因為先前有執行了 x.wait ，所以卡在 x condition 變數之 Waiting queue 中，接著，目前的 Process P 在 Monitor 中進行活動，當 P 執行了 x.signal 後，P 會將 Q 從 Waiting queue 中恢復 ( Resume ) 執行，此時代表 P 與 Q 同時在 Monitor 中進行活動( Active )，但是如此一來會違反 Mutual exclusive，因此我們要抉擇 讓 P 或 Q 其中一個能夠在 Monitor 中活動。 thetypeofmonitor Type 1 - Hoare Monitor ( 效果最好 ) P waits Q until Q completed function or Q is blocked again. Pros 保證 Q 一定可以被恢復執行 ( Resume execution )。 在不會退出 Monitor 的情況下可以恢復比較多的 Processes ，但是是效果其實與 Type3 的相去不遠。 Type 2 ( 效果最差 ) Q waits P until P completed function or P is blocked. Cons 不保證 Q 一定可以被恢復執行，因為允許 P 繼續往下執行的過程中，P 有可能改變可能讓 Q 可以恢復行為的同步條件值，使得 Q 仍被卡住。 Type 3 P leaves monitor ( 將 P 重新插在 Monitor entry queue 的第一個 ) and let Q resume execution 直到 Q finished or Q is blocked again, then P reenter Monitor. Consurrent C / Consurrent PASCAL 所採用。 Pros 保證 Q 一定可以被立刻恢復執行( Resume execution )。 Cons 效果不若 Type1 Monitor，因為在 P 一進一出的期間，頂多只能恢復一個 Q，然而 Type1 可以一次恢復多個 Q。 目前的分類 ( 2種 ) Signal-and-wait Type1 Hoare Monitor Type3 Monitor Signal-and-continue Type2 Monitor 實作 Monitor 使用 Semaphore 。 架構 保證「互斥」：最多只能有一個 Process 在 Monitor 中進行活動。 「Hoare」的設計手法。 Condition 變數 \(x\) ：x.wait()、x.signal。 共享變數 mutex：semaphore = 1 ( 用以保障函式使用的「互斥控制」) next：semaphore = 0 ( 若 P 執行 x.signal，則用來 block P ) next_count：int = 0 ( 統計 P 的個數 ) x_sem：semaphore = 0 ( 當 Q 執行 x.wait() ，則用以 block Q ) x_count：int = 0 ( 統計 Q 的個數 ) 控制碼 - 確保互斥：在 Monitor 的每個函式的「body」之前及後加入一些額外的控制碼。 123456789procedure entry _monitorfunction() wait(mutex) // body if(next_count &gt; 0) // 若 P 存在，必先讓 P 恢復執行 signal(next) else // 若沒有 P 在等待，才讓下一個 Q 進入執行 signal(mutex) 控制碼 - 「\(x\).wait()」： 12345678// x.wait x_count++ // Q 的個數加一 if(next_count &gt; 0) // 將要 blocked 前的準備動作(與上述程式碼相同) signal(next) else signal(mutex) wait(x_sem) // Q 將自己 block x_count-- // 當 Q resume 後，將 x_count 減一 控制碼 - 「\(x\).signal()」： 123456// x.signal if(x_count &gt; 0) // 先前若有 Q blocked 才有作用 next_count++ signal(x_sem) // resume Q wait(next) next_count-- 問題與討論 證明 Monitor 與 Semaphore 解決同步問題的能力是一樣的( idemtical; equivalent )。 由於 Monitor 與 semaphore 可以「相互實作」，所以兩者解決「同步問題」的能力是相同的。 當開發者在解決同步問題時，Monitor 的使用會比起 Semaphore 容易，因為 Monitor 本身已經保證「互斥」，所以 condition variable 不會有「race condition」的問題，所以只要專心解決「同步問題」即可，但是當開發者要使用 Semaphore 解決同步問題時還需要關心「Race condition」與「同步條件」的滿足。 Message Passing Direct ( symmtric ) communication Indirect communication 收、送雙方須相互指名對方 ID，才能建立通訊鏈結。 雙方透過「Shared mailbox」才能建立通訊鏈結。 通訊鏈結是專屬於溝通的雙方，不得與其他 Processes 共享。下圖(一) 可以多 Processes 一起共享。下圖(二) 溝通雙方最多只能一條通訊鏈結(禁止多條通訊鏈結)。下圖(三) 溝通雙方可以同時存在多條通訊鏈結，每一條皆須有「Shared mailbox」。下圖(四) thetypeofmessagepassing 直接通訊 ( Direct Communication ) Symmetric 雙方須「互相指名」對方的 Process ID ，才能建立通訊鏈結 ( Communication link )，OS 提供 send()、receive() 的 System call。 1234// P_1 ... sent(P_2_ID, message) ... 1234// P_2 ... receive(P_1_ID, message) ... Asummetric 只有「送出的 Process」需要指名「收受的 Process 之 ID」，但收受方無須指名送方，即任何 Process 皆可以收下這則訊息。 1234// P_1 ... send(P_2_ID, message) ... 1234// P_2 ... receive(id, message) ... 當 P_2 收到訊息後，會將「送出訊息的 Process」之 ID 存在id變數之中。 間接通訊 ( Indirect Communication ) 收、送雙方是透過「Shared mailbox」，才能建立通訊鏈結。 1234// P_1 ... send(A, message) ... 1234// P_2 ... receive(A, message) ... 用 Message Passing 解決 Producer-comsumer Problem Producer 123456// Producer while(condition != false) &#123; produce an item in next_tp; send(Consumer, next_tp); ... &#125; Comsumer 123456// Consumer while(condition != false) &#123; receive(Producer, next_tp); Consumer the item in next_tp ... &#125; 「同步」意義之呈現 Link capacity 假設「收受的 Process」是以：若未收到訊息則暫停執行，直到收到訊息後才往下執行；而對於「傳送的 Process」看待 Link capacity 時，其實針對每條傳輸鏈結裡的「Message queue」( 用以保存「除了正在傳輸中的訊息以外之其他 送方 訊息」)之容量。 linkcapacity ★ Zero capacity 送方直到收方收到訊息後才能繼續往下執行，此時雙方的同步模式也稱為「Rendezvous」( 法文：約會一次；偶遇 ) 12345// P_1 ... send(P_2_ID, message) receive(P_2_ID, "Acknowledge") ... 12345// P_2 ... receiver(P_1_ID, message) sned(P_1_ID, "Acknowledge") ... Bounded capacity 當 Queue 滿了之後，送方會被迫暫停執行。 Unbounded capacity 送方無須被迫暫停執行。 4 條指令之組合來表現不同之「同步模式」 Blocking send 送出訊息後直到收方收到訊息後才繼續往下執行。(Like zero capacity) Nonblocking send 送出訊息後無須收方確認收到訊息即可繼續往下執行。(Like unbounded capacity) Blocking receive 一定要收到訊息才能繼續往下執行。 Nonblocking receive 不一定要確認訊息的正確性亦能繼續向下執行。 問題與討論 Ex1.「Rendezvous」模式 1234// P_1 ... Blocking_send(P_2_ID, message) ... 1234// P_2 ... Blocking_receive(P_1_ID, message) ... Ex2. 假設收方的程式如下，則代表著甚麼含意： 12345678910... Nonblocking_receive(A, message) if(message == null) &#123; Blocking_receive(B, message) Blocking_receive(A, message) &#125; else &#123; Blocking_receive(B, message) &#125;... 選項： 從 A 或 B 收到訊息後，即可往下。 一定要從 A 與 B 收到訊息後且要先 A 後 B，才可以繼續往下執行。 同上，但 A、B 順序無所謂。 Ans： (3) Exception handling 在「Rendezvous」模式之下，若收或送任一方的 Process 以死亡( terminate )，但另一方不知情時，則另一方會永久停滯 ( Starvation、Deadlock )：作業系統會以「Exception」的方式刪除另一個 Process。 1234// P_1 ... Blocking_send(P_2_ID, message) ... 1234// P_2 ... Blocking_receive(P_1_ID, message) ... 在直接通訊 ( Direct symmtric communication )下，若「未通報其他 Process 自己的 ID」且 「New Process 也不知道他人 Process 的 ID」，則無法溝通。 訊息的傳輸過程之中，有可能會丟失訊息( Lost message ) ，作業系統負責偵測訊息是否已丟失，若丟失訊息時，作業系統會通知「送方」重送訊息，偵測丟失訊息的方法類似於「網路概論」中談到的封包丟失偵測有關 ( Time-out 法則 )。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Synchronization 1]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Process-Synchronization%2F</url>
    <content type="text"><![CDATA[Process Synchronization ( Process Communication, Inter Process Communication ) Synchronization Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。 Process Communication Shared memory 1530175318032 Process 透過對共享變數 ( Shared variables ) 之存 ( Write )、取 ( Read )，達到構通 ( Infomation exchange ) 的目的。 分析 適用於大量資料( Data, Message )傳輸的狀況。 因為不須 Kernel 的介入干涉，因此傳輸速度較快。 不適用在分散式系統( distributed system )。 Kernel 不須提供額外的支援( 最多就只供應共享的記憶體空間 Shared memory space )，而所有的控制都交付給 Programmer 自行負擔，必須撰寫額外的控制碼防止 Race condition 發生。 Message passing Process 雙方要溝通必須要遵循以下步驟 建立 Communication link。 訊息可雙向傳輸。 傳輸完畢，釋放 Communication link。 分析 適用於少量資料( Data, Message )傳輸的狀況。 因為須要 Kernel 的介入干涉，因此傳輸速度較慢。 適用在分散式系統( Distributed system )。 Kernel 必須提供額外的支援( 如：System call of send/receive, Management of communication link, Detection of message lost, 例外狀況的處理 )，而所有的通訊控制都交付給作業系統。 Race Condition Problem in Memory Communication 在利用共享記憶體作為通訊橋梁時，若未對共享變數存取提供任何互斥存取控制之同步( Synchronization )機制，會因為 Processes 之間的交錯執行而導致前後順序不同，進而造成共享變數的最終結果有所不同，這種資料不一致( Data inconsistency )的情型，稱為 Race condition。 \(Ex .\) C 為共享變數且初值為 5。 兩個 Processes \(P_i, P_j\)，分別程式碼如下。 1234//P_i...C = C + 1;... 1234//P_j...C = C - 1;... \(P_i, P_j\) 個執行一次則 C 的最終值可能是 5 或 4 或 6。 正常結束( No race condition ) ：5 123// processing flowc = c + 1 // P_ic = c - 1 // P_j 123//processing flowc = c - 1 // P_jc = c + 1 // P_i Race condition：4 12345678910111213// assembly processing flow// P_iload c; // c == 5// P_jload c; // c == 5// P_iprocess c = c + 1; // c == 6// P_jprocess c = c - 1; // c == 4// P_irestore to c; // c == 6// P_jrestore to c; // c == 4 Race condition：6 12345678910111213// assembly processing flow// P_iload c; // c == 5// P_jload c; // c == 5// P_iprocess c = c + 1; // c == 6// P_jprocess c = c - 1; // c == 4// P_jrestore to c; // c == 4// P_irestore to c; // c == 6 \(Ex 1.\) x、y 是共享變數，初值各別為 5, 7 ，有兩個 process \(P_i, P_j\) 分別程式碼如下。 1234//P_i...x = x + y;... 1234//P_j...y = x * y;... \(P_i, P_j\) 各作一次，求 (x, y) 可能的值？ (12, 84) 123// processing flowx = x + y;y = x * y; (40, 35) 123// processing flowy = x * y;x = x + y; ★ (12, 35) 1234567891011// assembly processing flow// P_1load x, y; // x = 5, y = 7// P_2load x, y; // x = 5, y = 7// P_1process x = x + y;restore to x;// P_2process y = x * y;restore to y; \(Ex 2.\) x 是共享變數初值等於零 ， i 為區域變數，另外有兩個 process \(P_i, P_j\) 分別程式碼如下。 12345//P_i...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... 12345//P_j...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... \(P_i, P_j\) 各作一次，求 x 可能的值( 可能的最小值、可能的最大值 )？ 先拆解 for loop 1234// P_ix = x + 1;x = x + 1;x = x + 1; 1234// P_jx = x + 1;x = x + 1;x = x + 1; 分析若為最小值的狀況：3。 123456789101112131415161718192021222324252627282930313233// assembly processing flow// P_iload x; // x = 0// P_jload x; // x = 0// P_ix = x + 1;restore x; // x = 1// P_jx = x + 1;restore x; // x = 1// P_iload x; // x = 1// P_jload x; // x = 1// P_ix = x + 1;restore x; // x = 2// P_jx = x + 1;restore x; // x = 2// P_iload x; // x = 2// P_jload x; // x = 2// P_ix = x + 1;restore x; // x = 3// P_jx = x + 1;restore x; // x = 3 正常結束：6 所以 x 的值會介於在 3 ～ 6 之間，都是有可能會出現的狀況。 \(Ex 3.\) x 是共享變數初值等於零 ， i 為區域變數，另外有兩個 process \(P_i, P_j\) 分別程式碼如下。 12345//P_i...for( int i = 1; i &lt;= 3; i++ ) x = x + 1;... 12345//P_j...for( int i = 1; i &lt;= 3; i++ ) x = x - 1;... \(P_i, P_j\) 各作一次，求 x 可能的值( 可能的最小值、可能的最大值 )？ 先拆解 for loop 1234// P_ix = x + 1;x = x + 1;x = x + 1; 1234// P_jx = x - 1;x = x - 1;x = x - 1; 分析若為最小值的狀況：-3。 123456789101112131415161718192021222324252627282930313233// assembly processing flow// P_iload x; // x = 0// P_jload x; // x = 0// P_ix = x + 1;restore x; // x = 1// P_jx = x - 1;restore x; // x = -1// P_iload x; // x = -1// P_jload x; // x = -1// P_ix = x + 1;restore x; // x = 0// P_jx = x - 1;restore x; // x = -2// P_iload x; // x = -2// P_jload x; // x = -2// P_ix = x + 1;restore x; // x = -1// P_jx = x + 1;restore x; // x = -3 最大值的狀況：3。 解決 Race Condition Disable inrerrput ( 針對CPU ) Process 在對共享變數存取之前，先 Disable interrupt，等到完成共享變數的存取後，才 Enable interrupt，如此一來可以保證 Process 在存取共享變數的期間 CPU 不會被搶走( Preempted )，所以這種存取的方法稱為「Atomically executed (不可分割之執行)」，所以可以防止 Race condition。 \(Ex.\) 123456//P_i...disable interruptC = C + 1;enable interrupt... 123456//P_j...disable interruptC = C - 1;enable interrupt... Pros Simple, easy to implementation 適用於 Uniprocessor system。(單一CPU) Cons 不適合用在 Multiprocessors system 中。因為只 Disable 一顆 CPU 的 Interrupt 功能無法防止 race condition ( 其他的 CPUs 上執行之 Processes 仍可以存取該共享變數 )；但若 Disable 所有 CPU 的 Interrupt 功能，雖然可以防止 Race condition，但是會導致 Multiprocessor 的效能低落( low performance，因為無法「平行執行」 )變得和 Single-processor 的環境差不多。 風險很高：因為 Disable interrupt 指應為特權指令(風險高，可能阻擋 Kernel 的插斷)，所以必須信任使用者程式在 Disable interrupt 後，在短時間內會再 Enable interrupt ，不然 CPU 從此再也不會回到 Kernel 管理的狀態 ( 高風險!! )。 通常「 Disable interrupt 解決方法」不會下放給 User process，通常只存在於作業系統 Kernel 的實踐之中。( 只有作業系統開發者可以使用 ) 1530176275538 Critical section design( 針對共享資料製作臨界區塊 ) 針對「共享變數」的存取進行管制，當 P_i 取得共享變數存取管制，在該 Process 尚未完成之期間，任何其餘 Processes 即便已取得 CPU 的使用權之下，仍無法存取共享變數。 1530176581925 Atomic operation 在多程序環境下，此指令運算時不得被中斷其運算，或者共用同一個資料區域 Atomic transaction 由一系列資料（資料庫）活動構成，包括資料讀取與資料寫入的動作，通常這類的活動都是不可分割的（Atomic） 「Transaction」所包含的一連串活動，若無法一次全部執行完畢，則都不執行（All-or-nothing） 交易過程中發生錯誤造成系統當機時，這筆交易最後不會執行（Commit），以確保資料正確性 除錯（包含「Client」與「Server」的處理） 「Server」 當程序（Process）出現錯誤終止，「Server」會分配另外一個行程來接手，但是原本程序處理的「未完成交易」會被取消，然後將數值恢復成「交易前的狀態」 「Client」 「Server」會給予「Client」每一筆交易一個時間區段，如果在時限內交易未完成，則會取消該筆交易，以預防客戶端無預警當機，造成交易一直無法完成 Critical section Process 中對於共享變數進行存取的敘述集合。 Remainder section Process 中除了 C. S. 之外的區間統稱為 Remainder section。 1234567891011// Processrepeat entery section critical section exit section remainder section until false Critical section 的主要設計，是設計每個 Critical section 的前後 Programmer 需增加的控制碼( Entery section、Exit section )。 12345678910//P_i...// Enter section...C = C + 1;...// Exit section// Remainder section... 12345678910//P_j...// Enter section...C = C - 1;...// Exit section// Remainder section... Critical Section ( Spinlock, Busy-wiating ) VS. Disable interrupt Critical Section (Pros) 適用於多處理器系統( Multiprocessor system )。 Critical Section (Cons) 設計較為複雜。 較不適合用在單處理器系統( Uniprocessor system )。 Busy waiting ( Spinlock ) 技巧 透過使用迴圈相關敘述達到讓 Process 暫時等待該共享變數。 Cons 在 Spinlock 等待中的 Porcess 會與其他 Processes 競爭 CPU ，將得到的 CPU time 用在於空轉 ( spinlock ) 中，因此若 Process 要等待很長的時間才能離開迴圈，則這種方式較為浪費 CPU time。 Pros 若 Process 在迴圈等待的時間短( 小於「Context switching time」 )，則 Spinlock 非常有用。 1531041864596 恐龍課本的錯誤：因為 Critical Section 設計當中，「Entery section」中經常使用 Busy-waiting ( spinlock ) 技巧，而課本將 Busy-waiting ( Spinlock ) 與 Critical Section 視為相同，進而與 Disable interrupt 比較( 應是 Busy waiting 與 Non-busy waiting 來比較 )。 Non-busy waiting 技巧 當 Process 因為同步事件( Synchronization event )被長時間卡住，則可以使用 Block system call 將該 Process 送入 Blocked state，所以不會與其他 Process 競爭 CPU ，直到該事件觸動了，才會喚醒 ( Wake up system call ) 該 Process 移至 Ready state。 Pros 等待中的 Process 不會與其他 Process 不會浪費 CPU time。 Cons 需額外付出「Context switching time」。 Critical Section Design 關鍵性質 Mutual exclution：在任何時間點最多只允許一個 Process 進入它的 C.S. ，不可以有多個 Processes 分別進入各自的 C.S.。 Progress：不想進入 C.S. 的 Process ( 在 R.S. 中活動的 Process )，不可阻礙( 不參與「 進入C.S.」的決策 )其他 Processes 進入 C.S.。「安排欲進入 C.S 的 Process」之決策，要在有限的時間中完成 ( Non-deadlock：不可以無窮等待，使得全部之 Process 皆無法進入 C.S. )。—全部 Process 都無法進入 Bounded waiting：當有 Process 提出「進入 C.S.」之申請，等待核准的時間是有限的( 防止該 Process 出現 Starvation 的情形 )。—單一 Process 一直無法進入若有 n 個 Process 欲進入 C.S. 則每個 Process 最多等待 n-1 次後即可進入 C.S.。 著重於 高階( 位於函式庫中 ) Monitor 同步問題之解決 中階( 通常於 System call ) Semaphore 同步問題之解決 基礎建設( 作業系統核心製作 ) Software solutions、Hardware instrustions support C.S. 設計的正確與否 Disable interrupt 也在基礎建設 Software Solutions 兩個 Processes 之 critical section design 有兩個 Process \(P_i, P_j\)。 Algorithm 1 ( Fall )：權力層面 共享變數：Turn：int，值恰為 i 或是 j 值。 視為一種權力的象徵，當 turn 值為 i 時 \(P_i\) 始得 進入 C.S. 的權力，且只能讓 \(P_i\) 下一個進入 C.S. ，反之亦然。 1234567// P_iRepeat while ( turn != i ); // enter C.S. turn = j; // leave R.S.Until False 1234567// P_jRepeat while ( turn != j ); //enter C.S. turn = i; //leave R.S.Until False ＜分析＞： Mutual exclution ( OK ) ：因為 turn 值不會同時為 i 且為 j ，只會為 i 或 j 之其中一個值，所以只有 \(P_i\) 或 \(P_j\) 一個可進入 C.S. 而不會兩個同時進入。 Progress ( FALL ) ：假設目前 \(P_i\) 在 R.S. ( 且 \(P_i\) 不想進入 C.S. )，而目前的 turn = i 且 \(P_j\) 欲進入 C.S，但是因為 \(P_i\) 仍在 R.S. 無法交付 turn ，所以被 \(P_i\) 阻礙進入。 Bounded waiting ( OK ) ：證明 \(P_i\) 無法連續兩次進入 C.S 之中。假設目前 turn = i，且\(P_i\) 已先早於 \(P_j\) 進入 C.S. 使 \(P_j\) 開始等待，若 \(P_i\) 離開後又想立刻想再次進入，但因為 \(P_i\) 離開時會將 turn = j，使得 \(P_i\) 無法再度比 \(P_j\) 早進入 C.S.，這一次 \(P_j\) 必定先進入之 ，所以 \(P_j\) 最多等一次後即可進入。 Algorithm 2 ( Fall )：意願層面 共享變數：flag[ i … j ] of Boolean。( 初值皆為 False ) \(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\) 1234567// P_iRepeat flag[i] = true; // 表達意願 while (flag[j]); // enter C.S. flag[i] = false; // leaveUntil false 1234567// P_jRepeat flag[j] = true; // 表達意願 while (flag[i]); // enter C.S. flag[i] = false; // leaveUntil false ＜Note＞ Progress ( 造成死結 -&gt; Fall ) Mutual exclusion ( OK ) Bounded waiting ( OK ) 12345flag[i] = true; // P_i 表達意願flag[j] = true; // P_j表達意願 while (flag[j]); // P_i can't enter while (flag[j]); // P_j can't enter... // Progress fall ( Deadlock ) Algorithm 3 - Peterson’s Algorithm ( OK )：權力、意願層面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//============================================================================// Name : Softwaresolution.cpp// Author : willywangkaa// Description : Hello World in C++, Ansi-style//============================================================================#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;using namespace std;int sharedvar = 0;int turn;int flag[2];int condition[2];void worker(int tid) &#123; while(condition[tid]) &#123; double delaySum = 0; for( int i = 0; i &lt; 10000; ++ i ) for( int j = 0; j &lt; 10000; ++ j ) delaySum += i*j; flag[tid] = true; turn = (tid^1); while(flag[tid^1] &amp;&amp; turn == (tid^1)) ; turn = tid; this_thread::get_id(); sharedvar = tid; cout &lt;&lt; "Shared variable is edit by "&lt;&lt; sharedvar &lt;&lt; ".\n"; flag[tid] = false; &#125;&#125;int main() &#123; vector&lt;thread&gt; ths; turn = 1; for(int i = 0; i &lt; 2; i++) &#123; condition[i] = true; &#125; for(int i = 0; i &lt; 2; i++) &#123; ths.push_back(thread(worker, i)); Sleep(10); &#125; Sleep(1000); condition[0] = false; Sleep(2000); condition[1] = false; for (thread &amp; th : ths) &#123; if (th.joinable()) th.join(); &#125; cout &lt;&lt; sharedvar &lt;&lt; endl; return 0;&#125; 共享變數：flag[ i … j ] of Boolean。( 初值皆為 False ) \(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\) 共享變數：Turn：int，值恰為 i 或是 j 值。 12345678910// P_iRepeat flag[i] = true; // 表達意願 turn = j; // * enter ( 權力先給對方 ) while ( flag[j] &amp;&amp; turn == j ); // enter// turn = i; // enter C.S.// turn = j; // enter ( fall ) flag[i] = false; // leaveUntil false 12345678910// P_jRepeat flag[j] = true; // 表達意願 turn = i; // *enter while ( flag[i] &amp;&amp; turn == i ); // enter// turn = i; // enter C.S.// turn = j; // enter ( fall ) flag[j] = false; // leaveUntil false Mutual exclusion (OK)：若 \(P_i, P_j\) 皆欲進入 C.S. 代表 flag[i] 與 flag[j] 皆為 True，當雙方皆作到while測試的時候，代表雙方已分別執行過 turn = i 以及 turn = j 的設定，差異點在於可能會交錯執行，但是 turn 必為兩值之其中一者，所以只有P_i, P_j 一個可以進入 C.S。 Progress (OK)： 假設 turn 值目前為 i ，且 P_i 不想進入 C.S.，帶表 flag[i] = false 若此時 P_j 欲進入 C.S. ，則 P_j 必可通過 while 的關卡進入 C.S. ，所以P_i 不會阻礙 P_j 進入 C.S.。 若 P_i, P_j 皆欲進入 C.S 則在有限的時間內必可決定出 turn 值為 i 或為 j 使得 P_i, P_j 可以進入，兩者不會永遠互相等待造成死結。 Bound waiting (OK)：假設 turn 為 i ， P_i 已早於 P_j 進入 C.S. 而 P_j 等待進入中，所以 flag[i] = flag[j] = true，若 P_i 離開 C.S. 後，又想再進入 C.S. ，則 P_i 必定會將 flag[i]=false turn = j ，使得 P_i 無法再度先早於 P_j 進入 C.S. ，一定是 P_j 進入 C.S. ，所以 P_j 至多等待一次後即可進入 C.S.。 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？ 可以正確執行，只是 flag 互相對調而已。 12345678// P_iRepeat flag[j] = true; // 表達意願 turn = j; // * enter ( 權力先給對方 ) while ( flag[i] &amp;&amp; turn == j ); // enter C.S. flag[j] = false; // leaveUntil false 12345678// P_jRepeat flag[i] = true; // 表達意願 turn = i; // *enter while ( flag[j] &amp;&amp; turn == i ); // enter C.S. flag[i] = false; // leaveUntil false 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？ 可以正確執行，只是 turn 互相對調而已。 12345678// P_iRepeat flag[i] = true; // 表達意願 turn = i; // * enter ( 權力先給對方 ) while ( flag[j] &amp;&amp; turn == i ); // enter C.S. flag[i] = false; // leaveUntil false 12345678// P_jRepeat flag[j] = true; // 表達意願 turn = j; // *enter while ( flag[i] &amp;&amp; turn == j ); // enter C.S. flag[j] = false; // leaveUntil false 今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？ 可以正確執行，只是 turn 與 flag 皆互相對調而已。 12345678// P_iRepeat flag[j] = true; // 表達意願 turn = i; // * enter ( 權力先給對方 ) while ( flag[i] &amp;&amp; turn == i ); // enter C.S. flag[j] = false; // leaveUntil false 12345678// P_jRepeat flag[i] = true; // 表達意願 turn = j; // *enter while ( flag[j] &amp;&amp; turn == j ); // enter C.S. flag[i] = false; // leaveUntil false N 個 Process 之 Critical Section design Bakery’s Algorithm ( 麵包店號碼牌演算法 ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//============================================================================// Name : Softwaresolution.cpp// Author : willywangkaa// Description : Hello World in C++, Ansi-style//============================================================================#include &lt;bits/stdc++.h&gt;#include &lt;thread&gt;using namespace std;int sharedvar = 0;bool choosing[10];int number[10];void worker(int tid) &#123; double delaySum = 0; for( int i = 0; i &lt; 10000; ++ i ) for( int j = 0; j &lt; 10000; ++ j ) delaySum += i*j; choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) (void)0; while(number[i]&gt;0 &amp;&amp; ( (number[i] &lt; number[tid]) || (number[i] == number[tid] &amp;&amp; i &lt; tid) )) (void)0; &#125; this_thread::get_id(); sharedvar = tid; cout &lt;&lt; "Shared variable is edit by "&lt;&lt; sharedvar &lt;&lt; ".\n"; number[tid] = 0;&#125;int main() &#123; vector&lt;thread&gt; tharr; for(int i = 0; i &lt; 10; i++) &#123; choosing[i] = false; number[i] = 0; &#125; for(int i = 0; i &lt; 10; i++) &#123; choosing[i] = false; tharr.push_back(thread(worker, i)); &#125; for (thread &amp; th : tharr) &#123; if (th.joinable()) th.join(); &#125; cout &lt;&lt; sharedvar &lt;&lt; endl; return 0;&#125; 核心觀念： 客人要先取得號碼牌才可以入店內。 店內一次只能有一個客人進入。 「號碼牌最小的客人」或「號碼牌相同最小之 ID 最小的客人」，得以優先入內。 共享變數 choosing: [0 … n-1] fo boolean：初值皆為 false。\(choose[i] = \left\{\begin{matrix}True &amp; P_i \; 正在取得號碼牌中，但尚未取得\\ False &amp; P_i \; 已取得號碼牌(init) \end{matrix}\right.\) number: [0 … n-1] of int：初值為 0。\(number[i] = \left\{\begin{matrix}=0 &amp; 代表 \; P_i \;無意願進入\\ &gt;0 &amp; P_i \; 有意願進入 \end{matrix}\right.\) MAX(i … j)：從 i … j 挑最大值。 (a, b) &lt; (c, d)：代表1. a &lt; cor 2. a==c and b &lt; d P_i 之程式碼 12345678910111213Repeat choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; C.S. Number[i] = 0 // P_i 已無意願 R.S.util false Ex1. 為何號碼牌( number[i] )會有兩個以上相同的問題？ 因為在 number[i] = Max(number[0], ... , number[n-1]) + 1 的執行階段時，有可能會被其他 Process 搶斷。 12345678910111213// number[max] = 0// P_i// Processiing " choosing[i] = true; "Load max number[max]; // number[max] = 0Process max++;// P_j preempting// Processiing " choosing[j] = true; "Load max number[max]; // number[max] = 0Process max++;// P_iStore to number[i]; // number[i] = 1// P_jStore to number[i]; // number[i] = 1 Ex2. 證明 Critical section 關鍵性值。 Mutual exclusion (OK) ： Case1. 假設號碼牌值皆不同且大於零，則具有最小號碼牌值之 Process 可以優先進入 Critical section，因為最小值必唯一，所以除了該 Process 可以進入其餘等待。 Case2. 有多個 Processes 有相同的最小號碼牌，以 Process ID 最小者優先進入 Critical section，因為 Process ID 必唯一最小值也必定唯一，所以除了該 Process 可以進入其餘等待。唯一性確保，互斥確保。 Process (OK)： ( 不想進入但不會控制其他人 )假設 P_j 不想進入 C.S. 代表 number[j] 為 0 ，若此時 P_i 欲進入 C.S. 則 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; 不會被 P_j 阻擋住。 ( 不會造成 deadlock ) 若 P_0 ~ P_n-1 n 個 Processes 皆欲進入 C.S. 會在有限時間內必決定有一個 Process (號碼牌最小加上 ProcessID 最小)可以順利結束 for loop 進入 C.S. Bounded waiting (OK)：假設 P_0~P_n-1 processes 皆欲進入 C.S. 令 P_i 具有最大的號碼牌等於 K ( nuber[i] = K ) 因此，其他 n-1 Process：P_j ( j!=i )，必定先早於 P_i 進入 C.S.，若 P_j 離開 C.S 後，又立刻欲進入 C.S，則 P_j 的再取得號碼牌必定大於 K，所以 P_j 不會再早於 P_i 進入 C.S. 進而可以知道 P_i 最多等待 n-1 次即可進入 C.S.。 Ex3. 123456789101112Repeat choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; ~~while (choosing[j]) do no-op;~~ // 移除這行程式碼是否還正確？請解釋。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; C.S. Number[i] = 0; R.S.util false 不正確，違反「Mutual exclusion」 令目前 number[0 … n-1] 所有的值皆為 0 ，今有兩 Process \(P_i, P_j \quad where \; i \neq j\) 欲進入 C.S. ，並且假設 Process ID 為 \(P_i &lt; P_j\) 小結論 此行程式碼存在的目的，是為了讓所有可能會同一時間拿到號碼牌的 Processes 能公平的取得該號碼牌，不會有的早拿到或是晚拿到該「同一號碼」之號碼牌。 Hardware (CPU) Intructions Support 程式開發者可以使用硬體預先定義之指立於設計 Critical Section。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//============================================================================// Name : Hardware solution// Author : willywangkaa// Version :// Copyright :// Description : Hello World in C++, Ansi-style//============================================================================#include &lt;bits/stdc++.h&gt;#include &lt;thread&gt;#include &lt;windows.h&gt;using namespace std;bool condition;int sharedvar = 0;bool waiting[10];atomic_flag LOCK = ATOMIC_FLAG_INIT;void worker(int tid) &#123; while( condition ) &#123; double delaySum = 0; for( int i = 0; i &lt; 10000; ++ i ) for( int j = 0; j &lt; 10000; ++ j ) delaySum += i*j; waiting[tid] = true; while(waiting[tid] &amp;&amp; LOCK.test_and_set()) ; this_thread::get_id(); sharedvar = tid; cout &lt;&lt; "Shared variable is edit by "&lt;&lt; sharedvar &lt;&lt; ".\n"; waiting[tid] = false; int next = -1, curr = (tid + 1) % 10; while(curr != tid) &#123; if(waiting[curr]) &#123; next = curr; break; &#125; curr = (curr + 1) % 10; &#125; if(next != -1) &#123; waiting[curr] = false; &#125; else &#123; LOCK.clear(); &#125; &#125;&#125;int main() &#123; vector&lt;thread&gt; ths; condition = true; for(int i = 0; i &lt; 10; i++) &#123; waiting[i] = false; &#125; for(int i = 0; i &lt; 10; i++) &#123; ths.push_back(thread(worker, i)); &#125; for(int i = 1; i &lt;= 10; i++) &#123; condition = true; Sleep(i*20); condition = false; &#125; for (thread &amp; th : ths) &#123; if (th.joinable()) th.join(); &#125; cout &lt;&lt; sharedvar &lt;&lt; endl; return 0;&#125; 「test_and_set(bool *lock)」機器指令 功能：回傳 Lock 參數值並將 Lock 參數設為 True，且 CPU 保證此指令是不可中斷地執行( Atomically executed )。 12345bool test_and_set(bool *lock) &#123; bool return_value = *lock; *lock = true; return return_value;&#125; Algorithm 1 ( Fall ) 共享變數： Lock：bool = False( Initial value ) \(P_i\) 之程式碼： 123456do &#123; while (test_and_set(&amp;Lock)); // do nothing /* critical section */ Lock = false; /* remainder section */&#125; while (condition == true); 分析 Mutual exclusion：OK Progress：OK Bounded waiting：Fall假設 \(P_i\) 以早於 \(P_j\) 進入 C.S. ，所以 \(P_j\) 進行等待，當 \(P_i\) 離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 \(P_i\) 有可能可以再次早於 \(P_j\) 執行 test_and_set 進入 C.S.，所以 \(P_j\) 有可能會面臨「Starvation」。 ★★Algorithm 2 ( Pass ) - FIFO 共享變數 Lock：bool = False ( Initial value ) Waiting：[0 … n-1] of bool 初值皆為 False\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\) \(P_i\) 之程式碼： 12345678910111213141516171819202122232425262728區域變數：key:bool; j :int;do &#123; waiting[i] = true; key = true; // 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); // **表明 P_i 不用繼續等待，可以進入 C.S.。 waiting[i] = false; /* critical section */ // 找出下一個欲進入 C.S. 之 P_j Process j = (i + 1) % n; // j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S. while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; // 無 Process 欲進入 C.S. else waiting[j] = false; // 讓 P_j 進入 C.S. /* remainder section */ &#125; while (condition == true); 證明 Critical section 關鍵性值存在： Mutual exclusion：OK\(P_i\) 可進入 C.S. 之條件有兩種可能：Case1：Key 為 False，代表 P_i 是第一個執行 test_and_set 的 Process ，如此才能將 Key 賦予 False ，唯一性。Case2：Waiting[i] = False，因為一開始會先執行 waiting[i] = true; 代表 P_i 在離開 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 前不會將 Waiting[i] 賦予 False ，只有在 C.S. 的 Process 欲離開 C.S. 後才能將其他 Processes 其中一個 Process 的 Waiting 賦予 False 值，但是能在 C.S. 之中執行的 Process 唯一，所以也只會讓一個 Process 的 waiting 賦予 False 值，唯一性( Mutex 成立 )。 Progress：OK(1) 若 P_i 不想進入 C.S. 其 Waiting[i] 為 False ，且 P_i 不會與其他 Process 競爭執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); ，另外，從 C.S. 離開之 Process 不會改變 Waiting[i]，所以 P_i 不會參與進入 C.S 之決策。(2) 若 n 個 Process 皆想進入 C.S. ，則在有限的時間內( 無死結 )必定會決定出第一個執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 者。之後，該選中 Process 從 C.S. 離開後，也會在有限的時間內，讓下一個欲進入 C.S. 的 Process 進入 C.S 。 Bounded waiting：OKn 個 Process 皆欲進入 C.S. ，表示 Waiting[0] ~ Waiting[n-1] 皆為 true。令 P_i 是第一個執行 while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); 者，率先進入 C.S.，當 P_i 離開 C.S. 後會將 \(P_{(i+1) \mod n}\) 的 Waiting 賦予 False 值，使 \(P_{(i+1) \mod n}\) 進入 C.S.，依此類推 Process 會以 \(＜P_i, P_{(i+1) \mod n}, \ldots, P_{(i-1) \mod n}＞\) 的序列 ( FIFO ) 進入 C.S.，所以沒有「Starvation」。 「compare_and_swap(int *value, int expected, int new_value) 」指令 功能：將 value 與 new_value 兩值互換，且 CPU 保證為不可分割之執行( Atomically executed )。 實現作法 ( 硬體寫死，無法使用高階程式語言實現 )： 123456int compare_and_swap(int *value, int expected, int new_value) &#123; int temp = *value; if (*value == expected) *value = new_value; return temp;&#125; Algorithm 1 (Fall) 共享變數 Lock：bool = False ( Initial value ) \(P_i\) 之程式碼： 12345678區域變數: key:bool;do &#123; while (compare_and_swap(&amp;lock, 0, 1) != 0) ; /* do nothing */ /* critical section */ lock = 0; /* remainder section */&#125; while (condition == true); 分析 Mutual exclusion：OK Progress：OK Bounded waiting：Fall假設 \(P_i\) 以早於 \(P_j\) 進入 C.S. ，所以 \(P_j\) 進行等待，當 \(P_i\) 離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 \(P_i\) 有可能可以再次早於 \(P_j\) 執行 compare_and_swap 進入 C.S.，所以 \(P_j\) 有可能會面臨「Starvation」。 ★★Algorithm 2 ( Pass ) - FIFO 共享變數 Lock：bool = False ( Initial value ) Waiting：[0 … n-1] of bool 初值皆為 False\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\) \(P_i\) 之程式碼： 12345678910111213141516171819202122232425262728區域變數：key:bool; j :int;do &#123; waiting[i] = true; key = true; // 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。 while (waiting[i] &amp;&amp; key) key = compare_and_swap(&amp;Lock); // **表明 P_i 不用繼續等待，可以進入 C.S.。 waiting[i] = false; /* critical section */ // 找出下一個欲進入 C.S. 之 P_j Process j = (i + 1) % n; // j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S. while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; // 無 Process 欲進入 C.S. else waiting[j] = false; // 讓 P_j 進入 C.S. /* remainder section */ &#125; while (condition == true); 問題探討 Ex 12345678910111213141516171819202122do &#123; waiting[i] = true; key = true; while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock); ~~waiting[i] = false;~~ // 若此行刪除將導致什麼後果？ /* critical section */ j = (i + 1) % n; while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = false; else waiting[j] = false; /* remainder section */ &#125; while (condition == true); 違反 Progress 性質 ( 造成死結 )。 Semaphore ( 號誌 ) 令 S 為 Semaphore type 變數，架構在 Integer type。針對 S ，提供兩個「Atomic 運算元」 wait(S) ( 或 P(S) ) 與 signal(S) ( 或 V(S) )。( 因為是「Atomic 運算元」，所以不會有 Race condition。 ) wait(S) 12while(S &lt;= 0) ;S = S - 1; signal(S) 1S = S + 1 主要功能：「設計 C.S. 」與「解決同步問題」 使用範例 共享變數mutex：semaphore = 1 (Initial value) 程式結構 123456repeat wait(mutex); C.S. signal(mutex); R.S.until False ＜Note＞：semaphore 的初值，有某些意義。\(\left\{\begin{matrix}1 \Rightarrow 互斥控制之用途。\\ 0 \Rightarrow 強迫等待之用途。 \end{matrix}\right.\) 解決簡單的同步問題 ( synchronization problem ) Synchronization Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。 \(Ex.\) \(A;\) 必須要在 \(B;\) 之前執行。 1234// P_i...A;... 1234// P_j...B;... 宣告共享變數 \(s\)：semaphore = 0。 12345// P_i...A;signal(s);... 12345// P_j...wait(s);B;... \(Ex.\) 執行順序為 \(A、C、B\)。 12345// P_i...A;signal(s_1);... 12345// P_j...wait(s_2);B;... 123456// P_k...wait(s_1);C;signal(s_2);... 宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0 1234// P_i...A;... 1234// P_j...B;... 1234// P_k...C;... \(Ex.\) 一直重複執行依照 「\(A、B、C\) 」的順序。 123456// P_iwhile(condition == true) &#123; ... A; ...&#125; 123456// P_jwhile(condition == true) &#123; ... B; ...&#125; 123456// P_kwhile(condition == true) &#123; ... C; ...&#125; 宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0、s_3：semaphore：semaphore = 0。 12345678// P_iwhile(condition == true) &#123; ... A; signal(s_1); wait(s_3); // 注意! ...&#125; 12345678// P_jwhile(condition == true) &#123; ... wait(s_1); B; signal(s_2); ...&#125; 12345678// P_kwhile(condition == true) &#123; ... wait(s_2); C; signal(s_3); ...&#125; 當我們令 s_1：semaphore = 0、s_2：semaphore = 0、s_3：semaphore = 1。 12345678// P_iwhile(condition == true) &#123; ... wait(s_3); // 注意! A; signal(s_1); ...&#125; 12345678// P_jwhile(condition == true) &#123; ... wait(s_1); B; signal(s_2); ...&#125; 12345678// P_kwhile(condition == true) &#123; ... wait(s_2); C; signal(s_3); ...&#125; \(Ex.\) \(C\) 為共享變數且初值為 3，追蹤下列程式判斷可能的結果值。 1234// P_i ... C = C * 2; ... 1234// P_j ... C = C + 1; ... 可能的結果值為6、4、8、7。 s：semaphore = 1 123456// P_i ... wait(s); C = C * 2; signal(s); ... 123456// P_j ... wait(s); C = C + 1; signal(s); ... 可能的結果值為8、7。 s：semaphore = 0 12345// P_i ... C = C * 2; signal(s); ... 12345// P_j ... wait(s); C = C + 1; ... 結果值為7。 \(Ex.\) 求 \(A、B、C\) 可能的執行順序。 s_1：semaphore = 1、s_2：semaphore = 0。 123456// P_i...wait(s_1);A;signal(s_2);... 123456// P_j...wait(s_2);B;signal(s_1);... 123456// P_k...wait(s_1);C;signal(s_1);... 可能的執行順序為A-&gt;B-&gt;C 或 C-&gt;A-&gt;B。 Semaphore 誤用 違反「互斥」 s：semaphore = 1 12345// P_isignal(s); // C.S.wait(s);// R.S. ☆形成死結 s：semaphore = 1 12345// P_iwait(s); // C.S.wait(s);// R.S. ☆ s_1：semaphore = 1、s_2：semaphore = 1 123456// P_iwait(s_1); wait(s_2); ...signal(s_1); signal(s_2); 123456// P_jwait(s_2); wait(s_1); ...signal(s_2); signal(s_1); 可能會造成「死結」。 12345678910// flow code// P_i wait(s_1); // pass// P_j wait(s_2); // pass// P_i wait(s_2); // block// P_j wait(s_1); // block// Deadlock 重要的同步問題 ( Synchronization Problem ) 解決要點 以 Semaphore 變數實作同步處理條件。 以 Semaphore 實作互斥控制防止「Race condition」。 先同步、再互斥。 Producer Consumer Problem ( 生產者消費者問題 ) producercomsumerproblem Producer：這種 Processes 專門產生資料，以供其他 Processes 使用。 Consumer：這種 Processes 專門處理資料給使用者。 Shared memory 狀態下討論。 ☆Bounded Buffer Producer-Consumer ( 有限緩衝區 ) 當緩衝區滿的時候，生產者必須等待。 當緩衝區空的時候，消費者必須等待。 Algorithm1 ( 未使用「Semaphore」 ) 共享變數 \(Buffer：[0 \ldots n-1] \; of \; items\) \(in, out：int = 0\) Producer Process 123456789// producerwhile(condition == true) &#123; ... create a new item "t"; while((in+1)%n == out) ; Buffer[in] = t; in = (in + 1) % n; ...&#125; Consumer Process 12345678910// consumerwhile(condition == true) &#123; ... while(in == out) ; assign Buffer[out] to "I"; out = (out + 1) % n; ... // using "I" item ...&#125; Algorithm2( Fall ) circulerqueue 若使用「Algorithm1」的算法，在上圖所表示的狀態中，算法會判斷為 Buffer 已滿 ((in + 1) % n == out)，無法再加入，所以導致最多只能用 n-1 個 Buffer。 共享變數 \(Buffer：[0 \ldots n-1] \; of \; items\) \(in, out：int = 0\) Count：int = 0 Producer Process 12345678910// producerwhile(condition == true) &#123; ... creat a new item "t"; while(count == n) ; buffer[in] = t; in = (in + 1) % n; count++; ...&#125; Consumer Process 1234567891011// consumerwhile(condition == true) &#123; ... while(count == 0) ; assign buffer[out] value to "I"; out = (out + 1) % n; count--; ... // using tiem "I" ...&#125; Algorithm3 ( 用 Semaphore 解決 Algorithm2 ) 共享變數 empty：semaphore = n代表緩衝區內的「空閒容量」，若為 0 則代表緩衝區已滿。 full：semaphore = 0代表緩衝區中「已使用容量」，若為 0 則代表緩衝區目前為空。 mutex：semaphore = 1對緩衝區、in、out 與 Count 做互斥控制，防止「Race condition」。 Producer Process 123456789101112// producerwhile(condition == true) &#123; ... create a new item "t"; wait(empty); // 確認當前「空格數」是否足夠使用。 wait(mutex); buffer[in] = t; in = (in + 1) % n; count++; signal(mutex); signal(full); // 將「滿格數」添上一筆。&#125; Consumer Process 1234567891011// consumerwhile(condition == true) &#123; ... wait(full); // 確認當前「滿格數」是否足夠使用。 wait(mutex); assign buffer[out] to "I"; out = (out + 1) % n; count--; signal(mutex); signal(empty); // 將「空格數」添上一筆。&#125; Unbunded Buffer Producer-Consumer ( 無限緩衝區 ) 當緩衝區空的時候，消費者必須等待。 不予討論 Reader Writer Problem readerwiterproblem ☆問題重點 Reader、Writer 須對該資料進行互斥處理。 Writer、Writer 須對該資料進行互斥處理。 First reader writer problem firstreaderwiterproblem 對於 Reader 有利，而對於 Writer 不利所以可能導致 Writer 「Starvation」。 共享變數 wrt：semaphore = 1 提供 Read/Write 與 Write/Write 的互斥控制，這種控制將會不利於 Writer 的寫入。 readcnt：int = 0 紀錄目前的 Reader 個數。 \(\left\{\begin{matrix}多一位 \; Reader \Rightarrow readcnt = readcnt + 1。\\少一位 \; Reader \Rightarrow readcnt = readcnt -1。 \end{matrix}\right. \Rightarrow 需使用互斥控制。\) mutex：semaphore = 1 對 readcnt 作「互斥控制」，防止 Race condition。 Reader 程式 12345678910// Reader wait(mutex); readcnt++; if(readcnt == 1) wait(wrt); signal(mutex); // Reading wait(mutex); readcnt--; if(readcnt == 0) signal(wrt); // 目前沒有 Reader 要使用此檔案了。 signal(mutex); Writer 1234// Writer wait(wrt); // Writing signal(wrt); 當 if(readcnt == 1) 符合條件代表目前是第一個想要使用此檔案的 Reader。 需要執行 wait(wrt); 以檢查目前是否有其他的 Writer 正在使用此檔案。1. 若有，則不繼續執行。2. 若無，則通過且將 Writer 阻擋住。 EX：根據上方程式，假設目前 \(W_1\) 已在寫入之中。 若 \(R_1\) 接上面之後開始執行，則 \(R_1\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(wrt);，readcnt = 1。 若 \(R_2\) 接上面之後開始執行，則 \(R_2\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(mutex);，readcnt = 1。 若 \(R_3\) 接上面之後開始執行，則 \(R_3\) 會卡在程式碼何處？而此時的 readcnt 又為何？wait(mutex);，readcnt = 1。 Second reader writer problem secondreaderwriterproblem 對於 Writer 有利，而對於 Reader 不利所以可能導致 Reader 「Starvation」。 只要 Writer 離開，發現尚有 Writers 也在等待佇列，則優先讓 Writer 對資料進行寫入，所以可能會導致 Reader Starvation。 共享變數 readcnt：int = 0紀錄目前 Readers 正在讀取的個數。 wrtcnt：int = 0紀錄目前還有多少 Writer 在等待寫入資料。 x：semaphore = 1對 readcnt 作互斥控制，防止 race condition。 y：semaphore = 1對 wrtcnt 作互斥控制，防止 race condition。 z：semaphore = 1因為要對 Writer 有利，所以使用 mutex 作為 Reader 要對資料進行讀取時的障礙，不會急於對資料讀取。(讓 rsem 的效果更明顯) rsem：semaphore = 1作為不利 Reader 之控制。 wsem：semaphore = 1提供 Read/Write 與 Write/Write 的互斥控制。 Reader 程式 1234567891011121314// Readerwait(z); wait(rsem); wait(x); readcnt++; if(readcnt == 1) wait(wsem); signal(x); signal(rsem);signal(z);// Readingwait(x); readcnt--; if(readcnt == 0) signal(wsem);signal(x); Writer 程式 123456789101112// Writerwait(y); wrtcnt++; if(wrtcnt == 1) wait(rsem); // 目前第一個 Writer，會迫使 Reader 多一層等待signal(y);wait(wsem); // 開始等待寫入 // Writingwait(y); wrtcnt--; if(wrtcnt == 0) signal(rsem); // 最後一個 Writer，將擋住 Reader 的閘門解除。 signal(wsem); // Writer 離開時，交付讀寫權。signal(y); The sleeping Barber Problem ( 理髮師睡覺問題 ) 一個理髮師，一張美髮座椅( 理髮師一次服務一個客人 )，與 n 個等待座位。 客人 若等待座位坐滿，就不會進入理髮廳。 若尚未坐滿： 進入理髮廳等待。 通知 / 喚醒理髮師。 若理髮師正在忙碌，客人進行睡覺( waiting )，直到理髮師喚醒客人剪髮，剪完後離開。 理髮師 若目前無客人，睡覺( waiting )直到有客人喚醒理髮師。 若目前理髮師醒著且目前有客人正在等待，會去喚醒客人理髮，重複動作直到沒有客人為止最後睡覺(wait)。 共享變數： customer：semaphore = 0用來處理客人與理髮師的同步問題。有客人才被喚醒工作，若無則繼續睡覺。 barber：semaphore = 0用來處理客人與理髮師的同步問題。若理髮師忙碌等待並睡覺，反之進行理髮。 waiting：int = 0 目前座在等待區的人數。 \(\left\{\begin{matrix}客人入店 \; \Rightarrow waiting++ \\理髮師開始處理下一為客人 \Rightarrow waiting-- \end{matrix}\right.\) mutex：semaphore = 1對 waiting 變數做互斥處理，以免 Race condition。 Barber 程式 12345678910// barberwhile(conditon == false) &#123; wait(customer); // 目前沒有客人，Barber 睡覺去。 wait(mutex); waiting--; signal(barber); // 叫醒客人。 signal(mutex); // processing cutting hair // signal(barber); // worng code&#125; Costomer 程式 12345678910// customer: 注意! customer 並沒有需要 loop 剪髮的需求。wait(mutex); if(waiting &lt; n) &#123; waiting++; signal(customer); // 叫醒/通知 Barber。signal(mutex); wait(barber); &#125; else &#123;signal(mutex); &#125; secondreaderwriterproblem_2 The Dining-philosophers Problem (哲學家用餐問題) dining_philosophersproblem 倆倆之間有一隻筷子，哲學家若感到飢餓，必須要能夠同時取得左右兩根筷子才能用餐。用完餐後放下左右兩根筷子，進行思考模式。 ＜Note＞ 中餐，奇數或是偶數位哲學家皆可以，因為左右邊都可以是一根筷子。 西餐，一定為偶數個哲學家，因為為吃飯需要一副刀叉。 thedinningphilosopherproblem2 共享變數 chopstick[0…4] of semaphore = {1 … 1}對 5 根筷子進行互斥控制。 i (i：0…4) 哲學家：\(Process \; P_i\) Philosopher 程式 (fall) 12345678910// philosopherwhile(condition==false) &#123; // need processing... wait(chopstick[i]); wait(chopstick[(i+1)%5]); // processing signal(chopstick[i]); signal(chopstick[(i+1)%5]); // thinking&#125; 在上述程式碼中，若每位哲學家都依序先取得左筷，之後每位哲學家在取得右筷時，會直接形成「Circular waiting」，所以這程式很有可能會造成「Deadlock」。 thedinningpholosopherproblem3 解法一 最多只允許 4 位哲學家上桌用餐。 根據產生死結的定理：m = 5、\(Max_i = 2 \; where \; 1 \leq i \leq 5\)。 \(1 \leq Max_i \leq m\)，OK。 \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+ 5 \Rightarrow n &lt; 5\)。 保證 「Deadlock free」。 可以利用一個號誌來實現這個做法 s：semaphore = 4。 123456789101112// philosopherwhile(condition==false) &#123; // need processing... wait(s); wait(chopstick[i]); wait(chopstick[(i+1)%5]); // processing signal(chopstick[i]); signal(chopstick[(i+1)%5]); signal(s); // thinking&#125; 解法二 增加限制「除非哲學家可以同時取得左右邊兩隻筷子，才允許取得筷子，否則不得持有該筷子」。 要解決「Hold and wait」的問題。 解法三 增加一個限制「相鄰的哲學家取筷的順序必須不同」。 創造「Asymmtric」，則必不可能形成迴路，亦不能造成「Circular waiting」。 Ex. \(\left\{\begin{matrix} 偶數號 \quad 先取左再取右。\\ 奇數號 \quad 先取右再取左。\end{matrix}\right.\) 這種做法亦等同於在西餐時，規定每個人必須先取刀再取叉一致。 Semaphore 種類 分類一 - 區分號誌值域 Binary semaphore (二元) semaphore 的值指介於 0 或 1。 不可為負。 無法紀錄有多少個 Process 正在 wait semaphore。 12345678910111213141516171819S: Binary semaphore = 1;wait(S):// Entry section// Critical section while(s&lt;=0) &#123;// Leave section no-op// Entry section &#125;;// Critical section s--;// Leave sectionsignal(S):// Entry section// Critical section s++;// Leave section 1234// 用途wait(s); // Critical sectionsignal(s); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#include &lt;Windows.h&gt;#include &lt;thread&gt;using namespace std;bool choosing[10];int number[10];typedef struct b_Semaphore &#123; int v;&#125; BSEM;BSEM bsem;void P( BSEM &amp;s, int tid ) &#123;// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) _mm_pause(); while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) _mm_pause(); &#125; while(s.v&lt;=0) &#123;// Leave section number[tid] = 0;// Critical section _mm_pause();// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) _mm_pause(); while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) _mm_pause(); &#125; &#125;// Critical section s.v--;// Leave section number[tid] = 0;&#125;void V(BSEM &amp;s, int tid) &#123;// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) _mm_pause(); while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) _mm_pause(); &#125;// Critical section s.v++; if(s.v&gt;2) cout &lt;&lt; "error" &lt;&lt; endl;// Leave section number[tid] = 0;&#125;void Worker(int tid) &#123; P(bsem, tid); time_t rawtime; struct tm * timeinfo; time (&amp;rawtime); timeinfo = localtime (&amp;rawtime); cout &lt;&lt; "Thread " &lt;&lt; tid &lt;&lt; endl; printf ("Current local time and date: %s", asctime(timeinfo)); Sleep(1000); V(bsem, tid);&#125;int main()&#123; bsem.v = 1; vector&lt;thread&gt; ths; for(int i = 0; i &lt; 10; i++) &#123; choosing[i] = false; number[i] = 0; &#125; for(int i = 0; i &lt; 10; i++) &#123; ths.push_back(thread(Worker, i)); &#125; for (thread &amp; th : ths) &#123; if (th.joinable()) th.join(); &#125; return 0;&#125; Counting semaphore (計數) semaphore 值域在整數之上(可為負) 可以利用負值知道目前有多少 Process 正在等待 semaphore，ex. s = -n。 使用 Binary semaphore 實現 Counting semaphore。 共享變數 C：int代表 Counting semaphore 號誌值。 S1：binary semaphore = 1。對 C 作互斥控制，防止 race condition。 S2：Binary semaphore = 0。當 C &lt; 0 的時候，讓 process 暫停。 程式 123456789101112131415wait(C): wait(S1); C--; if(C &lt; 0) signal(S1); wait(S2); else signal(S1);signal(C): wait(S1); c++; if(c&lt;=0) signal(S2); signal(S1); 12345C: counting semaphore = 1;wait(c); // Critical sectionsignal(c); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;#include &lt;Windows.h&gt;#include &lt;thread&gt;using namespace std;bool choosing[10];int number[10];typedef struct b_Semaphore &#123; int v;&#125; BSEM;typedef struct c_Semaphore &#123; int c; BSEM s1; BSEM s2;&#125; CSEM;CSEM csem;void P( BSEM &amp;s, int tid ) &#123;// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) (void)0; while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) (void)0; &#125; while(s.v&lt;=0) &#123;// Leave section number[tid] = 0;// Critical section (void)0;// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) (void)0; while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) (void)0; &#125; &#125;// Critical section s.v--;// Leave section number[tid] = 0;&#125;void V(BSEM &amp;s, int tid) &#123;// Entry section choosing[tid] = true; number[tid] = *max_element(number, number+10) + 1; choosing[tid] = false; for(int i = 0; i &lt; 10; i++) &#123; while(choosing[i]) (void)0; while(number[i]&gt;0 &amp;&amp; (number[i]&lt;number[tid] || (number[i]==number[tid] &amp;&amp; i&lt;tid) )) (void)0; &#125;// Critical section s.v++; if(s.v&gt;2) cout &lt;&lt; "error" &lt;&lt; endl;// Leave section number[tid] = 0;&#125;void P(CSEM&amp; s, int tid) &#123; P(s.s1, tid); s.c--; if(s.c&lt;0) &#123; V(s.s1, tid); P(s.s2, tid); &#125; else &#123; V(s.s1, tid); &#125;&#125;void V(CSEM&amp; s, int tid) &#123; P(s.s1, tid); s.c++; if(s.c&lt;=0) &#123; V(s.s2, tid); &#125; V(s.s1, tid);&#125;void Worker(int tid) &#123; P(csem, tid); time_t rawtime; struct tm * timeinfo; time (&amp;rawtime); timeinfo = localtime (&amp;rawtime); cout &lt;&lt; "Thread " &lt;&lt; tid &lt;&lt; endl; printf ("Current local time and date: %s", asctime(timeinfo)); Sleep(1000); V(csem, tid);&#125;int main()&#123; csem.c = 3; csem.s1.v = 1; csem.s2.v = 0; vector&lt;thread&gt; ths; for(int i = 0; i &lt; 10; i++) &#123; choosing[i] = false; number[i] = 0; &#125; for(int i = 0; i &lt; 10; i++) &#123; ths.push_back(thread(Worker, i)); &#125; for (thread &amp; th : ths) &#123; if (th.joinable()) th.join(); &#125; return 0;&#125; 分類二 - 是否 Busy-waiting Spinlock 令 S 為 semaphore 變數。 123456wait(s): while(s&lt;=0); s--;signal(s): s++; Pros and Cons：與 busy waiting 優缺一致。 Non-Busy-waiting semaphore 1234567891011121314151617181920struct semaphore &#123; int value; Queue q;&#125;s:semaphorewait(s): s.value--; if(s.value &lt; 0) &#123; add process P into s.q; block(P); &#125;signal(s): s.value++; if(s.value &lt;= 0) &#123; remove a process P from s.q; wakeup(P); &#125; ＜Note＞這種實現的方法也算是 counting semaphore。 實現 Counting semaphore 要如何保證 semaphore 避免 Race condition，也要確保 wait 與 signal 等指令是不可分割的。 Non-busy waiting semaphore Spinlock semaphore Disable interrupt ☆ Alogorithm1 ☆ Alogorithm3 C.S. Design：Software sol.、Hardware sol. Alogorithm2 Alogorithm4 Alogrithm1 123456789101112131415161718192021222324252627// alogoithm1struct semaphore &#123; int value; Queue q;&#125;s:semaphorewait(s): // disable interrupt s.value--; if(s.value &lt; 0) &#123; add process P into s.q; // enable interrupt block(P); &#125; else &#123; // enable interrupt &#125;signal(s): // disable interrupt s.value++; if(s.value &lt;= 0) &#123; remove a process P from s.q; wakeup(P); &#125; // enable interrupt Algorithm2 將「Algorithm1」中的disable interrupt換成是entry section。 將「Algorithm1」中的enable interrupt換成是exit section。 12345678910111213141516171819202122232425// algorithm2struct &#123; int value; Queue u;&#125; semaphore;wait(s): // entry section s.value--; if(s.value &lt; 0) &#123; add process P into s.q; // exit section block(); &#125; else &#123; // exit section &#125; signal(s): // entry section s.value++; if(s.value &lt;= 0) &#123; remove process P from s.q; wakeup(P); &#125; // exit section Hardware solution 使用test_and_set()實踐「entry section」與「exit section」。 1234567// entry section// global waiting: boolean[] = false// global lock: boolean = false waiting[i] = true; while(test_and_set(lock) &amp;&amp; waiting[i]) ; waiting[i] = false; 1234567891011// exit section tmp = (i + 1) % n; while(tmp != i) &#123; tmp = (tmp + 1) % n; &#125; if(tmp == i) &#123; lock = false; &#125; else &#123; waiting[tmp] = false; &#125; software solution 使用「Bakery’s solution」。 1234567891011// entery section// global chooseing: boolean[] = false// global number:int[] = false choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; 12// exit section number[i] = 0; Algorithm3 123456789101112131415161718192021// algorithm3struct &#123; int value;&#125; semaphore;semaphore s;wait(s): // disable interrupt s.value--; while(s.value &lt;= 0) &#123; // enable interrupt sleep(random); // disable interrupt &#125; // enable interruptsignal(s): // disable interrupt s.value++; // enable interrupt Alogorithm4 123456789101112131415161718192021// algorithm4struct &#123; int value;&#125; semaphore;semaphore s;wait(s): // entery section s.value--; while(s.value &lt;= 0) &#123; // exit section sleep(random); // entery section &#125; // exit sectionsignal(s): // entery section s.value++; // exit section Hardware solution 使用test_and_set()實踐「entry section」與「exit section」。 1234567// entry section// global waiting: boolean[] = false// global lock: boolean = false waiting[i] = true; while(test_and_set(lock) &amp;&amp; waiting[i]) ; waiting[i] = false; 1234567891011// exit section tmp = (i + 1) % n; while(tmp != i) &#123; tmp = (tmp + 1) % n; &#125; if(tmp == i) &#123; lock = false; &#125; else &#123; waiting[tmp] = false; &#125; software solution 使用「Bakery’s solution」。 1234567891011// entery section// global chooseing: boolean[] = false// global number:int[] = false choosing[i] = true; number[i] = Max(number[0], ... , number[n-1]) + 1 choosing[i] = false; for( j = 0; j &lt; n; j++ ) &#123; while (choosing[j]) do no-op; // 等待P_j 取得號碼牌。 //比較號碼牌與 Process ID。 while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op; &#125; 12// exit section number[i] = 0; 無法完全避免的 Busy-waiting 定義 製作 semaphore Busy waiting \(\Rightarrow\) Non-busy waiting 在實踐「Entry section」時，就必須使用「Busy-waiting」。 semaphore Busy waiting \(\Rightarrow\) Non-busy waiting 若使用「Disable interrupt」，風險實在太高，且不適合用在多處理器( Multiprocessor )之上。 在 Semaphore 之下的 Busy waiting 是短暫的，不避太在意會浪費效能。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Process Management and Thread Management]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Process-Management-and-Thread-Management%2F</url>
    <content type="text"><![CDATA[Process 定義：A program in execution. Process 建立後，主要組成有：\(^{[1]}\)Process NO.(ID), \(^{[2]}\)Process state, \(^{[3]}\)Process menory space：Code section, Data section。 Programming Counter (PC)：下一條指令的位址。 Stack Cpu registers value 是 OS 分配資源(CPU, I/O - Devce, Memory)的基本單位。 與Program (程式) 的差異 Process Program 執行中的程式 只是一個在硬碟的檔案 “執行中”的單位 “被動的”單位 Procress Control Block 定義：作業系統為了管裡所有的 process ，會在 kernel memory 中，替每個 process 各自準備一個 block 紀錄 process 之所有相關的資訊。 內容： Process No. (ID)：是唯一( unique )的。 Process state：有 「ready」、「running」、「wait」…。 Programming Counter ( PC ) CPU registers：有accmulatorm, psw, stack top… CPU schedualing infomation：優先權值、process arrival time (FIFO)。 Memory management infomation：隨作業系統記憶體管理方式不同記錄不同的資訊。如：Base/limit register, page table 或 segememt table。 Accounting infomation：Pocess 已使用了多少 CPU time ，那些資源還剩多少資源、還剩 CPU time 可用，系統管理員依據此資訊用以調校效能。 I/O status infomation：Process 已發出多少 I/O-request，完成狀態如何，目前占用哪些 I/O 資源。 \(Ex29.\) (Ref P.4-75)：以下哪些項目是不包含在正常的 PCB 當中？ Process number CPU register I/O device queue：為作業系統管理，不屬於每個 process。 \(Ex34.\) (Ref P.4-78)：以下哪些項目是不包含在正常的 PCB 當中？ Process state The bitmap of this process：用於磁碟可用空間的管理方法。 Register State trasition diagram (S.T.D.) 用於描述 Process 的 Lifecycle。 五個狀態 狀態 New (Create)：Process 被建立，已分得 PCB 空間，尚未載入 memory( 尚未取得 memory 資源 )。 Ready：Process 已在 memory 中，且在 ready queue 內，具有資格爭奪 CPU。 Running：Process 取得 CPU 並執行中。 Wait( Blocked )：Process 在 waitting queue 中，等待 I/O completed 或 事件發生。( 不會爭奪CPU ) Exit( Terminate, Zombie, abort )：Process 完成工作正常結束或異常終止，此時可能其 PCB 尚未回收，因為要等其父親 (paraent-process)得到孩子(child-process)的成果之後，才會回收 PCB space。( 其他資源如memory, cpu, I/O-Device 等已回收 ) 轉換 Admited：當記憶體空間足夠時，可由 long-term scheduler依優先權決定此工作載入與否。( in Batch system, not in Time sharing, not in Interactive system ) Dispatch：由 short-term scheduler 決定，讓高優先權的process 取得 CPU。 Interrupt (Time-out)：執行中的 process 會因為某些事件發生而被迫放棄CPU，回到 ready queue。例如：Time-out, interrupt 發生，高優先權的 process 到達而被插隊。 Exit：Process 完成工作或異常終止。 1526880431737 *七個狀態 狀態 Block/Suspend：Process 被 swapout 到磁碟中暫存。(Blocked/Sleep in Disk) Ready/Suspend：事件完成或 I/O-completed。(Ready in Disk) 轉換 Admit (實線)：記憶體足夠時。 Admit (虛線)：記憶體不足時。 Block-Suspend ( Swap-out )：當 memory 空間不足且有其他高優先權 process 需要更多 memory space 時，會由 medium-term scheduler 決定將 blocked process swap-out 至磁碟以空出 memory space。 Block-Ready ( Swap-in )：這是一個不好的設計，但仍可以支持主要是因為若所有的「Blocked-suspend state」process 優先權皆高於「Ready-suspend state」process，且作業系統相信後者會比較早進入等待狀態時。 Ready-Suspend( Swap-out )：支持此行為( trainsition )的理由：\(^{[1]}\) 所有 blocked process 皆 swap-out 後 memory 仍不足時。\(^{[2]}\) 所有 blocked state process 之優先權皆高於 ready state process 時。 Ready-Active ( Swap-in )：當 memory 有空時，medium-term scheduler 可將process swap-in memory 之中(Ready)準備被執行。 Running-Suspend( Swap-out )：這是一個不好的設計，但仍可以支持主要是因為若有一個高優先權process 從 「Blocked/suspend」變為「Ready/suspend」時，則作業系統可以強迫低優先權的process放掉 CPU 及 memory，供高優先權的 process 使用。 1526883114200 Queuing diagram Queuingdiagram UNIX STD 1526885420905 Scheduler I/O-bound &amp; CPU-bound 1526887552589 I/O-bound Job 定義：此類型的工作大都是需要大量的 I/O operation( Resourse )但對於 CPU time( Computation )需求很少，所以其工作效能會受限於 I/O-device 之速度。 例如：資料庫管理、財報列印…。 CPU-bound Job 定義：此類型的工作大都是需要大量的 CPU time( Computation ) 但對於 I/O operation( Resourse )需求很少，所以其工作效能會受限於 CPU 之速度。 氣象預估的大氣模型、科學模擬…。 Long-term schduler 定義：又稱為 Job schduler，目的是為了從 Job-queue 中挑選一些工作載入到記憶體中。 特點： 執行頻率最低。 可以調控 Multiprogramming degree。 可以調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 由 Batch system 採用，但是 Real-time system 及 Time-sharing system 皆不會採用。 Short-term schduler 定義：又叫做CPU schduler 或 process schduler，目的是從「Ready queue」中挑出一個高優先權的 process，分派 CPU 給予執行。 特點： 執行頻率最高。 無法調控 Multiprogramming degree。 無法調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 所有的 system 皆採用。 ★Midium-term scheduler 定義：為 Time-sharing system 所採用。( 不為 Real-time system 所採用，因為該系統不支援 Swap-out - 虛擬記憶體 ) 目的：當記憶體空間不足時，且又有其他高優先權的 process 需要記憶體時，此 scheduler 會挑選一些process ( 例：Blocked process、低優先權 procss ) 將其 swap-out 到磁碟中保存，以空出記憶體空間，翁其他 process 使用，將來等到有足夠的記憶體空間被釋放時，此 sechduler可再將 Swap-outed process Swap-in 至記憶體等待執行( Ready for execution )。 特點： 執行頻率居中。 可以調控 Multiprogramming degree。 可以調控 I/O-bound Job 與 CPU-bound Job 之混和比例。 為 Time sharing system 採用，但 real-time system 與 batch system 不採用。 Context switching 當 CPU 要從 running process 切給另一個 process 使用之前，kernel 執行 context-switching 包含： 保存 running process 之目前狀態的資訊( PCB )。如：PC、stack、CPU register…。 要載入( Restore )另一個 Process 之狀態資訊( PCB )。 Context switching 是一額外負擔，其時間長短大都取決於硬體的因素。如：暫存器之數量、記憶體存取速度。 如何降低 Context switching 的負擔？ 方法一：若暫存器很多，則可以 讓每個 process 皆有私有的( private )「Register set」，則作業系統只要切換指標指向另一個 process 的「Register set」即可完成 context swiching，而不用記憶體的存取( store and restore )。 此種方法速度最快。 方法二：使用「Multithreading」機制。 方法三：讓 system process 以及user process各自有自己的 register set，如此一來兩者之間的切換只要改變指向register set 的 pointer 即可。 Dispatcher分派器 &amp; Dispatch Latency 分派延遲 定義：Dispatcher 為一模組用來將 CPU 控制權授予「經由 CPU scheduler」所選出之 process (user process)。 主要工作 Context switching ( 費時最久 ) Change mode from kernel mode to user mode Jump to the execution entry of that selected process 在做上述這些工作的時間的總和就稱為「Dispatch Latency」。 Dispatch Latency 越小越好。 Process control operations 也就是 process 的建立、終止、暫停、回復執行、設定、修改、讀取 process atteributes …，而這些都應是作業系統提供的服務(system call)。 Process 可以建立自己的 child process，目的是要 child process 工作。 Child process 的工作可分為兩類： 與 parent 相同的工作。(word編輯器) 特定工作 。(與 parent 不同) Parent 與 child 之互動關係 Concurrent execution Parent waits for child until child terminated Child process 的資源取得 方法一：作業系統供應 方法二：Parente供應 Parent 若終止，則 child process 會： 方法一 - Cascading termination：一併終止。 方法二：存活資源向\(^{[1]}\)作業系統取得，或向\(^{[2]}\)祖先 process 取得。 UNIX system call 1527077415190 fork()：用以建立 child process ，而 fork() 之回傳結果如下： 失敗，因為資源不足無法建立 process ，回傳 -1 給作業系統，在傳給 parent process。 成功，作業系統會回傳 \(^{[1]}\) 0，給 child process。 \(^{[2]}\) 大於 0 的正整數，給 parent process，且此值為 child process ID (PID)。 wait()：用以暫停 process 的執行直到某個事件發生。例如：parent 等到 child 直到 child 終止。 exit()：用以終止 process 的執行且回收期資源 ( 不包含PCB )，通常 \(^{[1]}\) exit(0) 表示正常終止。 \(^{[2]}\) exit(-1) 表示異常終止。 execlp() 或 exec() 或 execve()：用以載入特定的 Binary code( 可執行檔 ) 執行。 例：execlp(“目錄名稱”, “檔名”, 個數) getpid()：用以取得 process 的 ID。 1527077382823 ＜Note＞： 呼叫 fork() 後作業系統會配置 child process memory space，此空間與 parent 是佔用不同的記憶體空間，且 child 的資料區塊及程式碼區塊內容均來自 parent 的一份副本。 若 child 所做的工作與 parent 相同( 平行處理 )，則只要使用 fork() 便可達到此目的。 若 child 要做特定的工作(與 parent 不同)，則 child 必須執行 execlp() 以載入特定工作的執行檔。 1527077442901 程式實際操作 \(Ex1.\) 建立 child process 執行 ls 命定檔且 parent 等到 child 完成之後 parent 才輸出「child complete」。 Creating a separate process using the UNIX fork() system call. 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); //fork a child process if (pid &lt; 0) &#123; // error occurred fprintf(stderr, "Fork Failed\n"); return 1; //exit(-1); &#125; else if (pid == 0) &#123; // child process execlp("/bin/ls","ls",NULL); // 程式區塊指標轉換，下方不做，見上圖。 &#125; else &#123; // parent process wait(NULL); // parent will wait for the child to complete printf("Child Complete\n"); &#125; return 0;&#125; \(Ex2.\) (Ref p. 4-52) Identify the values of pid at lines A, B, C, and D. ( Assume that the actual pids of the parent and child are 2600 and 2603, respectively. ) 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid, pid1; pid = fork(); // fork a child process if (pid &lt; 0) &#123; // error occurred fprintf(stderr, "Fork Failed\n"); return 1; &#125; else if (pid == 0) &#123; // child process pid1 = getpid(); printf("A: Child: pid = %d\n",pid); // A -&gt; 0 printf("B: Child: pid1 = %d\n",pid1); // B -&gt; 2603 &#125; else &#123; // parent process pid1 = getpid(); // child process ID printf("C: Parent: pid = %d\n",pid); // C -&gt; 2603 printf("D: Parent: pid1 = %d\n",pid1); // D -&gt; 2600 wait(NULL); &#125; return 0;&#125; \(Ex3.\) (Ref p. 4-53) 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int value = 5; // global varibleint main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process value += 15; return 0; &#125; else if (pid &gt; 0) &#123; // parent process wait(NULL); printf("PARENT: value = %d\n",value); // LINE A value -&gt; 5 return 0; &#125; return 0;&#125; ★\(Ex4.\) 程序的並行 求輸出結果？ ( Tip: 父與子是並行的。 ) 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process printf("A\n"); &#125; else if (pid &gt; 0) &#123; // parent process printf("B\n"); &#125; return 0;&#125; Ans： 12AB OR 12BA 都有可能。 求輸出結果？ ( Tip: 父與子是並行的。 ) 考慮： 1527080836257 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(void) &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process printf("A\n"); &#125; else if (pid &gt; 0) &#123; // parent process printf("B\n"); wait(NULL); &#125; printf("C\n"); return 0;&#125; Ans： 1234ACBC OR 1234ABCC OR 1234BACC ★\(Ex5.\) 共享變數 假設 Count 是 parent 與 child process 的共享變數，且初值為 5。 123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid; pid = fork(); if (pid == 0) &#123; // child process count++; printf("%d\n", count); &#125; else if (pid &gt; 0) &#123; // parent process wait(); count--; printf("%d\n", count); &#125;&#125; Ans： 1265 ＜Note＞：共享變數可用以下方式達成。 檔案共享。 UNIX 的 pipe。 共享記憶體區間。( Windows / Linux ) 假設 Count 是 parent 與 child process 的共享變數，且初值為 5。 考慮： 1527081997770 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt; using namespace std;int main(int argc, char **argv) &#123; int* count; count = (int*) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0); if (count == MAP_FAILED) &#123; cout &lt;&lt; "mmap failed..." &lt;&lt; strerror(errno) &lt;&lt; endl; return -1; &#125; *count = 5; pid_t pid; pid = fork(); if (pid == 0) &#123; (*count)++; &#125; else if (pid &gt; 0) &#123; (*count)--; &#125; cout &lt;&lt; (*count) &lt;&lt; endl; return 0;&#125; Ans： 1255 OR 1245 OR 1265 OR ( 當指令不是 atomic 時 ) 1266 OR ( 當指令不是 atomic 時 ) 1244 ★OR ( 當指令不是 atomic 時 ) 1246 ★OR ( 當指令不是 atomic 時 ) 1264 \(Ex6.\) 有幾個 process 被建立了？ including main() (Ref p. 4-54, Text book p. 150) 1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; /* fork a child process */ fork(); /* fork another child process */ fork(); /* and fork another */ fork(); return 0;&#125; Ans：8 個。 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; if(fork() == 0) &#123; // child process fork(); fork(); &#125; fork(); return 0;&#125; Ans：10 個。 1531135436305 ★ 12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; fork(); if(fork()&gt;0) &#123; // parent process fork(); &#125; else if(fork()==0) &#123; // child process fork(); fork(); &#125; return 0;&#125; Ans： 14 個。(30個) 1531136821130 1531137337724 ★★ 1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; for(int i = 0; i &lt; 3; i++) &#123; if(fork()==0) &#123; fork(); fork(); fork(); &#125; &#125;&#125; Ans：729 個。 1531138419381 1531139238689 \(i == 2\), 會再多新生 \(8 \times 81 = 648\) 加上原本的 81 個等於 729 個 Processes。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; for(int i = 0; i &lt; 3; i++) &#123; if(fork()==0) &#123; fork(); &#125; else if (fork()&gt;0) &#123; if(fork()==0) &#123; fork(); &#125; &#125; &#125;&#125; Ans：216 個。(1728 個) 1531139971022 \(i == 1\)，上面六個 Processes 會再各自生成 5 個行程，所以會再多生產 \(5 \times 6 = 30\) 個 Processes ，加上原本的 Processes 等於 36 個。\(i == 2\)，36 個 Processes 會再各自生成 5 個行程，所以會再多生產 \(5 \times 36 = 180\) 個 Processes ，加上原本的 Processes 等於 216 個。 printf(&quot;%d\n;&quot;, a);共做幾次？ 印出0幾次？ 印出1幾次？ 印出2幾次？ 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int a = 2; fork(); a--; printf("%d\n", a); if(fork()==0) &#123; a--; printf("%d\n", a); fork(); &#125; else &#123; a++; fork(); printf("%d\n", a); &#125;&#125; Ans： 1234567811002222 1531141578065 12345678910111213141516171819202122\\ 錯誤答案110022222222222222222 CPU 排程 評估 CPU scheduking 效能之五個準則(criteria) CPU utilization - CPU 利用度(率) \(\frac{CPU \; Process \; execution \; time}{CPU \; total \; time}\) \(CPU \; total \; time = process \; execution \; time + comtext \; switch \; time + idle \; time \dots\) $Ex. $ Process 平均花 5 ms 在 execution 上，花 1 ms 在 comtext switching，則 \(CPU \; utilization = \frac{5}{5+1}\) Throughput - 產能 單位時間完成的工作數目。 1527426695265 ★ Waiting time - 等待時間 Process 在 Ready Queue 中等待獲得 CPU 之等待時間的加總。 \(Ex.\)上圖的等待時間為 \((8-2)+(19-15) = 10\)。 ★ Turnaruond time - 完成時間 自 process 進入(到達) 到工作完成的這段時間差值。 $Ex. $上圖的等待時間為 \(26-2 = 24\)。 Response time - 回應時間 自使用者 (user process) 輸入命令(或資料)給系統後，到系統產生第一個回應的時間差。(Time-shaeing system, user-interactive application 特別重視。) 由上述可知，CPU utilization、throughput 愈高愈好；waiting time、turnaround time、response time 愈低愈好。 排班法則 Starvation Process 因為長期無法取得完工所需之各項資源，導致遲遲無法完工，形成「Indefinite blocking - 未知期停滯」現象。 容易發生在不公平對待的環境之中，若又有「Preemptive - 可搶奪機制」，則更容易發生。 解決方案：使用「Aging」技術。隨著 process 待在 system 內的時間逐漸增加，我們也逐步調高此process 的優先權，經過一段有限的時間後，此 process 會有最高優先權，故可取得需要的資源(resourses)完工。 ＜Note＞：soft real-time system 不採用 「Aging」。 Non-preemptive 與 premptive 法則 觀點一 Non-premptive 法則 除非執行中的 process 自願放掉 CPU，其他的 process 才有機會取得 CPU，否則就只能 wait ，不可逕自搶奪 CPU。 \(Ex.\) 自願放棄使用 CPU 的情況：完成工作、wait for I/O-completed after issue I/O-request …。 Pros Comtext switching 次數較少 ( 時間節省 )。 Process 之完工時間點較可以預期 ( preditable )。 比較不會有「Race condition problem - 資源競爭問題」。 Cons 排班效能較差，因為可能會有 「Convoy effect」。 不適合用在 Time-sharing system 與 Real-time system。 Preemptive 法則 執中的 Provess 有可能被迫放棄 CPU ，回到 Ready queue ，再將 CPU 指派給別的 Process 使用。 \(Ex.\) Time-out ( 用在分時系統 )、interrupt …。 Pros 排班效益較佳，平均 waiting / turnaround time 較小。 適用於 Real time system 與 Time sharing system。 Cons 完工時間較不可預期。 Context switching 次數較多，負擔重。 須注意 Race condition 的發生。 ★觀點二 從 CPU 排班決策(啟動)的時機點區分。 Running \(\rightarrow\) Block Ex. Wait for I/O-completed (自願) Running \(\rightarrow\) Ready Ex. Time out (被迫) Wait \(\rightarrow\) Ready Ex. I/O-completed (高優先權的 Process 開始需要 CPU，作業系統啟動排班器，低優先權的 process 被迫放棄 CPU ) Running \(\rightarrow\) Exit (terminate) Ex. Task completed (自願) 所以若排班決策之啟動點只包含 Running \(\rightarrow\) Block 與 Running \(\rightarrow\) Exit (terminate) 未包含 Running \(\rightarrow\) Ready 或 Wait \(\rightarrow\) Ready 則為 Non-preemptive，否則為 Preempt。 ＜Note＞：凡是 \(\ldots \rightarrow\) Ready 皆列入 Preemptive 元素，所以 Ready/suspend \(\rightarrow_{Swap\; in}\) Ready、New \(\rightarrow\) Ready … 也列入。 預估 Process Next CPU Burst Time 公式 \[ \tau_{n+1} = \alpha \cdot t_n + (1-\alpha) \cdot \tau_n \] \(\tau_{n+1}\)：下次預估值。 \(t_n\)：本次實際值。 \(\tau_n\)：本次預估值。 \(\alpha\)：加權值。(\(0 \leq \alpha \leq 1\)) \(Ex.\) 當\(\alpha = 0.5\) 1527475744485 ＜Note＞：\(\alpha\) 的值用於條整與歷史紀錄的相依性高低。 FIFO 到達時間最小的 process 取得 CPU，也就是說先來先做。 1527427440948 到達時間皆為 0。 到達順序為：P1、P2、P3。 Gantt chart。 FIFO Avg. waitting time \[ \frac{(0-0)+(24-1)+(27-0)}{3}=17 \] Avg. turnaround time \[ \frac{(24-0)+(27-0)+(30-0)}{3}=27 \] 分析 易於製作。 排班效能最差，即 Avg. waiting time &amp; Avg. turnaround time 最長 (其他準則不看)。 可能有「Convoy effect - 護衛效應」，許多 processes 均等待一個需要很長 CPU time 之 process 完成工作，才能取得 CPU，導致 Avg. waiting time 太長。 非常公平。 沒有 starvation 現象。 Non-premptive，不可搶奪、插隊。 SJF ( Shortest Job First ) 具有最小 CPU time 的 process，優先取得 CPU。 1527472805224 到達時間皆為 0。 Gantt chart。 1527472898945 Avg. waiting time \[ \frac{(0-0+(3-0)+(9-0)+(16-0)}{4}=7 \] 分析 排班效益最佳( Optimal ) 即 Avg. waiting/turnaround time 最小。Proof： 1527473571408 由上圖可知Waiting time for long job：\(0 \rightarrow CPU \; execution \; time_{short \; job}\)Waiting time for short job：\(CPU \; execution \; time_{long \; job} \rightarrow 0\)Avg. waiting ime：\(\frac{(CPU \; execution \; time_{short \; job}-0)+(0-0)}{2} &lt; \frac{(0-0)+(CPU \; execution \; time_{long \; job}-0)}{2}\) 以這種方式 Short job 所減少的等待時間必定大於等於 Long job 所增加的等待時間，所以會使平均等待時間變小，最後可歸納到必為最佳的排班法則。 不公平，偏好 short job。 可能會 Starvation (for long job)。 又可以分為： Non-preemptive ( SJF ) Preemptive ( SRTF or SRJF ) 較不適合用在 shortest-trem scheduler，因為 short-term schduler 執行頻率太高，所以很難在極短時間內預估出精確每個process 的 CPU burst time 又要挑出最小值，不易真正呈現出 SJF 之行為；但比較適合 long-term schduler。 SRTF ( Shorest Remaining-time Job First ) 又稱為 SRJF 或 SRTN ( Shorest Remaining-time Job Next )，即為「Preemptive - SJF」，將剩餘 CPU burst time 最小的 Process 取得 CPU，若「新到達的 process」 的 CPU burst time 目前執行中 process 剩下的 CPU time ，則新到達的 Process 可以插隊( Preemption )目前執行中的 Process。 SRTF Avg. waiting time for *SRTF 1527477828916 \[ \frac{ ((0-0)+(10-1)) + (1-1) + (17-2) + (5-3) }{ 4 } = 6.5 \] SJF \[ \frac{ (0-0)+(8-1)+(12-3)+(17-2) }{4} = 7.75 \] FIFO FIFO \[ \frac{ (0-0) + (8-1) + (12-2) + (21 -3) }{4} = 8.75 \] 分析 與 SJF 相比 SRTF 的平均 waiting / turnaround time 會比較小，但是付出較大的 Context switching 負擔。 不公平，偏好 Short remaining time job。 可能會有 Starvation。 屬於 Preemptive。 Priority Method 具有最高優先權的 Process 取得 CPU ，若多個 Process 權值相同，則以 FIFO 為準。 1527479225080 到達時間皆為 0。 Non-preemptive priority method 且 Priority number 愈小優先權愈大。 Avg. waiting time 1527479387651 \[ \frac{ (6-0)+(1-0)+(16-0)+(18-0)+(1-0) }{5}=8.2 \] \(Ex2.\) Process Arrvial time Priority Burst time P1 0 5 5 P2 2 2 3 P3 5 4 8 P4 10 3 4 P5 13 1 6 Preemptive priority method。 Priority number 愈小優先權愈大。 Avg. waiting time 1527486332570 \[ \frac{ ((0-0)+(23-2)) + (2-2) + ((5-5)+(20-10)) + ((10-10)+(19-13)) + (13-13) }{5} = \frac{37}{5} \] 分析 不公平。 可能會有 Starvation ，但可以用「Aging」解決。 分為 Non-preemptive 與 Preemptive。 是一個具有參數化的方法，給予高低不同的優先權值，可展現出不同的排班行為。 Priority 的定義 行為 Arrival time 愈小，優先權愈大。 FIFO CPU time 愈小，優先權愈大。 SJF 剩餘時間愈小，優先權愈大。 SRTF ★Round Robin 為 Time sharing system 所採用，作業系統會規定一個 CPU time Quantum (Slice) ，當 Process 取得 CPU 執行後，若未能在此 Quantum 完成工作，則「Timer」會發出一個「Time-out interrupt」通知作業系統強迫回收 CPU 並將此 Process 送回「Ready queue」中等待下一輪再取得 CPU 執行，每一輪之中，是採以 FIFO 的排班法則規劃。 Process CPU time P1 8 P2 4 P3 9 P4 5 到達時間為 0。 順序為：P1～P4。 Quamtum = 4。 Avg. waiting time。 1527829801602 \[ \frac{((0-0)+(16-4))+((4-0))+((8-0)+(20-12)+(25-24))+((12-0)+(24-16))}{4} = \frac{53}{4} \] Process *Arrival time CPU time P1 0 20 P2 2 5 P3 7 3 P4 13 8 Quamtum = 4。 Avg. waiting time。 1527831109693 \[ \frac{((0-0)+(8-4)+(16-12))+((4-2)+(15-8))+((12-7))+((18-13))}{4} = \frac{27}{4} \] Processs ★Arrival time ★★行程行為 P1 0 5 CPU + 6 I/O + 4 CPU P2 3 15 CPU P3 8 3 CPU + 10 I/O + 9 CPU P4 14 8 CPU Quantum = 5 (Ref p.4-111)。 1528097302440 Turnaround time。 P1 = 22 - 0。 P2 = 32 - 3。 P3 = 44 - 8。 P4 = 40 - 14。 Avg. waiting time。 \[ \frac{((0-0)+(18-11))+((5-3)+(13-10)+(27-18))+((10-8)+(32-23)+(40-37))+((22-14)+(37-27))}{4} = \frac{113}{4} \] ＜Note＞：有爭議的題目。 Process Arrival time CPu time P1 0 10 P2 4 9 P3 8 6 Quantum = 4。 1527833536050 不知道為 P2 還是 P1 先進入 Waiting queue。 分析 Time sharing system 採用此方法。 也為一種可參數化 (ex. Quantum)的法則。 公平。 沒有 starvation。 ★Preemptive。 Round robin 排班效益取決於 Time quantum 大小決定。 \(Ex1. \; Quantum = \infty\) 則 RR 會變成 FIFO，也可以說排班的效能很差。\(Ex2. \; Quantum \rightarrow 0\) 則 Context switching 太頻繁，CPU utilization 會變得非常差 (\(\approx 0\))。$Ex3. $ 根據經驗法則，若 Quantum 能讓 80% 的工作量在該時間完成，效能最佳。 ＜Note＞： RR 雖然是公平，但可支持差異化 ( 優先權差異 ) 的實現，請問該如何達成？Ans： 方法一 針對高優先權的 Process 在 Ready queue 中置入多個 PCB pointer 指向此 Process ，使得每一輪當中可以多次取的 CPU 的機會。 方法二 針對高優先權 Process 給予較大的 Quantum。 Round robin with priority 如果想在不改變 Round robin 排程演算法的情況下，欲使某寫 Process 有更多的 CPU 使用優先權 「Ready queue」的內容（協助 Round robin 演算法的排程） 指向各個 Process 之「Process control block」（PCB）的指標 所以，直覺的想法就是讓「高優先權」的 Process，在「Ready queue」中能插入更多指向自己 PCB 的指標 可以讓該 Process 有更多次的 CPU 使用權 優點 可以讓使用者給予某寫 Process 更高的優先權 因為 Round robin 排程演算法原本的性質（FCFS；無法被中斷），所以可以防止某些低優先權的 Process 發生「Starvation」 不必改變原始演算法的結構 缺點 因為每當「Time quantum」時間結束後，「Time interrupt」會隨之觸發，無論前後的 Process 是否相通皆需要做「Context switch」，而隨之而來的「Overhead」也會增加 當一個 Process 結束時，其原本位於「Ready queue」的其餘指標也要隨之刪除，但是由於「Queue」結構的特性，必須要將全部的元素都比對後才能確保將剩餘的指標完全移除 Multilevel Queues 將原本單一一條 Ready queue 變成多條 Ready queue ，且高低優先權不同。 Queue 之間也有以排班的方式管理，通常採取「Preemptive priority」管理。 每個 Queue 可以有自己的排班法則。 Process 一旦被置入於某個 Queue 中，就不可(不允許)在不同 Ready queue 之間移動。 1527835326994 $Ex. $ I/O - Bound 與 CPU - Bound Job 各自要置入哪種等級的 Queue 比較好？ Ans：I/O - Bound Job \(\Rightarrow\) 高優先 Queue ( 使用 CPU 不多 )；CPU - Bound Job \(\Rightarrow\) 低優先 Queue ( 會使用大量 CPU ) 分析 可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則—Critera ) 的項目眾多，有助於排班設計及效能調校之彈性 ( flexibility )。 不公平。 *有 Starcation。 Preemptive。 Multilevel Feedback Queues 與 Multilevel queue 相似，差別在於「允許」Process 在不同 Queue 之間移動。( 可以採取類似「Aging」的技術或是可以搭配「降級」的方式來避免「Starvation」 ) 分析 可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則—Critera ) 的項目眾多，有助於排班設計及效能調校之彈性 ( flexibility )。 不公平。 可解決 Starcation。 Preemptive。 結論 哪些是 Non-preemptive。 FIFO SJF Non-preemptive priority 哪些是 Preemptive。 SRJF RR Preemptive priority Multilevel (Feedback) queue 哪些沒有 Starvation。 FIFO RR Multilevel feedback queue 那些包含於( \(\subset\) )關係是錯的？ FIFO \(\subset\) Priority SJF \(\subset\) Priority FIFO \(\subset\) RR SJF \(\subset\) RR RR \(\subset\) MFQs Consider a preemptive priority scheduling algorithm based on dynamically changing priorities Larger priority numbers imply higher priority When a process is waiting for the CPU (In the ready queue, but not running), its priority changes at a rate α When it is running, its priority changes at a rate β All processes are given a priority of 0 when they enter the ready queue What is the algorithm that results from β &gt; α &gt; 0 ? 因為 β 的值比 α 還高，所以隨著該程序不斷在 CPU 執行，其優先權提升的變化度會比在「Ready queue」的程序還高，這使得「Ready queue」中的程序其優先權不可能大到可以插斷 CPU 正在執行的程序，所以為「FCFS排班演算法」 What is the algorithm that results from α &lt; β &lt; 0? 因為「Ready queue」的程序，其遞減變化度 α 會比在 CPU 執行的程序的遞減變化度 β 還高，新加入的優先權為零，而「Ready queue」的程序與正在 CPU 執行的程序優先權總是隨著時間遞減，所以新加入的程序永遠可以插斷目前執行的程序，且因為在 CPU 執行的程序遞減程度較緩，所已不可能被「Ready queue」中的程序插斷，所以為「LIFO排班演算法」 (補充) CPU utilization 計算 Modern 版 假設採 RR 排班，令 Time quantum 為 Q、Context switching time 為 S，Process 平均執行每隔 T 時間會發出 I/O-request，求下列狀況的 CPU utilization。 0 &lt; S &lt; T &lt;&lt; Q 1527838126019 所以 \(\frac{T}{T+S}\) 0 &lt; S &lt; Q &lt;&lt; T 1527838656554 所以 \(\frac{Q}{Q+S}\) 0 &lt; S = Q &lt;&lt; T 由上圖可知 \(\frac{Q}{Q+S} = \frac{Q}{Q+Q} = 50 \%\) Q 趨近於 0。 \(\frac{Q}{Q+S} \approx \frac{0}{0+S} = 0\)，CPU utilization 趨近於 0。 恐龍版 ( Ref p. 4-86 Ex.50 ) 10 個 I/O-Bound tasks、1 個 CPU-Bound task，I/O-Bound task 執行每隔 1ms 發出 I/O-request ，每個 I/O 運作花 10 ms ( 此例子有 CPU-Bound task 所以不會因此 Idle )。Context switching time: 0.1 ms，所有process 永遠不會結束，求 CPU utilization ，採 RR 法則。 Quantum = 1ms。針對 I/O-Bound task，在 Time-out 的同時也發出了 I/O-request，接著花 0.1 ms 在 Context switching，所以一個 I/O-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。針對 CPU-Bound task，會將所有 CPU time 用完後 Time-out ，接著花 0.1 ms 在 Context switching，所以一個 CPU-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 1 }{10 \times 1.1 + 1 \times 1.1} = \frac{1}{1.1} \approx 91\%\) Quantum = 10 ms。針對 I/O-Bound task，CPU time 用不完，隔 1 ms 後直接發出 I/O-request ，並也花 0.1 ms 在 Comtext switching 上，所以一個 I/O-Bound task 共花了 \(1 + 0.1 = 1.1\) (ms)。針對 CPU-Bound task ， 會將所有的 CPU-time 用完後 Time-out 接著花 0.1 ms 在 Context switching ，所以一個 CPU-Bound task 共花了 \(10 + 0.1 = 10.1\) (ms)。\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 10 }{10 \times 1.1 + 1 \times 10.1} = \frac{20}{21.1} \approx 94\%\) 特殊系統之排班設計考量 Multiprocessor system ASMP (Master-Slave 架構)：因為都是以 Master-processor 來排班，類似於過去單顆 CPU，所以沒有特殊的排班設計。 SMP：主要有兩個排班的機制。 方法一： 每個CPU 共享同一個 Ready queue ，當一個 CPU 完程某 Process 後，就去存取 Ready queue。設計重點： 必須提供上述 Ready queue 的互斥存取之機制，若未提供，則可能發生 Process 重複執行，或有 Process 被忽略的錯誤。例：CPU 去取 Process 之工作如下：第一步，取得(read) Queue Front 端 Process 之 PCB pointer；第二步，從 Queue 中刪除此 Process pointer 。 不須考慮附載平衡 (load balance)，因為每個 CPU 在工作都做完時會再繼續從 Ready queue 中挑選工作，不會讓自己閒置(idle)。 方法二：每個 CPU 都有自己的 Ready queue ，每個 CPU 只會檢查自己的 Ready queue ，不會去檢查其他 CPU 的 Ready queue ，有工作就執行，無工作就閒置 (idle)。設計重點： 不須有互斥存取的考量。 需考慮附載平衡 ( Load balanceing )，避免 CPU 之勞務不均 (有人忙、有人閒)。通常使用 2 種機制來調整 CPU 的附載 ( loading )： Push migration ( 移轉 ) — 像是領班、工頭 Pull migration — 好同事 Process affinity 在 multiprocesors system 中，當 Process 已決定某 CPU 上執行，則在他執行過程之中，盡量不要將之移轉到其他 CPUs 上執行，除非有其必要。( 如：Processor bad、Load balancing… )避免 CPU 之 Cache、暫存器的內容要複製且又要刪除該工作，而影響效能。 有兩種 Affinity： Hard-affinity：該 Process 不可移轉。 Soft-affinity：盡可能不移轉。( 若有需要，仍可移轉。) Real-time system 排班設計考量 Hard read-time system 1528098291707 排班設計考量 確認這些工作是否可排程 ( schedulable )？也就是 CPU 可否負荷？判斷公式：若 \(\sum_{i = 1}^n \frac{C_i}{P_i} \leq 1\) 則為可排程，反之為不可排程。其中：\(n\) 表示 Real-time event (Process)之數目、 $C_i$1表示 \(Event_i\) (Process)之所需 CPU time、P_i 表示 \(Event_i\) (Process)之發生週期( Period time )。例：有下列四個 Real-time event ，其 CPU burst time 分別是：20 ms、50 ms、30 ms、X ms。其 period time 分別是 80ms、100ms、300ms、1ms。則在可排程的要求情況下，X 不可超過多少？Ans：\(\frac{20}{80}+\frac{50}{100}+\frac{30}{300}+\frac{X}{1000} \leq 1 \Rightarrow \frac{X}{1000} \leq 0.15 \Rightarrow X \leq 150\) (ms)。 再考慮是否可以滿足各工作的 Dead line。有兩個排班則： Rate-monotonic scheduling EDF ( Eaeliest Deadline First ) 如何排程，以滿足各工作的 deadline？ Rate-monotonic 採取靜態的優先權值且可插隊( Preemptive )。 Period time 愈小，優先權值愈高。 $Ex1. $ Process Period time CPU time P1 50 20 P2 100 35 是否可排程化？ \(\frac{20}{50}+\frac{35}{100}=0.4+0.35=0.75 \leq 1 \Rightarrow\) OK 若規定 P2 優先權高，且為 preemptive，是否滿足 deadline？ 甘特圖 Ratemonotonic P1 未能滿足 deadline，P2 滿足 deadline。 採用 Rate-monotinic 是否滿足 deadline？ Period time 愈小，優先權愈高，所以 P1 的優先權高。 甘特圖 1528099381692 P1 滿足 deadline，P2 滿足 deadline。 $Ex2. $ Process Period time CPU time P1 50 25 P2 80 35 採用 Rate-monotinic 是否滿足 deadline？ Period time 愈小，優先權愈高，所以 P1 的優先權高。 甘特圖 1528099949133 分析： 並不保證可以滿足 deadline。 在靜態的優先權值要求下，是最佳的狀況( optimal )。(若該手法無法滿足 deadline，其他針對靜態優先權值的排班也無法滿足。) Earliest deadline First (EDF) 採用動態優先權值，且為可插隊。 規定 deadline 愈早，優先權愈高。 \(Ex 1.\) Process Period time CPU time P1 50 25 P2 80 35 以 Rate-monotinic 是否不牴觸 Deadline？ P1 的 Period time：50 &lt; P2 的 Period time：80，P1的優先權大於 P2 的優先權。 1528701363468 以 EDF 是否滿足 Deadline？ ﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：80，P1的優先權大於 P2 的優先權。 ﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：80，P2的優先權大於 P1 的優先權。 ﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。 ﹙4﹚ P1 的 Deadline：150 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。 ﹙5﹚ P1 的 Deadline：200 &lt; P2 的 Deadline：240，P1的優先權大於 P2 的優先權。 ﹙6﹚ P1 的 Deadline：250 &lt; P2 的 Deadline：240，P2的優先權大於 P1 的優先權。 ﹙7﹚ P1 的 Deadline：300 &lt; P2 的 Deadline：320，P1的優先權大於 P2 的優先權。 ﹙8﹚ P1 的 Deadline：350 &lt; P2 的 Deadline：400，P1的優先權大於 P2 的優先權。 ﹙8﹚ P1 的 Deadline：400 = P2 的 Deadline：400，P1的優先權等於 P2 的優先權。 1528704009904 \(Ex 2.\) Process Period time CPU time P1 50 25 P2 75 30 以 Rate-monotinic 是否滿足 Deadline？ P1 的 Period time：50 &lt; P2 的 Period time：75，P1的優先權大於 P2 的優先權。 1528704266407 以 EDF 是否滿足 Deadline？ ﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：75，P1的優先權大於 P2 的優先權。 ﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：75，P2的優先權大於 P1 的優先權。 ﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：150，P1的優先權大於 P2 的優先權。 ﹙4﹚ P1 的 Deadline：150 = P2 的 Deadline：150，P1的優先權等於 P2 的優先權。 1528705571205 分析 在可排程的情況之下必 EDF 保證最佳 (optimal)。(任何工作皆不違反 deadline) 理論上，CPU utilization 可達 100%，但實際上不可能達 100% ，因為還要再加上 Context switching、interrupt handling 等額外付擔。 Soft real-time system 就 CPU scheduling design必須要具備： 支援 preemptive-priority 法則。 不支援「Aging」技術。 盡可能降低 kernel dispatch latency time，可得 read-time process 可以即早工作。 降低 lermel latency 的困難處： 大部分的作業桶接不允許 kernel 整在執行 system call 或其他 system processes 時被 user process 任意的插隊 (preemption)，目的是要確保 kernel data structures 的正確性(就是避免有 race condition)，但是這種做法對於 soft real-time system 極為不利。 假設目前 kernel 正在執行一個「long-time」system call ( I/O-operation ) 而此時有一個 soft real-time process 到達(或是 fork())，但是他必須到 kernel 完成此 long-time system call 後才能取得 CPU。(Dispatch latency 太長)。要解決此問題原則是：必須插隊 kernal 且要保障 kernel data structure之正確性。 方法一 - Preemptive point 在 system call code 中加入一些「preemptive point」( 在此時點將 kernel 插隊是安全的 )，將來system call 執行時若遇到 preemptive point，system call 會先暫停 kernel 會檢查此時是否有 real-time process 到達。若有，方才的 kernel system call 會暫停執行， CPU 分派給 real-time process 使用；若無，方才的 kernel system call 繼續執行直到遇見下一個 preemptive point。 Cons：system call 中可以加入的 preemption point 數目不夠多(插入點有限)，Dispatch latency 仍然很長。 方法二 - kernel 可隨時被 real-time process 插隊 需要具備有對於 kernel 的共享 data structure/resource 提供嚴謹的「互斥存取」( synchronization機制 )，以確保資料之正確性。 Cons：使用互斥存取可能造成「優先權反轉 ( Priority inversion )」問題。 Priority inversion - 優先權反轉 高優先權的 process 所需要的共享 data/resourses 恰巧被一些低優先全 process 所把持，無法存取 (因為互斥存取控制)，造成高優先權等待低優先權 process 之情況，再加上低優先權 process 往往無法很快的取得 CPU ，已完成對共享 data/resources 之使用進而釋放資源，所以高優先權 process 被迫要等一段很久的時間。 解決方法：讓低優先權 process 暫時繼承高優先權的權值，使得低優先權 process 可以很快的 取得 CPU 完成共享 data/resource 之使用並釋放資源，同時也立刻恢復其原本的低權值。 Real-time system 之 dipatch latency 的架構 由兩個 phases 組成： Conflict phase Preempts kernel 低優先權釋放高優先權之 data/resource Disoatch phase Context switching Change mode to user mode Jump 1528637800281 Thread management Thread：又稱之為「Lightweight proces」，為作業系統分配 CPU time 之基本單位 (It’s a basic unit of CPU utilization)。( Process 是分配資源如：I/O, memory，的最基本單位 ) Thread 建立後，其私有的內容 ( 紀錄於TCB - thread control block 之中 ) 組成有： Programming counter CPU registers value Stack Thread ID, state … 此外，同一個 process 內之不同 threads 彼此共享此 process 的： Code section Data section Other OS resources (Open files, I/O resources, siginal, …) Code section 與 Data section 合稱為 Memory address space。 Tradition process (Single-thread model) 1528638942439 Multithreading mode 1528639073333 Pros Responsiveness：當 process 內執行中的 thread 被 blocked，則 CPU 可以交給此 process 內其他可執行的 threads 執行，故整個 process 不會被 blocked，仍持續執行，所以若將 multithreading 用在 user-interactive application，可增加對使用者之回應程度。 Resource sharing：因為 process 內之多條 threads 共享此 process code section，所以在同一個 memory space 上可有多個工作同時執行。 Economy：因為同一個 process 內之不同 threads 彼此共享此 process 的 memory 及其他作業系統的資源，所以 thread 之私有成份量少，故 thread 之 creation、context switching 更快、Thread 的管理成本更少。 Scalability (Utilization of multiprocessors Architecture)：可以做到同一個 Process 內之不同 threads 可在不同 CPUs 上平行執行，所以可以增加對 multiprocessors system 之效益(平行程度)提升。 Process VS. Thread Thread Process Light weight Process Heavy weight process Multithreading model Single-threaded model 是作業系統分配資源( Resource )的最基本單位。 是作業系統分配 CPU time 的最基本單位。 不同的 Processes 不會有共享的 Memory 以及其他資源，除非在 shared memory 的情形下。 同一個 process 內之 threads 彼此共享此 process 之 memory 與其他資源。 若 process 內的 single thread 被 blocked，則整個 process 也被 blocked。 只要 process 內尚有可執行的 threads 就不會被 blocked。 process 之 creation、context switching 慢，管理成本高。 process 之 creation、context switching 快，管理成本低。 對於 multiprocessors 架構之效益發揮較差。 對於 multiprocessors 架構之效益發揮較加。 Process 較無 race condition 問題。( 除非是採用「Shared memory」溝通 ) 因為同一個 Process 內之 Thread 彼此共享此 Process data section，所以必須對共享的資料提供互斥存取的機制，防止 Race condition。 適合使用 Multithread 開發的程式。 一個時間點有多個工作要同時執行。如：Client-server model。 不適合使用 Multithread 開發的程式。( 以傳統 process 開發即可 ) 一個時間點最多只有一個工作可執行。如：命令解譯器 ( UNIX 的 Shell )。 User thread and Kernel thread Thread management 的工作 (如：thread creation、thread destory、thread suspend、thread wakeup、thread scheduling、thread context switching) 由誰負責。 User-level Thread Thread management 是由在 User mode 之 thread library 提供的 APIs 以讓 user process 呼叫使用、管理。Kernel 完全不知道( be unknowed with ) user level threads 的存在。(只知道有 process 的 single thread)所以 thread management 不須 kernel 介入干預。 Pros Thread creation、context switching …等管理成本低，速度快。 Cons 當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。) 因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 $Ex. $ 舉凡 Thread liberary 皆是 user threads。 如：POSIX 的 pthread library ( 是只在UNIX、Linux系統上的規格 )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。 Kernel-level thread Thread managemet 完全由 Kernel 負責，kernel 知道每一條 thread 之存在並進行為護理。 ★不需要 Kernel 的任何協助。( With no support from kernel. ) Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 \(Ex .\) 大部分作業系統都支援。 Windows (2000、NT) UNIX、Linux … Solaris [ Modern例題 ]：CPU time 依照分配對象數平均分配 thread，\(P_a\) 有三條 threads ，\(P_b\) 有兩條 threads，則 \(P_a, P_b\) 各分到多少趴的 CPU time。 若全部的執行序皆為 User thread。Kernel 只知道有兩個 Process ，所以分配 CPU time 給\(P_a, P_b\) 各 50%。 若全部的執行序皆為 Kernel thread。Kernel 知道有 5 條執行序要來分配 CPU time，所以 \(P_a\) 分到 60 %，\(P_b\) 分到 40 %。 Multithreading model User thread to Kernel thread Many to one ( User thread ) 1528718261665 1528718722383 This model maps many user threads to one kernel thread. Thread management is done in User space. 與 User thread 一致，不同解釋法。 Pros Thread creation、context switching …等管理成本低，速度快。 Cons 當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。) 因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 $Ex. $ 舉凡 Thread liberary 皆是 user threads。 如：POSIX 的 pthread library ( 是只在UNIX、Linux系統上的規格 )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。 One to one ( Kernel thread ) 1528718998029 1528719859725 This model maps each user threads to a kernel thread. 與 kernal thread 不盡相同。 Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 *Process 每建立一條 User-thread，作業系統就必須配合產生一條 Kernel-thread 與 User-thread 搭配，所以若 User-thread 數產生眾多，則會讓作業系統負擔太大，耗資源大。 \(Ex .\) 大部分作業系統都支援。 Windows (2000、NT) UNIX、Linux … Solaris OS/2 Many to many ( Kernel thread ) 1528719979394 1528720444327 1530181565681 This model maps many user threads to a small or equal number of kernel thread. Pros 當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。) 可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。 負擔不和 one-to-one model 大。 Cons Thread creation、context switching …等管理成本較高，速度較慢。 製作、設計較為複雜。 \(Ex .\) Solaris 2 以上 ( Two-level modeling ) 1530181715559 1530182120849 Multithreading issues fork() issue 1530178012484 Child1：適用在「子程序」工作與「父程序」相同時。 Child2：適用於「子程序」與「父程序」不同時，也就是說「子程序」出生後立即呼叫「execl」system call。 Signal delivery issue 1530178614262 Signal 1530178832898 It’s used in UNIX to notify the process that a particular event has occurred. 當 process 收到 siginal 通知後，他必須處理 ( 可交 process 自行處理或交付給 default signal handler kernel 處理 ) Synchronous signal Divide-by-zero Illegal memory access Asynchronous signal 「ctrl - c」 by administrator Time-out by timer Signal Delivery Issue Case 1 ( Ex. Synchronous signal ) Signalisssue Case 2 ( Ex.「Ctrl-break」) 1530179630741 Case 3 1530179857612 Case 4 ( Set a default signal handler. Ex. Solaris ) 1530180057880 Thread pool 在 client-server model 中，當 server 收到 client 的 request 後，server 才建立 thread 以服務此一請求，然而 thread creation 仍需耗用一些時間，所以對 client 的回應不能非常即時，以「Thread pool」解決。Process ( server ) 事先建立一些 threads 置於「thread pool」中，當收到 client 的 request 後，就從「thread pool 」中指派一條可使用的 thread 以服務此請求，不須重新建立 thread ，回應較為即時，當此 thread 完成工作之後，再回到 thread pool 中待命，如果 thread pool 中沒有可用的 thread 則 client 的 request 需要等待。 Cons 萬一 process 事先在 thread pool 中產出過多 threads，對作業系統負擔較大，所以作業系統通常會限制 thread pool 的大小。 Thread 程式追蹤 pthread library 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;int sum; /* this data is shared by the thread(s) */void *runner(void *param); /* threads call this function */int main(int argc, char *argv[]) &#123; pthread_t tid; /* the thread identifier */ pthread_attr_t attr; /* set of thread attributes */ if (argc != 2) &#123; fprintf(stderr,"usage: a.out &lt;integer value&gt;\n"); return -1; &#125; if (atoi(argv[1]) &lt; 0) &#123; fprintf(stderr,"%d must be &gt;= 0\n",atoi(argv[1])); return -1; &#125; /* get the default attributes */ pthread_attr_init(&amp;attr);/* create the thread. 根據 attr 屬性值建立一條 thread，ID 記錄在 tid 中，執行 runner() 副程式*/ pthread_create(&amp;tid, &amp;attr, runner, argv[1]);/* wait for the thread to exit */ pthread_join(tid, NULL); printf("sum = %d\n",sum); // 輸出應為 15&#125;/* The thread will begin control in this function */void *runner(void *param) &#123; //若為 static 變數就為全域共享變數。 int i, upper = atoi(param); sum = 0; for (i = 1; i &lt;= upper; i++) sum += i; /*Thread 終止*/ pthread_exit(0);&#125; 12345678910111213141516171819202122232425#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;types.h&gt;int value = 0;void *runner(void *param); /* the thread */int main(int argc, char *argv[]) &#123; pid_t pid; pthread_t tid; pthread_attr_t attr; pid = fork(); if (pid == 0) &#123; /* child process */ pthread_attr_init(&amp;attr); pthread_create(&amp;tid,&amp;attr,runner,NULL); pthread_join(tid,NULL); printf("CHILD: value = %d",value); /* LINE C -&gt; 5 */ &#125; else if (pid &gt; 0) &#123; /* parent process */ wait(NULL); printf("PARENT: value = %d",value); /* LINE P -&gt; 0 */ &#125;&#125;void *runner(void *param) &#123; value = 5; pthread exit(0);&#125; 問題 Which following is shared by thread ? Static local variable 共享 Program text/executable binary (code section) 共享 Registers value of CPU 私有 Heap memory (code + data scetion memory space) 共享 Programming counter 私有 Stack memory 私有 Open files 共享 I/O-resourses 共享 Local variables 私有 Global variables 共享 參考 Operating Systems: Internals and Design Principles]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Deadlock]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Deadlock%2F</url>
    <content type="text"><![CDATA[Deadlock 系統中存在一組 processes，彼此形成 循環等待 的情況，造成這些 processes 皆無法往下執行，並降低產量 ( throughput ) 的現象。 1530163891325 死結成立的四個必要條件 ( 所以有一個不成立，則死結必不發生，但是若四個條件全部成立時，死結不一定會發生。 )If there are 4 conditions are true, then the deadlock will/can arise. \(\rightarrow\) false/true. Mutual exclusion：對於 Resource 而言，具有此性質的 resource ，在任何時間點最多只允許一個 process 持有/使用，不可多個 processes 同時持有/使用。$Ex. $ 大多數的資源皆具有此性質。如：CPU, memory, disk, printer…$Counter ; Ex. $ Read-only file 不具此性質。 Hold and wait：Process 持有部分的資源，且又在等待其他 processes 所持有的資源。 No preemption：Process 不可以任意剝奪其他 processes 所持有的資源，必須等待對方釋放資源才有機會取得資源。＜Note＞：若可 Preemption 則必無 Deadlock 頂多只有 Starvation。 Circular waiting：系統中存在一組 Processes 形成循環等待之情況。 1530163425234 ＜Note＞1. (恐龍版本)Circular waiting 代表 Hold and wait。2. (其他版本)Circular waiting 代表 Mutual exclusion、Hold and wait、No preemption。3. 為何 Single-process 必不會造成 Deadlock ？ 因為 Circular waiting 不存在，所以 Deadlock 不發生。 交通十字路口 Deadlock 路口：資源 車子：Process deadlock 與 Starvation 比較。 相同之處為都是 資源分配管理機制設計不恰當所導致。 Deadlock Starvation 一組 Processes 形成 Circular waiting ，造成這些 Process 皆無法往下執行。 Process 因為長期無法取得完工所需的各式資源，造成遲遲無法完工。 不可能有機會完工。 有完工的機會，但是機會渺茫、Indefinited block。 會連帶造成 Throughput 低落。 與 Throughput 高低無關聯。(其中 SJF、SRTF 效能示好的。) 一定會在 Non-preemption 的環境下。 容易發生在 Preemption 的環境。 解決方案：Prevention、Avoidance、Detection and recovery。 使用「Aging」技術解決。 Resource allcation graph ( R. A. G. ) 資源分配圖 令 \(G= ＜V, E＞\) 為一有向圖，代表 R.A.G.，其中： Vertex ( 頂點 ) Process 1530164365297 Resource 1530164408843 其中「。」數目代表該項資源的數目。 Edge ( 邊 )： Allocation edge 1530164614789 Request edge 1530164672585 $Ex. $ 1530166364004 結論 No cycle \(\rightarrow\) No deadlock。 Cycle 不一定有 deadlock。 1530166810415 此圖雖然有 Cycle，但因為 P3 必可以完工且會釋出一個 R2 Resource，再配置給 P2 使用，所以無死結。 1530166364004 因為 P4 必可以完工且會釋出 R3 Resource，再配置給 P3 使用，所以無死結。 除非每一類型的資源皆為 single-instance ( 單一數量 )，則有 Cycle 必有死結。 解決 Deadlock Prevention、Avoidance Pros 保證系統為 deadlock free。( 不可能進入「Deadlock state」) Cons 對資源的使用與限制與取得限制多，所以 Resource utilization 偏低，連帶 throughput 偏低。 不可能造成 Starvation。 Detection and Recovery Pros Resource utilization 相對較高， throuput 也較高。 Cons System 可能進入 deadlock state。 Detection and recovery 的成本很高。 Deadlock prevention 破除四個必要條件之其中一個，則死結必不發生。 針對「Mutual exclution」 因為 Resource 本來就有的性質，以致無法解決「Mutual exclution」帶來的問題。 針對「Hold and wait」 方法一：作業系統可以決定除非該 Process 可以一次取得全部所需資源，才允許持有資源，否則不得持有任何資源。 方法二：Process 可先持有部分資源，但當該 Process 要申請其他資源時，必須先釋出所持有的資源，才可以提出申請。 針對「No preemptive」 將該法則改為可強奪( Premptive )，並以優先權作為搶奪基準。( 但可能會造成 Starvation ) Process 持有的資源 欲申請的資源 P1 R1 R3 ( 可以申請 ) P2 R5 R3 ( 必須先釋出 R5 ) P3 R1、R5 R3 (必須先釋出 R5 ) *針對「Circular waiting」 「Resource ordering」：作業系統賦予每一類型資源一個唯一的 Resource ID，再規定 Process 必須按照 Resource ID asending (遞增) 的方式對資源提出申請。 證明「Resource ordering」：假設在這樣的規定下，系統仍存在一組 Processes 形成 Circular waiting 如下圖，依規定，我們可以推導出資源 ID 大小關係如：\(r_0 &lt; r_1 &lt; r_2 \ldots &lt; r_n \quad , r_i \; is \; unique.\)，但又 \(r_0 &lt; r_n &lt; r_0\) ，矛盾，所以 Circular waiting 必不存在。 1530168967415 Deadlock aviodance 當某個 process 提出某些資源申請時，則作業系統必須執行「Banker’s algorithm」以確認倘若分配給 Process 其申請資源後，系統未來是否處於「Safe state」；若為「Saft state」，則核准申請，否則為「Unsafe state」系統會否決該資源申請，Process 必須等一段時間後再重新申請資源，系統會再確認當時的狀態是否安全。 1528970642055 Deadlock 是 Unsafe 集合的 Subset。 Banker’s Algorithm 資料結構 n：Process 個數。 m：Resource 種類數。 \(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\) 提出的各式資源申請量。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Max：n \times m \; matrix \Rightarrow\) 各 Process 完工所需之各式資源最大數量。 \(Need：n \times m matrix = Max - Allocation \Rightarrow\) 各 Process 還需各式資源才能完工。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 1528971381784 演算步驟 確認 \(Request_i \leq Need_i\)若成立進入第二步，否則因為申請不合理導致終止 \(P_i\)。 確認 \(Request_i \leq Available\)若成立進入第三步，否則 \(P_i\) 一直等待直到資源可以使用時。 ( 演算結果 ) \(Allocation_i = Allocation_i + Request_i \quad Need_i = Need_i - Request_i \quad Available = Available - Request_i\) 依照第三步的演算值執行「Safety Algorithm」，若回傳「Saft state」則可以核准該申請，但若回傳「Unsafe state」則核駁該次申請。\(P_i\) 必須等待一段時間再重新提出申請。 Safty algorithm 資料結構 n：Process 個數。 m：Resource 種類數。 \(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\) 提出的各式資源申請量。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Max：n \times m \; matrix \Rightarrow\) 各 Process 完工所需之各式資源最大數量。 \(Need：n \times m matrix = Max - Allocation \Rightarrow\) 各 Process 還需各式資源才能完工。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 \(Work：[1\ldots m] \; of \; int \Rightarrow\) 代表系統目前可用的資源累積數量。 \(Finish：[1\ldots n] \; of \; int\) \(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\False \quad 尚未完工 \end{matrix}\) 演算步驟 設定初值$Work = Availabe Finish[i] ; i, 1 i n ; 設定為 ; false $ 試找一個 \(P_i\) 滿足：\(Finish[i] 為 False\)\(Need_i \leq Work\)若可以找到進入第三步，否則進入第四步。 設定\(Finish[i] = True \quad Work = Work + Allocation_i\)，接著進入第二步。 確認 \(Finish\) 陣列，若全部皆為 True 回傳「Safe state」，否則回傳「Unsafe state」。 Safe sequence / Safe stete 至少可以找出大於一組 「Safe sequence」稱為 Safe state 否則稱為 Unsafe state ，代表作業系統未來依此 Processes 順序可分配各 Process 所需的資源使得大家皆可以順利完工。 實際演練一 5 個 Processes：\(P_0, \ldots, P_4\) 3 種類型的 Resource：\(A, B, C\) 起始資源量：\((A, B, C) = (10, 5, 7)\)求取 \(Need[]\) 與\(Available[]\)\(P_1\) 提出 \((A, B, C) = (1, 0, 2)\) 之資源申請，請問是否予以核准或是核駁，請說明。 1531184487179 1531184825933 Banker’s algorithm \(Request_1 = (1, 0, 2)\) 確認 $ Request_1 (1, 0, 2) Need_1(1, 2, 2)$，OK ( goto step2 )。 確認 $ Request_1 (1, 0, 2) Available(3, 3, 2)$，OK ( goto step3 )。 Safty algorithm。 Safty algorithm Initial value：\(Work = Available = ＜2, 3, 0＞\) 因為可以找到一個 Process \(P_1\) 供應 Resource 並使之得以完成該工作。滿足：\(Finish[1] = False\quad Need_1 \leq Work\)，OK ( goto step3 )。 設定 \(Finish[1] = True \quad Work = Work + Allocation_i\)，goto step2。…在 Step2 不斷重複的尋找是否有 \(P_i\) 尚未完工且目前資源可以予以完工… 最後確認 \(Finish[]\) 全皆為 \(True\) 後回傳「Safe state」。 列出其 Safe sequence \(＜P_1, P_3, P_4, P_0, P_2＞\) 實際演練二 5 個 Processes：\(P_0, \ldots, P_4\) 3 種類型的 Resource：\(A, B, C\) 起始資源量：\((A, B, C) = (10, 5, 7)\)求取 \(Need[]\) 與\(Available[]\)\(P_4\) 提出 \((A, B, C) = (3, 3, 0)\) 之資源申請，請問是否予以核准或是核駁，請說明。 1531184487179 1531184825933 Banker’s algorithm 確認 $ Request_4 (3, 3, 0) Need_4(4, 3, 1)$，OK ( goto step2 )。 確認 $ Request_1 (3, 3, 0) Available(3, 3, 2)$，OK ( goto step3 )。 Safty algorithm。 Safty algorithm Initial value：\(Work = Available = ＜0, 0, 2＞\) 因為不能找到一個 Process \(P_i\) 供應 Resource 並使之得以完成該工作 Fall ( goto step4 )。 最後確認 \(Finish[]\) 非全皆為 \(True\) 後回傳「Not safe state」。 Banker’s algorithm 的 Time complexity 令 n：process 數目、m：resource 種類數。 Step1 需要 \(O(m)\)。(檢查 request 是否大於 need) Step2 需要 \(O(m)\)。(檢查目前剩下資源是否充足可以給予 request) Step3 需要 \(O(m)\)。(若可以給予，將原本的 need、allocation、available) Safty algorithm 的 time complexity。 Safty algorithm 初值設定、每次工作需要 \(O(m)\)、將所有 processes 確認一遍需要 \(O(n)\)。 最多檢查 \(n + (n-1) + (n-2) + \ldots + 1 = \frac{(n+1) \cdot n}{2}\) 個 process 每次檢查 \(Need_i \leq work\) 需要 \(O(m)\) ，加總起來為 $O(n^2 m) $。 使用 $ O(n) $ 確認所有 processes 都做完檢查。 Single-instance resource algorithm 可以化簡較為簡易的 avoidance 檢查方法。 利用 RAG，加上「Claim edge」使用。 1530172024919 clam edge (虛線)：代表 \(P_i\) 未來會對 \(R_j\) 提出申請。(即為 Max/Need 的意義) 演算法 ( 當 \(P_i\) 提出 \(R_j\) 申請 ) 檢查原本有無該宣告邊之存在，若有進入第二步，否則終止 \(P_i\)。 確認 \(R_j\) 是否可供使用，若可以進入第三步，否則 \(P_i\) 等待該資源 ( 由 Claim edge 轉為 Request edge )。 ( 演算結果 ) 暫時將宣告邊改為配置邊( Allocation edge )，進入第四步。 確認途中是否有 Cycle 存在，若無則為「Safe state (核准)」，若有 cycle 為「Unsafe ( 核駁 )」。 \(Ex .\) 1530172534581 若\(P_1\) 對 \(R_2\) 提出申請是否核准？因為沒有 Cycle 存在，所以 Safe 核准申請。 1530172797528 若為 \(P_2\) 對 \(R_2\) 提出申請是否核准？因為有 cycle 存在，所以核駁申請。 1530172966437 ＜Note＞：Deadlock 位於 Unsafe state 的集合之中，也就是說若目前的狀態是 unsafe state 有可能會導致死結，但也有可能不會導致死結。 *＜Theorem＞ Deadlock free 1530173438706 系統若有 n 個 processes、m 個 resources intsance ( 單一種類 )，且滿足下列條件： \(1 \leq Max_i \leq m\) ，單一 Process 不得要求超過該種類資源的上限。 \(\sum_{i = 1}^n Max_i &lt; n + m \Rightarrow \sum_{i = 1}^n Max_i - n &lt; m\) ，假設目前所有的 processes 都剩下一個資源未取得，而剩下的資源小於 m 代表的意思就是 $ m - （_{i = 1}^n (Max_i - n) ）1$，代表我們還有至少一個以上的資源可以使某些 processes 可以先結束，接著回收的資源就可以再分配給其他 processes。 則系統是不可能會有死結的 ( Deadlock free )。 \(Ex1 .\) 有 6 部印表機現在正被 Process 使用，每個 process 最多需要 2 部印表機才可以完工，則系統最多允許 幾個 process 執行以確保 Peadlock free ？ m = 6, \(Max_i = 2\)。(1) \(1\leq Max_i \leq m \Rightarrow 1\leq 2 \leq 6\)，OK。(2) \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+6 \Rightarrow n &lt; 6 \Rightarrow\) 最多 5 個 Processes。 $Ex2 . 有 10 部印表機現在正被 Process 使用，每個 process 最多需要 3 部印表機才可以完工，則系統最多允許 幾個 process 執行以確保 Peadlock free ？ \(Max_i = 3, m = 10\)。\(3n &lt; n+10, 2n &lt; 10 \Rightarrow n &lt; 5 \Rightarrow\) \(最多 4 個 \; Processes。\) Proof假設資源全部配置出去即為 \(\sum_{i = 1}^n Allcation_i = m\)，又 \(\sum_{i = 1}^n Need_i = \sum_{i = 1}^n Max_i - \sum_{i = 1}^n Allocation_i \Rightarrow \sum_{i = 1}^n (Max_i) - m \Rightarrow \sum_{i = 1}^n Max_i = \sum_{i = 1}^n Need_i + m\)。因為依照定理第二點 \(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow \sum_{i = 1}^n Need_i + m &lt; n+m\)，所以 \(\sum_{i = 1}^n Need_i &lt; n\)，此式代表至少有大於等於 1 個process 之 Need_i 為 0 代表 Process_i 可以完工，且 P_i 至少會釋出超過 1 個 Resource (因為按照定理第一點可以知道每個 process 只少會占用大於 1 個資源 Max_i 大於等於 1)，使得剩下的 processes 中又會有大於等於 1 個 processes 可以取得資源並完工。 Example（106 清華大學資工計算機系統） Consider a system consisting of m resources of the same type that are shared by n processes, each of which needs at most k resources. What is the minimum number of instances of resources to guarantee that the system is deadlock free? 假設每個「Resource」有 x 個「Instance」，則： \(n\times (k-1) &lt; x \times m \Rightarrow x &gt; \frac{n\times(k-1)}{m} \\ \Rightarrow x \geq \lceil\frac{n\times(k-1)}{m}\rceil+1\) Deadlock detection and recovery 如果放任 Resources 無限制的使用，雖然 Utilization 高，但是系統有可能進入死結而不自知，所以需要有一個死結偵測的演算法以及解決 ( Recovery ) 死結的方法。 Detection ＜Note＞ Avoidance ( Banker’s algorithm ) 含有未來的資訊 (Max, Need)。 Detection 只有目前的資訊 ( Current infomation )。 資料結構 n：Process 個數。 m：Resource 種類數。 \(Allocation：n \times m \; matrix \Rightarrow\) 各個 Process 目前持有的各式資源數量。 \(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\) 系統目前可用的各式資源數量。 \(Work：[1\ldots m] \; of \; int \Rightarrow\) 代表系統目前可用的資源累積數量。 \(Finish：[1\ldots n] \; of \; int\) \(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\ False \quad 尚未完工 \end{matrix}\) *\(Request：n \times m \; matrix \Rightarrow\) 各 Process 目前對各式資源提出的申請量。 演算法 初值設定\(Work = Available\)，因為目前沒資源的 process 不會導致 deadlock，因為不會有 hold and wait 的問題所以\(Finish[i] = \{\begin{matrix}True \quad if \; Allocation_i = 0 \\ False \quad if \; Allocation_i \neq 0 \end{matrix}\) 試找一個 \(P_i\) 滿足\(Finish[i] = False \; AND \; Request_i \leq Work\)若找到進入第三步，否則進入第四步。 設定 \(Finish[i] = True \quad Work = Work + Allocation_i\)，回到第二步。 確認 \(Finish\) 陣列，若全部皆為 true，而我們可以得知目前沒有死結的可能。否則我們可以得知目前有死結的存在，而且 \(Finish[i] = false\) 的 Process 會陷入該死結之中。 Time complexity \(O(n^2 \cdot m)\)：死結偵測一次的時間需求很高，還要再乘上偵測的頻率，所以總體的成本很可觀。 實際演練一 1531188159444 \(Work = Available (0, 0, 0)\) 可以找到 \(P_0\) 予以 Resource 後可完工且 \(Finish[0] = False\)，\(Request_0 \leq Work\) 前往第三步。 設 \(Finish[0] = True\) ，\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\) 前往第二步。 可以找到 \(P_2\) 予以 Resource 後可完工且 \(Finish[2] = False\)，\(Request_2 \leq Work\) 前往第三步。 設 \(Finish[2] = True\) ，\(Work = Work + (3, 0, 3) = (3, 1, 3)\) 前往第二步。 在不斷的 (2) \(\Leftrightarrow\) (3) 之下，可以再找到 \(P_1, P_3, P_4\) 可以完工進入第四步。 最後確認 \(Finish[]\) 全皆為 \(True\) 後得知目前「Deadlock free」。 實際演練二 1531188115016 \(Work = Available = (0, 0, 0)\) 可以找到 \(P_0\) 予以 Resource 後可完工且 \(Finish[0] = False\)，\(Request_0 \leq Work\) 前往第三步。 設 \(Finish[0] = True\) ，\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\) 前往第二步。 找不到 \(P_i\) 可以利用目前資源完工，進入第四步。 最後確認 \(Finish[]\) 非全皆為 \(True\) 後得知目前有「Deadlock」，而在死結內的程序有 \(P_1, P_2, P_3, P_4\)。 Single instance resource algorithm 令 \(G = ＜V, E＞\) 有向圖代表「Wait-for Graph」，其中1. Vertex：只有 Process 而已，無 Resource 頂點。2. Edge：Wait-for edge。 1530174622303 從 RAG 簡化而成，即為： 1530174725109 1530174756704 較為 Detection 演算法簡單 使用「Wait-for graph」：在「Wait-for graph」中，若有 cycle 存在則目前有死結存在，否則目前無死結存在。 1529287297237 此「Wait-for Graph」有 Cycle，所以有死結存在。 1529287327536 Recovery Kill processes in the deadlock Kill 「all」 processes in the deadlock：先前的工作成果全部作廢，成本太高。 Kill process one by one，刪除一個 process 之後再使用偵測死結演算法，若死結仍存在，再多刪除一個 process。( 因為這種做法需要：O(loop 刪除次數$ $偵測成本 )，時間成本太高不值得 ) Resource preemption (資源剝奪) 選擇受害 Process。 剝奪該 Process 的資源。 回復該受害 Process 當初未被剝奪資源的狀態。(太困難，成本太高也可能會有 Starvation 的問題)]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Deadlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 3]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept-3%2F</url>
    <content type="text"><![CDATA[System Call It’s a programming interface to the services provides by the OS. 定義：幫助執行中的 user process 與 kernel 之間溝通，當 user peocess 需要OS提供某種服務時，會先以 Trap 通知 OS (由 User mode 轉為 Kernel mode) 並傳入System call ID (no.) 及所需參數，接著 OS 執行對應的 System call，完成後將服務結果回傳至 User process。 1526605131439 種類 (Ref P.3-8 ~ 3-9) Process Control：建立、終止、暫停、恢復執行 process，設定/讀取 process attribute。 File Management：建立、讀、寫、開啟、關閉、刪除檔案。 Device Management：讀、寫 Device。 Information of Maintenance：取得系統日期、時間，取得process屬性。 Communications：process之間的通訊，且只針對Massage Passing方式提供服務。 Protection：硬體資源的保護，檔案讀取控制。 System call 的參數(Parameter) 傳遞方式 暫存器( Register )：保存參數於暫存器之中傳遞給作業系統。Pros：簡單、存取速度快( 無記憶體存取 )。Cons：不適用於存取大量參數的情況。 記憶體( Memory )：以一個區塊( Block, Table )儲存這些參數並將此區塊的起始位址存於一個暫存器之中傳遞給作業系統。Pros：適用於大量參數。Cons：存取速度較慢，且操作較為麻煩。 系統堆疊( Stack )：將參數 Push 堆疊之中，作業系統再從堆疊 Pop 取得參數。Pros：也適用大量參數的傳遞，操作也很簡單。Cons：目前無( 可用暫存器或是記憶體實現堆疊 )。 \(Ex. 20\) (Ref P.3-36) 作業系統的架構( Structure ) 分類 Simple More complex than simple Layered approach Microkernel Module Hybrid Simple 無雙重模式( Duel-mode ) 單工 無模組化( Module )的設計 例如：MS-DOS More complex than simple Limited by hard functionality.( 因為當時硬體技術不夠成熟，作業系統受到硬體很大的限制 ) The original UNIX had limited structuring. 例如：UNIX UNIX 包含兩個分開的部分 System Programs Kernel Beyond simple but not fully layered. 1526608163203 Layered approach 1526609224214 定義： 採取 Top-down 的方式切割系統功能/元件以降低複雜度。 元件/模組之間呼叫關係分層，即：上層可以呼叫下層的功能，但下層不得呼叫上層的功能。 使用由 Button-up 的測試、除錯( 防止下層可以呼叫上層 )。 層次( Layer )的劃分沒有明確的規定。 Pros 降低複雜度。 有助於分工。 測試、除錯、維護容易。 Cons 很難精準的劃分層次。例如：\(A \rightarrow_{call} B \rightarrow_{call} C\) 但又因為某些原因必須要設計 \(C \rightarrow_{call} A\)，最後變成 \(A, B, C\) 都在同一層次；解決：將 \(C\) 再拆開分成不同層次(難)。 若層次太多，可能會導致作業系統的效能變差。 ＊Microkernel - 微核心 由卡內基-美隆大學( CMU )率先提出。 代表產品：Mach OS 定義：將 Kernel 中一些不必要的服務移至 User mode 提供服務，以 System program 方式存在，如次一來可以得到一個比較小的 Kernel 。 一般而言，微核心提供下列三個最必要的服務： Process control Memory Management (不包含Virtual memory) Process communications (只提供 massage passing 的服務) 1526610608669 Pros Easier to extend a microkernal. ( 因為服務是在User mode，服務的新增或刪除可以不會改到 Kernel 的架構，相對來說更簡單 ) Easer to port the OS to new archutectures.( 作業系統移植到新的服務平台-cpu不用改太多 ) More reliable. ( 若有一個服務失效時，對 Kernel 的傷害較小 ) More secure. Cons 效能差，因為存在大量的 User mode 與 Kernel mode 的訊息傳遞。 ＜Note＞：相對於微核心的相反\(\rightarrow\)Monolitic kernel。定義：所有的系統服務皆須在 Kernel 執行。( 商用如：Windows \(\Leftrightarrow\) 使用者無法輕易的更改功能 )Pros and Cons 皆與微核心相反。 Module - 模組化 Many OS implement loadable kernel modules. () Use object-oriented approach. Each core component is separate. Each talks to the others over known interface. Each is loadable as needed within the kernel. ( 需要該服務的時候再載入到記憶體執行，不需要時就從記憶體移除 ) Similar to “Layers” but with more flexible.( 效能更好 ) 例如：Linux, Solaris … Pros 因為與 Kernel 傳輸的距離不長，效能比較好。 1526611810996 Hybrid - 混和型 現在的 OS 很難純粹關屬於某一型。 \(Ex.\) Linux and Solaris 是 Monolitic 且也是Moduler for dynamic loading. \(Ex.\) Windows大致上是 Monolitic，有時真針對不同客戶的需求才會對一些子系統再加入Microkernel。 \(Ex.\) Apple Mac OS Kernel Mach microkernal Some of BSD UNIX I/O kit Dynamic loadable module( kernel extension ) 1526613108853 Aqua：負責 GUI 的顯示。 Vritual Machine 1530162737868 定義：利用軟體技術模擬出一份與底層硬體一模一樣的功能介面之抽象化機器( abstract machine )。 1526613748648 名詞解釋 Host：underlying hardware system, OS. ( 原生的硬體與 VMM 都可稱之為 Host ) VMM ( Virtual Macihine Management or Hypervisor )：Creates and managing/runs Virtual machine. ( 可以用硬體或是軟體實現 ) Guest：Process provided with virtual copy of the host. Abstract hardware of a single computer into several different execution environments. Similar to layered approach, but layer creates virtual machine(VM). Pros 為測試開發中的作業系統之良好的負載平台，具有：\(\;^{[1]}\)其他 user, user process 工作時仍可持續運作不須暫停；\(\;^{[2]}\)萬一測試中的作業系統不穩定，就算當機了也不會影響 Host hardware, OS, user procrss 的工作，因為只是相當於一個 user process 失效而已，不會對 system 有重大危害。 同一部 Host hardware 上可以在虛擬機中執行多個作業系統，可節省成本。 Consolidation( 資源的彙整、調度 )：在雲端運算環境時，通常會用有限的機器建立為數眾多的虛擬機，可以依虛擬機上的應用程式( Applications )之執行的負擔輕重調動 Host Machine 資源作為因應的支援。 較為安全，若被病毒入侵不至於擴散。( 虛擬機之間是獨立的個體 ) 可以 Freeze, Suspend, Running 及 Clone 虛擬機。 1526615255622 1526615230230 VMM的實現 主流 主要以模擬與底層一模一樣的環境(如 cpu)給作業系統使用，有分成下列三種模擬方式。 Type 0 Hypervisor ( Hardware ) Hardware - based solutions via firmware. Ex. IBM LPARS and Oracle LDOMs. Type 1 Hypervisor ( Kernel mode ) OS-like software. Ex. VMware ESX, Joyent SmartOS, Citrix XenServer. General purpose OS that provide VMM functions( Serveices ). Ex. MicroSoft Window Server with HyperV, Redhat Linux with KVM. Type 2 Hypervisor ( User mode ) Applications level provides VMM functionally. Ex. Parallel Desktop, Oracle VirtualBox. 非主流 所實現出來的 VM 不等同於 host 的硬體環境。 Paravirtualization The guest OS need modify to work in cooperator with VMM to optimize performance Preseents guest with similars but not identical to host hardware. (指模擬出常用的機器指令，將少用的指令移除以達到 VM最佳化) Guest must be modified to run on paravirtualization hardware. Application containment ( 創造一個執行環境 ) Oralcle Soaris Zones, BSD Jails IBM AIX WPARs. 1526804733939 Programming - environment virtualization VMMs do not virtualize real hardware but instand create an optimized virtual system. Ex. Java Virtual Machine (JVM) Microsoft.Net ＜Note＞：JVM is a specification (規格) , not a implementation. 其中規範有：\(^{[1]}\)Class Loader, \(^{[2]}\) Class Verifier, \(^{[3]}\) Java Interpreter. Emulator - 模擬器 ( 不同架構的cpu使用模擬器做轉換 ) Allow application writtem for one hardware to run on a very different hardware such as different type of cpu. Policy and Mechanism Policy 定義：“What” to be provided&quot; Policy 會經常改變。 Mechanism 定義：“How” to do that 「The underlying mechanism」甚少改變或不變。 設計原則 Policy and mechanism 最好分開設計，以增進系統的彈性( Flexibility )。 $Ex1. $ Mechanism：運用 Timer 幫助 cpu protection。 Policy：Max time Quantum 的大小制定。 $Ex2. $ Mechanism：cpu 排班採優先權高低。 Policy：優先權高低的定義。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 2]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept-2%2F</url>
    <content type="text"><![CDATA[基礎觀念 - Basic Concept (貳) 機器指令 Stage (階段) 1526805202151 IF：Instruction Fetch ID：Instruction Decode FO：Fetch Operands EXE：Execution WM：Write Result to Memory CPU 會 Memory Access DMA 要用 Memory IF 必用 Conflict ID 不使用 OK FO 可能使用 OK or conflict EXE 不使用 OK WM 可能使用 OK or conflict (P.3 - 66) (原文書 I/O Subsystem P. 596) DMA 之六個步驟： 1526805611478 驅動程序（CPU） 作業系統中的「裝置驅動程序」提出要求，欲將存於硬碟的資料傳輸至 RAM，並指定地址位在 x 的「Buffer」 「裝置驅動程序」接著命令「硬碟控制器」（Disk controller）傳輸 C Byte 到指定的位置 硬碟控制器（Disk） 對「DMA 控制器」作初始化設定 「硬碟控制器」使用「PCI bus」將每個位元組資料傳輸給「DMA 控制器」 原先不使用「DMA 控制器」的情況下，要將資料交給 CPU 再傳輸到 RAM 中 DMA 控制器 在接受自「硬碟控制器」傳來的資料後，將資料以「CPU memory bus」傳送到指定 RAM 中的位置 x；接著將 x 值遞增，C 值遞減直到成為 0 傳輸完成後，「DMA 控制器」觸發「Interrupt」以通知 CPU 中的驅動程序 Life cycle of I/O request (via Interrupted I/O) (P.3-65) (原文書P.612) 1526806092878 提升 I/O 效率 減少執行 I/O 時所觸發的「Context switch」（\(B^+—tree\)） 當程序（Process）要與裝置溝通時，減少資料對 RAM 存取的次數 在大量資料轉移、智慧控制器的運作、「Polling」執行時，盡量使用「Busy waiting」的方式解決短小的「I/O 等待」，減少觸發「Interrupt」的次數 增加 DMA 使用率，盡可能避免使用 CPU 來完成簡單資料的複製工作 讓某些簡單程序可以藉由裝置裡的處理器來執行，使得這些運算能與 CPU 並行 使 CPU、RAM控制子系統、I/O 裝置效能平衡，因為任何一個步驟發生錯誤很可能會導致系統的「停滯」（Idle） Blocking I/O and Nonblocking I/O Blocking I/O：Process suspended until I/O completed. Pros Easy to use and understand. 撰寫維護簡單，明確的知道什麼user program 需求 Cons Insufficient for some needs. 欲載入一個大型影片，如要等所有資料載完才反饋給使用者，將導致使用者體驗不好 Synchronous-I/O 也就是 Blocking I/O Nonblocking I/O：I/O return controll as much as available.（得以在提出 I/O 的需求後馬上交付控制權回來，所以該 Process 不用轉換至「Waiting state」） 應用 User interface、Data copy（Buffered I/O） 以多線程系統來實現技術 見 Thread-management ，若為「One to one」、「Many to many」系統，則某一個線程發出「I/O 請求」時，CPU 會移轉控制權給該程序的其他可執行的線程 快速的回傳些許目前 I/O 裝置保存於緩存器的資料 Asynchronous I/O：Process runs while I/O executes. 屬於「Nonblocking I/O」的一種 難以駕馭其功能 I/O 裝置完成需求後才將資料完整回傳並以「I/O subsystem」通知CPU 1526807435082 Intruupt 機制與種類 「Interrupt」觸發時 作業系統收到後，若該處理為必要時，則作業系統會暫停目前 Process 執行，且保存其 「Status」、「Register」（Context switch） 作業系統會依據「Interrupt ID」（Interrupt number）查詢「Interrupt Vector」以確認何種中斷被觸發，且找出其「Interrupt service routine」（ISR）在記憶體的位置 在處理器中的指令會跳至該服務程序位置，執行「Interrupt service routine」 完成「Interrupt service routine」後，將控制權返回給 Kernel 作業系統恢復（Resume）中斷之前 Process 的進行。 1526808564478 不同分類的「Interrupt」 分類一 「External interrupt」：CPU 以外的周邊設備、控制卡… 所觸發 I/O completed、I/O error、Machine-check… 「Internal interrupt」：CPU 在執行程式過程中，遭遇重大錯誤而觸發並且通常優先權最高 Divide-by-zero、執行非法的特權指令（Privileged instruction）… 「Software interrupt」：User process 在執行之中，若需要作業系統提供的服務，必須觸發此中斷以通知作業系統執行對應的服務 I/O request… 分類二 「Interrupt」：硬體裝置為了某些目的，需轉換目前處裡器裡執行的 Process 而產生的「通知信號」 「I/O 設備」為了告知 CPU 目前的狀態所以會觸發「I/O-completed」、「I/O-error」與「Machine-check」… 「Timer」為一種硬體，在協助「Round robin」排程、防止單一 Process 霸佔而保護 CPU 時，會觸發「Time out」 Trap：程序在執行時為了某些目的需要作業系統的協助而產生的「通知信號」 Arithmetic error Divide-by-zero、執行非法指令、非法記憶體存取… User process 需要作業系統提供服務，產生「Trap」以通知作業系統 I/O-request 分類三：以中斷的優先權高低分類 Maskable interrupt（遮蔽式中斷）：觸發後可被忽略或延後處理 Software interrupt （優先權低） Non-maskable interrupt（無蔽式中斷）：觸發後必須及刻處理 Internal interrupt（重大錯誤）、I/O error… Hardware Resource Protection 1526808604540 Dual mode operation - 雙重模式 作業系統的運作模式只少要可被區分為兩種模式 Kernel mode 又稱為「supervisor mode」、「System mode」、「Privileged mode」、「Monitor mode」 以此模式取得系統控制權（CPU）後，即可使用特權指令（Privileged instruction） User mode 「User process」通常在此模式之下，取得系統控制權且不允許執行特權指令 「Duel mode」必須要有硬體的支持才可以實現，CPU 內有「Mode bit」以區分現在狀態為何 Privileged instruction（特權指令） 任何可能會造成系統重大危害的指令，則通常為特權指令 唯獨在「Kernel mode」下才能執行，一旦在「User mode」之下執行會觸發「Trap」以通知作業系統，而應對處理通常會終止（Terminate）該 Process 的運行 包含 I/O instruction 為了保護 I/O 不被 User Process 濫用 記憶體清除指令 暫存器狀態修改指令 有關記憶體管理、保護而用的暫存器 如：「Base register」、「limit register」 「Timer」設定指令 為了保護 CPU 不被濫用 如：「Set」、「Change」 「Enable interrupt」、「Disable interrupt」 「Halt」 當系統無及時的工作需要完成時作業系統會利用此指令以切換至「Idle state」 自「User mode」轉換到「Kernel mode」之指令 Ex 33​ (Ref P.3-42) 以下哪些是特權指令？ Set the value of Timer Read the clock Clear Memory Turn-off interrupt Switch from user to kernel mode (1)(3)(4)(5) Ex 34 以下哪些是必要的特權指令，且讓使用者程序（User process）能更方便與兼顧安全？ (2)(3)(4)(5)(7) Change to user mode 若下放給「User mode」使用也無關緊要，不會使得「User process」得以進入「Kernel mode」 Change to monitor mode Read from monitor memory ☆ Write to monitor memory Fetch an instruction from monitor memory ☆ Turn on timer interrupt 「Timer」本來就保持啟動的狀態，所以此指令並不重要 Turn off timer interrupt (2)(3)(4)(5)(7) I/O Protection 將所有「I/O指令」設為特權指令，「User process」一律委託「Kernel」執行「I/O 運作」 I/O 運作繁瑣複雜，降低「User process」操控 I/O之複雜度 避免「User process」對「I/O 裝置」之不當操作 Memory Protection 防止「User process」存取其他「User process」之記憶體空間以及「Kernel」的記憶體空間 以「Contiguous memory allocation」為例，針對每個 Process 「Kernel」會提供一套「Base registers」與「Limit registers」 「Base registers」紀錄 Process 在記憶體中的起始位址 「Limit registers」紀錄 Process 在記憶體中的大小 1526809058649 Memory management unit（MMU；硬體）檢查是否逾越記憶體位置 （因為記憶體讀取很頻繁，若交由軟體檢查是否逾越則會導致中斷太多而讓效能低落） CPU Protection 防止「User process」無限期/長期佔用 CPU 而不釋放 以「Timer」實施保護 作業系統規定 Process 使用 CPU 之最大時限（Max time quantum） 當 Process 取得 CPU 之後，一開始會設定「Timer」裡的計時器為「Max time quantum」 隨著 Process 執行時間增加，計時器會逐漸遞減 當計時器結束時會一同觸發「Time-out interrupt」以通知作業系統強迫結束（Preemptive）該 Process 對 CPU 的使用權]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System - Basic Concept 1]]></title>
    <url>%2Fwillywangkaa%2F2018%2F07%2F10%2FOperating-System-Basic-Concept%2F</url>
    <content type="text"><![CDATA[基礎觀念 - Basic Concept (壹) 機器種類 - Machine type Bare Machine（裸機） 只有「Hardware Components」所組成（CPU、memory、I/O device），沒有任何輔助使用者（ User ）的系統程式（System Program）存在 Extended Machine 以「Bare Machine」為底加上輔助使用者的系統程式－System Programs（OS、Compiler、Database management system…） CPU 的等待時間（Idle time） 人類手動操作相對於「CPU cycle time」太慢 以「Automatic Job Sequence」的軟體常駐於在早期的電腦上，利用少量的記憶體執行非常駐於的電腦上的軟體，類似於現今的作業系統，稱之為「Resident Monitor」 I/O 裝置的工作速度遠比 CPU 的工作速度還慢，CPU 針對某些工作必須等待 I/O 工作完成後才能繼續執行，所以造成 CPU 等待時間（idle time）太久 以較快速的裝置介入 CPU 與 I/O 裝置之間作為緩衝 脫機 (Off-line 非即時運作 I/O) 1529920981306 不即時的將 CPU 演算完的資料給予讀取或是列印，利用專門的外圍控制機，將低速 I/O 設備上的數據傳送到高速磁碟（磁帶）上；或者相反，CPU 直接對於磁帶讀寫，使電腦加快讀取的速度 以磁帶機緩解讀卡機（Input）與印表機（Output）造成過慢的等待（Idle） 電腦中間以磁帶機的方式加速與讀卡機與印表機的溝通（讀卡機與印表機不直接由 CPU 直接操作） 磁帶機實作 以專用的 I/O 裝置對於磁帶讀寫（CPU 直接控制） 以一個小型的子電腦對於磁帶讀寫，習慣稱之為衛星機（Satellite processing），主要負責磁帶拷貝的工作，CPU 不直接參與磁帶機的讀寫運作 Pros CPU 不受到讀卡機或是印表機的速度限制（CPU 受到磁碟機的速度限制） 已寫好的程式不必更動，只要把原本直接交付給裝置執行的指令存入磁帶中再給該裝置執行 裝置獨立性（Device Independent） 泛指同一程式可以在不同的 I/O 裝置上執行的能力 Cons 因為要先讓電腦先將指令載入至磁帶，再交由該機器執行，導致設定時間需求長 磁帶只能以循序讀取（Sequential Access）的方式讀寫 緩衝區 ( Buffering ) 用以實現 CPU 能與 I/O 同時運作。可以想像成有一個超強者( CPU )，但是要跟一對弱者( I/O device )合作，是必要強者等待弱者將事情做完再交付給強者執行，而強者若要等到某一位弱者執行完後再執行太沒效率了，所以強者準備一個空間( 緩衝區 )給弱者將作完的工作丟入，再來就交由強者以不同策略使用緩衝區的資料達到最佳化。 I/O Bound Job 因為需要大量的 I/O 工作，速度受限於 I/O 裝置速度。 CPU Bound Job 因為需要大量的 CPU 計算，速度受限於 CPU 的處理速度。 假脫機－線上同時周邊處理技術( Simultaneous Peripheral Operation On-Line, SPOOL ) 又稱為「排隊緩存技術」；當系統中引入了多程序技術（Multiprocess）後，完全可以利用其中的一道程序，來模擬脫機輸入時的外圍控制機功能，把低速 I/O 設備上的數據傳送到高速磁碟上；再用另一道程序來模擬脫機（Off-line）輸出時外圍控制機的功能，把數據從磁碟傳送到低速輸出設備上。這樣，便可在主機的直接控制（On-line）下實現脫機輸入、輸出功能 1529918563313 外圍操作與 CPU 對數據的處理可以同時進行 「SPOOL」的需求 建立在具有多程序（Multiprocess）功能的作業系統 高速隨機外存（磁碟存儲技術） 組成 井：在磁碟上開闢的兩個大存儲空間 輸入井：模擬脫機輸入時的磁碟設備，用於暫存 I/O 設備輸入的數據 輸出井：模擬脫機輸出時的磁碟，用於暫存用戶程序的輸出數據 緩衝區：為了緩解 CPU 和磁碟之間速度不匹配的矛盾，在內存（RAM）中要開闢兩個緩衝區 輸入緩衝區：暫存由輸入設備送來的數據，一旦緩衝區要滿出來了，再傳送到輸入井 輸出緩衝區：暫存要送往輸出井送來的數據，往後再傳送給輸出設備 「輸入程序 \(SP_i\) 」 和「輸出程序 \(SP_o\)」，利用兩個程序來模擬脫機 I/O 時的外圍控制機 「程序 \(SP_i\)」：模擬脫機輸入時的外圍控制機，將用戶要求的數據從輸入機通過輸入緩衝區再送到輸入井，當CPU 需要輸入數據時，直接從輸入井讀入內存 「程序 \(SP_o\)」模擬脫機輸出時的外圍控制機，把用戶要求輸出的數據先從內存送到輸出井，待輸出設備空閒時，再將輸出井中的數據經過輸出緩衝區送到輸出設備上。 達到共享 I/O 裝置的目的 印表機（獨占設備）：當用戶進程請求列印輸出時，「SPOOLing 系統」同意為它列印輸出，但並不真正立即把印表機分配給該用戶進程，而只為它做兩件事： （1） 由「輸出程序」在輸出井中為之申請一個空閒磁碟塊區，並將要列印的數據送入其中 （2） 「輸出程序」再為用戶程序申請一張空白的用戶請求列印表，並將用戶的列印要求填入其中，再將該表掛到請求列印隊列上 （3）如果還有進程要求列印輸出，系統仍可接受該請求，也同樣為該進程做上述兩件事 （4）如果印表機空閒，輸出進程將從請求列印隊列的隊首取出一張請求列印表，根據表中的要求將要列印的數據，從輸出井傳送到內存緩衝區，再由印表機進行列印 （5）列印後，輸出進程再查看請求列印隊列中是否還有等待列印的請求表。若有，又取出隊列中的第一張表，並根據其中的要求進行列印 （6）直至請求列印隊列為空，輸出進程才將自己阻塞( Blocked )，僅當下次再有列印請求時，輸出進程才被喚醒( Wake up ) Pros 提高 I/O 的速度 從對低速 I/O 設備進行操作，演變為對輸入井或輸出井中數據的存取，如同脫機輸入輸出一樣，提高了 I/O 使用率，緩解了 CPU 與 I/O 設備之間速度不匹配的矛盾 將獨占設備視為為共享設備 「SPOOLing 系統」中，實際上並沒為任何進程分配設備，而只是在輸入井或輸出井中為進程分配一個存儲區和建立一張「I/O 請求表」 實現了虛擬設備功能 宏觀上，雖然是多個程序在同時使用一台獨占設備，而對於每一個程序會認為自己獨占了一個設備（ 邏輯上的設備） 「SPOOLing 系統」實現了將獨占設備變換為若干台對應的邏輯設備的功能 Spool 與 Buffer 的差異性 Spool 允許有程序在執行 CPU 運算時，可以有其他的程序的 I/O 運算同時進行（Overlay execution） Buffer 允許有程序執行 CPU 運算時同時運算（Overlay execution）該程序的 I/O 運算 系統種類 - System Type 多元程序系統 - Multiprogramming System 允許系統 ( 或在記憶體 ) 中存在多個 Process ( 處理程序 ) 同時執行；透過 CPU Scheduling 技術，當某個 Process 取得 CPU 執行時，若因為某些事件發生（如：Wait for I/O completed 、Resource Not Available…）而無法往下執行時，作業系統可將 CPU 切換給其他 Process 使用，則 CPU 在各個 Processes 切換，可以使 CPU 的使用率提升 主要用於避免 CPU 的空等（Idle），提高 CPU 效能（Utilization） Multiprogramming Degree 系統中存在執行的 Process 個數 通常 Multiprogramming Degree 越高，且非為 Thrashing 狀態，則 CPU 效能越高 多個 Process 同時執行的方法： Concurrent ( 並行 )：一個 CPU，多個 Processes 共同使用 1530087435637 Parallel ( 平行 )：多核心 CPU 共同執行多個 Processes 1530087726413 分時系統 - Time Sharing System It’s a logical extension of multiprogramming system, the CPU in this kind of system switch highly frequently. Multiprogramming 的一種，又可以稱為「Multitasking」 與 Multiprogramming 的差異在於 CPU 切換的頻率極高 排班使用「RR(Round-Robin) 法則」：作業系統規定一個 CPU Time Quantum，若 Process 在取得CPU後，未能於區段內完成工作，則必須被迫放棄CPU，等待下一次輪迴 通常 Quantum 時間很短 對每個使用者 ( 程序 ) 是公平的 適用在「User Interactive System」（互動式作業系統 ）或「Response Time」（反應時間）要求較短的系統 透過「Resource Sharing 技術」（CPU資源 - CPU scheduling、記憶體資源 - Memory sharing、I/O 裝置資源 - Spooling )，使得每個使用者 ( 程序 ) 皆認為享有專屬的資源 Virtual Memory 技術，擴展邏輯的記憶體空間 ( Virtual Memory Space )。 1530091014614 分散式系統 - Distributed System 多處理器系統 - Multiprocessors System ( 緊密耦合 - Tightly Coupled ) 又稱為 Mulitprocessing、Parallel system。 在一台機器 ( 或是在主機板 ) 中，具有多顆 CPUs ( 或是 Processors )。 共享此機器的資源：1. Memory2. Bus3. I/O - Devices4. Power supplier 通常聽從同一個時脈器 ( Clock )。 通常由通一個作業系統管理。 CPUs 溝通藉由「共享記憶體 - Shared memory」的方式完成。 可以進行平行運算 ( Parallel computing )。 Pros 增加吞吐量 ( Throughput )：可以使多個程序在不同的 CPUs 上執行 ( Parallel computing )。＜Note＞：「 N 個 CPUs 之產能」&lt;&lt;「一個有 N 倍 CPU 的產能」，因為會有問題存在使得產能抵銷：1. Resource contention - 資源競爭。2. Processor 之間的 communication。 增加可靠度 ( Reliability )：若有一個 CPUs 在執行時失效，然而還有其餘的 CPUs 可以繼續執行，使得系統不會因此停頓。＜Note＞1. Graceful degradation ( 漸進式滅亡 )：又稱為「Fail - soft」，系統不會因為某些硬體或是軟體元件故障而停頓，仍然保持運作的能力。2. Faild - Tolerent system ( 容錯系統 )：具有「Graceful degradation」特性的系統。 提升運算的經濟效益 ( Economy of scale )：因為「N 個 CPUs 在同一部機器」可共享該機器的資源 ( Memory、Bus、I/O - devices … ) ，所以較於「N 部機器」更為便宜而寫有效率。 1530093944139 Symmtric Multiprocessor - SMP 每個 Processors 的工作能力是相同的 ( Identical )，並且每個 Processors 皆有對等的權利存取資源。 Pros 可靠度較為 ASMP 高。 效能較高。 Cons SMP 的作業系統開發互斥存取的機制，使得設計較為複雜。 Asymmtric Multiprocessor - ASMP ASMP_2 每個 Processors 的工作能力不盡相同，通常採取「Master-Slave ( Boss-Employee )」架構。Master Processor 負責工作分派、資源分配與監督 Slave Processor 等管理工作，其餘的 Slave Processors 負責執行工作。 Pros 因為與開發「Single - CPU」的作業系統相似，所以相較為簡單。 Cons 可靠度較為 SMP 低。 由於 Master Procrssor 是效能的瓶頸，所以效能較低。 「Multiprocessor」 V.S 「Multicore Processor」 依作業系統的設計觀點是沒有差異的。( 將一個 Core 視為一個 logical CPU 資源 ) $Ex. $ 主機板中有 4 顆 Duel-core CPUs ，對於作業系統來說，視為 \(4 \times 2 = 8\) 個 CPUs 可以使用。 Multiprocessor 1530099598137 Multicore Processor Pros1. Power Saving2. 因為在同一個晶片之內，傳輸的速度較快。 multicore 分散式系統 - Distributed System 又稱為「Loosely-Coupled system ( 鬆散耦合系統 )」。 多部機器彼此透過網路( Network )、Bus 的方式相互串聯。 每部機器之 CPU 都有各個自有的 Memory、Bus、I/O-device … ，且並不共享，Clock time 也不盡相同。 每部機器的作業系統也不盡相同。 溝通採用「Message Passing」的方式。 建立連線 ( Communication Link )。 Message 相互傳輸。 釋放連結 ( Link )。 實現「Client - Server Computing Model」 Server：提供服務的機器。$Ex. $ Mail server、File server、DNS、Printer server、Computing server…。 Client：本身不提供服務，當需要某項服務時，向對應的 Server 發出請求，當 Server 服務完成，再將結果回傳至 Client。 ＜Note＞：「Peer-to-Peer Model」Peer：同時具有 Server 與 Client 的角色。 用以實現「Remote site communication」 $Ex. $ 透過網際網路可以實現 Email、FTP。 Pros Computation speed up - 增加吞吐量 ( Throughput )： 增加可靠度 ( Reliability )： Resource Sharing - 提升運算的經濟效益 ( Economy of scale )：所以成本低。 即時系統 - Real-time System Hard Real-time System 1530103496272 This system must ensure the critical task completed on time. 工作必須要再規定的時間內完成，否則會有重大危害的狀況發生。 設計考量： 所有時間延遲之因素皆須納入考量( 如：感測器資料傳輸速度、運算速度、Signal 傳輸速度… )，並且確保這些時間加總能在 Deadline 前做完。 所有會造成時間過久或無法預測之設備或機制，最好少用或不要使用。$Ex. $ 磁碟 ( Disk ) 最好少用或不用、虛擬記憶體 ( Virtual Memory ) 絕不使用。 針對 CPU 排班的設計，需要先考量是否可排程化 ( Schedulable )，在進行排程規劃 ( 如：Rate-monotonic、EDF scheduling )。 Time sharing system 無法與 Hard real-time system 並存。 現行的商用作業系統不支援 Hard Real-time 的特性。( 通常保留於客製化的作業系統之中。 ) 作業系統造成的「Dispatch latency」要盡量降低。 ＜Note＞：一般實務上，Hard Real-time System 少有作業系統的存在。 應用於：軍事防衛系統、核能安控系統、工廠自動化生產、機器人控制 …。 Soft Real-time System This system must ensure the real-time process get the highest priority than the others and retain this priority level until it completed. 應用於：Multimedia system、Simulation system、VR system …。 針對 CPU 排班的設計 必須支持「Preemptive priority scheduling - 可插隊排程」。 不可提供「Aging」功能。 儘量降低核心 ( kernel ) 的 Dispatch latency time。 可支援 Virtual memory，但是要求 Real-time processes 的全部 pages 在完工前，必須置於記憶體之中。 可以與「Time-sharing system」並存。 $Ex. $ Solaris。 一般商用作業系統皆支持 Soft real-time system 的功能。 批次系統 - Batch system 將一些較不緊急、定期性、非交談互動性 ( non-interactive ) 的工作，累積成堆，再分批送入系統處理。 主要目的：提高資源的利用度 ( Resource utilization ) 利用冷門時段的時間批次將工作送入執行。 不適合用於 Real-time system、User-interactive application。 $Ex. $ 庫存盤點、報稅、掃毒、磁碟重組、清算系統 …。 掌上型系統 - Hand Held System $Ex. $ PDA、Smartphone (智慧型手機)、PAD (平板) …。 硬體天生的限制會導致軟體必須配合的功能。 硬體限制 軟體應對設計 因為電源供應、散熱不易所以閹割處理器的性能 運算量宜簡單 記憶體有限 程式量宜小，並且要適當的管理記憶體，將不用的記憶體立刻釋放。 顯示器很小 ( 解析度、長寬比 ) 顯示內容精簡化 ( 手機網站須有所刪減 ) I/O 運作方式 詢問式 I/O - Polling I/O 又稱為 Busy-waiting I/O、programmed I/O 。 操作流程 User process 發出 I/O 要求給作業系統。 作業系統收到請求後，( 有可能 )會暫停目前此 process 的執行，並執行對應的 System calls。 Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。 裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。 裝置控制器起動，監督 I/O 設備的運作進行， 在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。 但是 CPU 在執行 Process 工作的過程中，卻要不斷去 Polling 裝置控制器以確保 I/O 運作是否完成或有 I/O-Error。 Cons CPU 耗費大量時間用於 Polling I/O 裝置控制器上，並未全用於 Process 執行，所以 CPU 的效能 ( Utilization ) 低，產量 ( Throughput ) 低。 1530157733165 中斷式 I/O - Interrupted I/O 操作流程 User process 發出 I/O 要求給作業系統 作業系統收到請求後，( 有可能 )會暫停目前此 process 的執行，並執行對應的 System calls。 Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。 裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。 裝置控制器起動，監督 I/O 設備的運作進行， 在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。 當 I/O 運作完成，裝置控制器會發出「I/O-completed」的中斷 ( Interrupt ) 通知作業系統 ( CPU )。 作業系統收到中斷後 ( 可能 ) 會先暫停目前 Process 的執行。 作業系統必須查詢「Interrupt Vector ( 中斷向量表 )」，確認是何種中斷發生，同時也要找到該中斷之服務處理程式的位置 ( ISR：Interrupt service routine )。 跳至 ISR 位置並執行 ISR。 ISR 完成後，交還使用權給 Kernel，Kernel 可能會作通知的動作給 User process。 恢復 ( Resume ) 原先中斷前的中作執行 ( 或交由 CPU 排程器決定 )。 Pros CPU 不需耗費時間用於 Polling I/O 裝置上，而是可以用於 Process 執行上，所以 CPU 效能 ( Utilization ) 提升、產量 ( Throughput ) 提升。 Cons 中斷 ( Interrupt ) 處理仍需耗費 CPU 的工作時間。 ＜Note＞：若「I/O 運作的時間」&lt;「中斷處理時間」，則使用中斷 I/O 就不是一個好選擇，因此 Polling 還是有其存在必要性。 若中斷發生的頻率太高，則大量的中段處理會占用幾乎全部的 CPU 工作時間，導致系統效能很差。 CPU 仍需耗費一些時間用於監督 I/O 裝置與記憶體之間的「資料傳輸」過程。 1530159007395 DMA (Direct Memory Access) I/O DMA-controller 負責 I/O 裝製與記憶體之間的資料傳輸工作，過程中無須 CPU 5 參與監督，所以讓 CPU 有更多時間用於 Process 執行上。 Pros CPU 效能 ( Utilization ) 更高。 適合用在「Block-transfer oriented I/O-device」上 ( 因為中斷發生頻率不至於過高 )，如：Disk。＜Note＞：不適合用在「Byte-transfer oriented I/O-device」。 Cons 因為 DMA 控制器( controller ) 會與 CPU 競爭記憶體與 Bus 的使用權，當控制器占用記憶體或是Bus時，CPU 要被迫等待，所以引進 DMA 控制器增加硬體設計的複雜度。 DMA controller 通常採用「Cycle stealing (Interleaving)」技術，與 CPU 輪替使用記憶體以及 Bus，若 CPU 與 DMA controller 發生衝突 ( conflict：同時要使用記憶體或 Bus )，則會給予 DMA 較高的優先權。 通常系統會給予「對該資源需求量頻率較小」的對象有較高的優先權，可以使得1. 平均等待時間較小。2. 平均產能較高。 參考 SPOOLing技術]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F19%2FDijkstra-algorithm%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344Graph&#123; set&lt;int&gt; V map&lt;int, map&lt;int, int&gt;&gt; E;&#125;Graph g;Graph sp;bool check[MAXN];int cost[MAXN];Node &#123; int id; int value; bool operator&lt;( const Node r ) &#123; return value&lt;r.value; &#125;&#125;void dijkstra (int s, int e) &#123; priority_queue&lt;Node, vecotr&lt;Node&gt;, greater&lt;Node&gt;&gt; pq; Node start; start.id = s; start.value = 0; pq.push_back(start); int last = -1; for(int i = 0; i &lt; MAXN; i++) &#123; cost[i] = INT_MAX; &#125; while(!pq.empty()) &#123; Node tmp = pq.top(); pq.pop(); if(check[tmp.id]) continus; check[tmp.id] = true; if(last!=-1) &#123; sp.V.push_back(tmp.id); sp.V.push_back(last); sp.V.E[tmp.id][last] = g.V.E[tmp.id][last]; sp.V.E[last][tmp.id] = g.V.E[last][tmp.id]; &#125; if(tmp.id==e) break; for(auto it: g[tmp.id]) &#123; if(!chcek[it.first]) &#123; if( tmp+it.second&lt;cost[it.first] ) &#123; Node tmpi = &#123;it.first, tmp+it.second&#125;; cost[it.first] = tmp+it.second; pq.push_back(tmpi); &#125; &#125; &#125; last = it.first; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[KNN and Radial Basis Function - K近鄰算法 與 放射狀基底函數網路]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F13%2FKNN-and-Radial-Basis-Function-K%E8%BF%91%E9%84%B0%E7%AE%97%E6%B3%95-%E8%88%87-%E6%94%BE%E5%B0%84%E7%8B%80%E5%9F%BA%E5%BA%95%E5%87%BD%E6%95%B8%E7%B6%B2%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前言機器學習分兩大類 Eager alogorithm(積極) 性質 將歷史資料做了很多分析與篩選( Munge )等預處理。 因為訓練出的假說很明確( Explicit )，所以自然判斷也比起 Lazy 方法更迅速。 \(Ex.\) Artifitial neural network Decision tree Lazy algorithm(被動) 性質 簡單的處理訓練資料，不會將資料轉成其他方式表達，所以資料不會因為處理過後而喪失一些屬性。 這種訓練方法在「判斷」未知案例時，因為要做的比對處理比較多，比起利用歷史資料先處理的 Eager算法需時更長。 因為這種方法是將資料做區域化的處理( Localized )，所以每次判斷全域( Generalization )時都要重新花一次時間。 \(Ex.\) KNN KNN and Radial Basis Function Instance-based Learning 以先前的案例( 未做處理或修飾的 )建立假說空間。 重點 概念 只有將先前的案例完整的儲存起來，不要有任何的修飾或是處理。 \[&lt;x_i, f(x_i)&gt;\] 最近鄰法 ( Nearest neighbor ) 給定一個要判斷的案例 \(x_q\)，接者我們在該案例空間中找到一個最靠近的先前案例以猜測之。 \(\hat{f}(x_q) \leftarrow f(x_{Nearest \; neighbor})\) 近 \(K\) 鄰法 ( KNN ) 給定一個要判斷的案例 \(x_q\)，接著我們在近 \(K\) 個鄰居之中做多數決選擇法。 ( 當目標結果 Target function 是離散值時 ) 給定一個要判斷的案例 \(x_q\)，接著我們在近 \(K\) 個鄰居之中取其平均數決定。 ( 當目標結果是在實數值時 ) \(i.e., \quad \hat{f}(x_q) = \frac{\sum_{i = 1}^k f(x_i)}{k}\) Voronoi Diagram - 沃羅諾伊圖 K-Nearest Neighbor knearestneighbor Voronoi Diagram (K= 1) voronoidiagram Nearest neighbor - 最近鄰法 重點性質 將所有的案例( Instance )儲存在一個 \(R^n\) 案例空間之中。( \(n\) 的多寡代表這些資料的 Attribute - 環境引響因素有多少 ) 盡量將 環境引響因素 去蕪存菁，最好少於 20 個 。 ＜Note＞： 引響的環境因素最好是具有意義實數且不可以太多。舉例：假設今天有一筆資料同時可以被兩個與三個的環境因素所表達，但在有三個環境因素案例空間的資料間隔會更分散。 Pros 訓練的時間很快。 可以學習很複雜的「目標函數 ( 概念 )」 不會捨去訓練資料的資訊。 Cons 判斷新進的案例需時很長。 容易被不重要的環境因素所誤導。 K-Nearest Neighbor Learning - 近 \(K\) 個鄰法 若今天給定資料案例 \(x\) 是由 \(n\) 個 attributes - 環境因素所構成，可以表達為：\(x = ＜a_1(x), \ldots, a_n(x)＞\)。 接者，使用平常對於歐基里德空間最熟悉的兩點求距( Euclidean distance ) \(d(i, j) = \sqrt{\sum_{r = 1}^n (a_r(x_i) - a_r(x_j))^2}\) ###Algorithm - 演算法 給定一個要判斷的案例 \(x_q\) 。 欲找到 \(k\) 個與 \(x_q\) 靠最近的 \(x_i\) 。( 利用 \(d(x_i, x_q)\) 判斷距離 ) 選出 \(k\) 個案例之中出現比較多次的結果作為 \(x_q\) 的結果。( 當這份資料的結果是由離散的資料組成採用此方法 ) - 以下圖舉例 \(k = 1\) ，判定 \(x_q\) 為正向輸出。\(k = 5\) ，判定 \(x_q\) 為負向輸出。 當資料的結果為連續的時數值時，我們判定 \(x_q\) 的輸出為 \(k\) 個鄰居的平均值。 建立的假說空間 使用 KNN 時我們建立的假說空間 \(H\) 不是明確的。 隱式的假說空間 \(H\) 將所有的訓練資料( 案例 )都完整地保留在我們建立的假說之中。 要檢驗新的 \(x_q\) 時，需要將所有的案例都檢查過一遍。 1-NN：\(H\) = Voronoi Diagram voronoidiagram2 距離權重近鄰法 Distance - Weighted \(K\)NN 欲考慮比較近的鄰居佔比越重。( 所以距離與權重呈現倒數的關係 ) \(\hat{f} \leftarrow \frac{\sum_{i = 1}^k w_if(x_i)}{\sum_{i = 1}^k w_i}\) \(w_i \equiv \frac{1}{d(x_q, x_i)^2}\) \(d(x_q, x_i)\) 是 \(x_q\) 與 \(x_i\) 的距離。 問題來了，那我們要選擇幾個鄰居作為參考值呢？ Shepard’s Method ：將整個案例空間所有的 \(x_i\) 都納入考量。 Curse of Dimensionality - 維度災難 (閱讀更多) 想像一個案例可以用20個環境變因( Attribute )所解釋，但是只有其中兩個變因是實際有影響的，若變因的維度太高可能會讓不重要的因素導致整個空間裡的案例之間的距離變得更稀疏，進而干擾我們最終呈現的「想法」。 解決方法：計算兩個案例之間的距離時對每個變因進行加權 這樣的方法相當於按比例縮放歐式空間中的坐標軸，先決定哪些環境邊因對我們的訓練比較重要(Try and error)，縮短對應到相關不大之變因的坐標軸，拉長對應於相關較大之變因之座標軸。每個座標軸的伸縮量可以透過交叉驗證的方法自動決定。 一些專有名詞 Regression - 回歸 逼近一個實數函數 \(f\) ( 最終「想法」) Residual - 殘差 「某樣本的均值」與「所有樣本集均值」的均值之偏離，代表取樣的合理性即該樣本是否具代表意義。残差大，表明樣本不具代表性，也有可能由特徵值引起。 ＜Note＞：誤差: 所有「不同樣本集的均值」之均值與真實總體均值的偏離量。由於真實總體均值通常無法獲取或觀測，因此通常是假设總體為某一分部類型，則有 \(N\) 個估算的均值；代表的是觀測/測量的精確度。誤差大，由變異數引起。表明數據可能有嚴重的測量錯誤，或者所選模型不合適。 要看一個模型是否合適，看誤差；要看所取樣本是否合適，看残差。 \(\hat{f}(x) - f(x)\) Kernel function \(K\) - 核心函數 \(K\) 決定距離的函數，用於決定權重影響的比例。 \(w_i = K(d(x_i, x_q))\) \(\Rightarrow w_i = K(d(x_i, x_q)) = \frac{1}{d(x_i, x_q)^2}\) Locally Weighted Regrassion - 區域加權回歸 ＜Note＞：全域法 v.s 區域法：在估計 \(f(x_q)\) 時， 全域法 將所有的案例 \(＜x, f(x)＞\) 納入參考。 區域法 只將區域的( knn )鄰居納入參考。 區域法 加權：由對應的案例 \(x_i\) 與 \(x_q\) 的距離產生的權重。 回歸：逼近一個實數的目標函式。 直觀 \(K\) - NN 對於目標函式 \(f(x)\) ，有一個 \(x_q\) 的需求時，產生一個區域型的逼近結果。 區域加權回歸其實就是泛化的 \(K\) - NN 。 藉由 \(x_q\) 劃出來的範圍 \(K\) 直觀( explicit )的逼近目標函式 \(f(x)\)。 舉例來說，可以一個「線性方程」表達 \(K\) 個鄰居的加權影響值。 \[ \hat{f}(x) = w_0 + w_1a_1(x) + \ldots +w_na_n(x) \] \(a_i\) 代表 \(x\) 對應環境變因的值。 特別的是，有可能可以用「非線性方程」來表達。 K 個鄰居以二次多項式( quadratic function )呈現權重值。 以「分段近似法( piecewise approximation )」求取 \(f\)。 ( 類似cubic spline的手法 ) 以各種不同的「殘差函式」將殘差降到最低求取最終的 \(f\) 在「 \(K\) 個鄰居」之間可以找到 Sum Square Error (SSE) \(E_1(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2\) 在「所有鄰居」之間可以找到距權 Distance-Weighted SSE \(E_2(x_q) \equiv \frac{1}{2} \sum_{x \in D} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\) 將上面兩者合體後 \(E_3(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\) Radial Basis Function Networks 放射狀基底函數網路 將所有的區域逼近組合成全域型地逼近目標函數 \(f\)，通常用於影像、訊號分析。 ＜Note＞：這種網路模型是完全不相干於「Artificial Neural Network - 類神經網路」，相較起來比較與「距離加權回歸」相近，但是以積極的( Eager )的方式而不是以被動的( Lazy )的方式實現。 radialbasisfunction \[ \hat{f}(x) = w_0 + \sum_{u = 1}^k w_u \times K_u (d(x_u, x)) \] \(a_i\)代表 \(x\) 的第 \(i\) 個環境變因，而 \(K_u (d(x_u, x))\) 已經定義為當距離 \(d(x_u, x)\) 變大時會隨之變小。 常用的 \(K_n\) ：Gaussian kernel function \[ K_u (d(x_u, x)) = e^{-\frac{1}{2 \times {\delta_u}^2} d^2(x_u, x)} \] ＜Note＞：常態分布( 又稱為高斯分布 ) \(y = p(x) = \frac{1}{\sqrt{2\pi \delta^2}}e^{-\frac{1}{2}(\frac{x-\mu}{\delta})^2}\) * 訓練 RBF 網路 問題一：對於核心函式\(K_u(d(x_u, x))\)，如何選定一個 \(x_u\) ？ 問題亦是在問如何選定套用一個樣板( prototypes )當作訓練模型。 確認何點為這個案例空間的「常態分布中心點」。 或是以其他的分布套用於該案例空間。 問題二：如何訓練權重( 假設使用Gaussian \(K_u\)的狀態下 )？ 對於每個 \(K_u\) 先設定為變異數( 或是平均數 )。 將 \(K_u\) 固定，訓練出一個線性式的輸出層。 參考 Quora - What is the difference between eager learning and lazy learning? 沃羅諾伊圖 K近邻算法(kNN) - 知乎专栏 机器学习：维度灾难问题- CSDN博客 残差residual VS 误差 error 機器學習技法學習筆記(7)：Radial Basis Function Network與Matrix Factorization 放射狀基底函數網路- 維基百科，自由的百科全書 - Wikipedia]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>KNN</tag>
        <tag>Radial Basis Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chinese Remainder Theorem - 中國剩餘定理專題]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F08%2FChinese-Remainder-Theorem-%E4%B8%AD%E5%9C%8B%E5%89%A9%E9%A4%98%E5%AE%9A%E7%90%86%E5%B0%88%E9%A1%8C%2F</url>
    <content type="text"><![CDATA[Modular 反元素 (模反元素、數論倒數) 整數 \(a\) 對同於 \(n\) 之模反元素滿足以下： \[a^{-1} \equiv b \quad (mod \; n)\] 等價於 \[a \cdot b \equiv 1 \quad (mod \; n)\] ＜Note＞：整數 \(a\) 對模數 \(n\) 之模反元素存在的充分必要條件(iff)是“\(a\)”與“\(n\)”互質。 求 Modular 反元素 輾轉相除法( 歐基里德演算法 ) 原理：\(a, b\)兩整數最大公因數等於各自\(( a , b )\)與兩數相差( a - b )的最大公因數。 \(Ex\)： 252 與 105 的最大公因數為 21 \(252 = 21 \cdot 12 \quad 105 = 21 \cdot 5\)\((21 \cdot 12) - (21\cdot 5) = 21 \cdot (12 - 5) = 21 \cdot 7 = 147\) \(gcd(252, 105) = gcd(252, 147) = gcd(147, 105)\) 使用原理的過程之中，較大的數的最大公因數可以由較小的數所代表，所以繼續進行同樣的計算可以不斷縮小\(a, b\)兩數，直到最後有一數變為 \(0\) 。這時所剩下的非零數就是兩數的最大公因數。 由歐幾里得演算法的過程之中，可以推出兩數的最大公因數能用兩數的整數倍( \(\forall k \in \mathbb{Z}\) )相加來表示，承上例：\(21 = 5 \cdot 105 + (-2) \cdot 252\) Bézout’s lemma - 貝組定理 (丟番圖方程) \(\forall a, b, m \in \mathbb{Z}\) ，求未知數 \(x, y\) 的線性丟番圖方程式（稱為貝祖等式）： \[a \cdot x + b \cdot y = m\] 當 $x, y $有整數解時若且唯若( \(\Leftrightarrow\) ) \(gcd(a, b)\; | \; m\) 。此等式有解時必然有無窮多個解，每組解 \(x, y\) 都稱為貝組數可用擴展歐幾里得演算法求得，也就是說若 \(a\) 為負數\(a \cdot (-x) + b \cdot y = m\) 有整數解時\(gcd(|a|, b) \;| \; m\)。 $Ex. $ 求 \(47 \cdot x + 30 \cdot y = 1\)，求 \(x, y\)？ $47 = 1 30 + 17 $ \(\Rightarrow 30 = 1\cdot 17 + 13\) \(\Rightarrow 17 = 1 \cdot 13 + 4\)\(\Rightarrow 13 = 3\cdot 4 +1\) 我們得知 \(gcd(47, 30) = 1\)且\(1 \; | \; 1\)，所以接著改寫成「餘數等於」的形式\(17 = 1\cdot 47 - 1 \cdot 30\) \(13 = 1\cdot 30 - 1 \cdot 17\) \(4 = 1\cdot 17 - 1 \cdot 13\)\(1 = 1\cdot 13 - 3 \cdot 4\)最後再反著倒寫回去\(1 = 1\cdot 13 - 3 \cdot 4\)\(\Rightarrow 1 = 1\cdot 13 - 3 \cdot (1\cdot 17 - 1\cdot 13)\)\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot 13\)\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot (1\cdot 30 - 1 \cdot 17)\) $1 = 430 + (-7)17 $ \(\Rightarrow 1 = 4\cdot 30 + (-7)\cdot ( 1 \cdot 47 - 1 \cdot 30 )\) \(\Rightarrow 1 = 47 \cdot (-7) + 30\cdot 11\) 其中， \(x = -7\) 與 \(y = 11\) 為其中一組貝組數，其無限解為 \(x = -7 + 30\cdot k, y = 11 - 47 \cdot k, \forall k \in \mathbb{Z}\) Modular 反元素 若貝組等式 \(a \cdot x + b \cdot y = 1\) (若 \(\neq 1\) 則模反元素不存在)則：\(a \cdot x = 1 - b\cdot y \Leftrightarrow a\cdot x \equiv 1 \quad (mod \; b)\)所以\(a \cdot a^{-1} \equiv 1 \quad (mod \; b)\) ，此時\(x\)為\(a\)的一個模反元素，其無限表示式為\(a^{-1} = x + k\cdot b, \forall k \in \mathbb{Z}\)。 Modular - 同餘的性質 整除性 \(a\equiv b \quad (\mod m) \Rightarrow c \cdot m = a - b , c \in \mathbb{Z}\)\(\Rightarrow a \equiv b\quad ( \mod m ) \Rightarrow m \; | \; a-b\) 遞移性 若 \(a \equiv b \quad (\mod c) , b \equiv d \quad (\mod c)\)則 \(a \equiv d (\mod c)\) 保持基本運算 \(\left \{ \begin{matrix} a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right.\) 放大縮小模數 令\(k \in \mathbb{Z}^+ , a \equiv b \quad (\mod m) \Leftrightarrow k \cdot a \equiv k \cdot b \quad (\mod k \cdot m)\) 費馬小定理 假設 \(a \in \mathbb{Z}\) 且 \(p\) 是質數 \(\ni gcd (a, p) = 1\)，則：\(a^p \equiv a \quad (\mod p)\)\(\Leftrightarrow a^{p-1} \equiv 1 \quad (\mod p)\) 由拉 \(\phi\) - 函數 假設 \(n \in \mathbb{Z}^+\)，定義\(\phi (n)\) 為 \(\\{ 1, 2, \ldots, n-1 \\}\) 中與\(n\)互質(coprime)的元素個數。 假設 \(m \in \mathbb{Z}, n \in \mathbb{Z}^+\)且 \(gcd(m, n) = 1\)，則：\(m^{\phi (n)} \equiv 1 \quad (\mod n)\) Chinese Remainder Theorem - 中國剩餘定理 用例子來推演整個過程： \(Ex.\) 求 \[ \left\{\begin{matrix} x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right. \] 首先拆開來解方便計算： \(\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_1 = 35 \cdot n_1\) \(\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_2 = 21 \cdot n_2\) \(\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_3 = 15 \cdot n_3\) 接著使用同餘的保持基本運算，令\(x = a_1 + a_2 + a_3\)：\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 3)\)\(x = a_1 + a_2 + a_3 \equiv 3 \quad (\mod 5)\)\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 7)\) 計算 \(a_1\)：\[\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_1 = 35\cdot n_1 \equiv 2 \quad(\mod 3)\)不好運算，轉成\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3)\)\(\Rightarrow 35 = 11 \cdot 3 + 2\)\(\Rightarrow 3 = 2 \cdot 1 + 1\)\(1 = 1 \cdot 3 - 1 \cdot 2\)\(\Leftrightarrow 1 = 1 \cdot 3 - 1 \cdot ( 1 \cdot 35 - 11 \cdot 3 )\)\(\Leftrightarrow 1 = (-1) \cdot 35 + 12 \cdot 3\)令\(m_1 = -1 + 3 \cdot k\) (模反元素)所以，\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3) \Leftrightarrow 2 \cdot b_1 \equiv 2 \cdot 35 \cdot m_1 \equiv 2 \cdot 1 \quad (\mod 3)\)則可以令\(a_1 = b_1\cdot 2\)，取\(k = 1, b_1 = 35 \cdot 2 = 70 \Rightarrow a_1 = 140\) 計算\(a_2\)：\[\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_2 = 21\cdot n_2 \equiv 3 \quad(\mod 5)\)不好運算，轉成\(b_2 = 21\cdot m_2 \equiv 1 \quad(\mod 5)\)\(\Rightarrow 21 = 4 \cdot 5 + 1\)\(1 = 21 \cdot 1 - 4 \cdot 5\)令\(m_2 = 1 + 5 \cdot k\) (模反元素)所以，\(b_2 = 21 \cdot m_2 \equiv 1 \quad (\mod 5) \Leftrightarrow 3 \cdot b_2 = 3\cdot 21 \cdot m_2 \equiv 3 \cdot 1 \quad (\mod 5)\)所以令\(a_2 = b_2 \cdot 3\)，取\(k = 0, b_2 = 21 \cdot 1 = 21 \Rightarrow a_2 = 63\) 計算\(a_3\)：\[\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\] ，\(a_3 = 15\cdot n_3 \equiv 2 \quad(\mod 7)\)不好運算，轉成\(b_3 = 15\cdot m_3 \equiv 1 \quad(\mod 7)\)\(\Rightarrow 15 = 2 \cdot 7 + 1\)\(1 = 15 \cdot 1 - 2 \cdot 7\)令\(m_3 = 1 + 7 \cdot k\) (模反元素)所以，\(b_3 = 15 \cdot m_3 \equiv 1 \quad (\mod 7) \Leftrightarrow 2 \cdot b_3 = 2\cdot 15 \cdot m_3 \equiv 2 \cdot 1 \quad (\mod 7)\)所以令\(a_3 = b_3 \cdot 2\)，取\(k = 0, b_3 = 15 \cdot 1 = 15 \Rightarrow a_3 = 30\) 最後計算 \(x = a_1 + a_2 + a_3 = 233\)，驗算\(\left\{\begin{matrix} 233 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ 233 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ 233 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\) ，OK。 常見題目類型 Type 1 (模數都互質) \(Ex.\)(99 政大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 5 &amp; ( \mod 7 &amp; )\\ x &amp; \equiv &amp; 4 &amp; ( \mod 9 &amp; )\\ x &amp; \equiv &amp; 3 &amp; ( \mod 13 &amp; )\end{matrix}\right.\) Type 2 (模數不全是互質) \(Ex.\)(97 台科大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 8 &amp; ( \mod 15 &amp; )\end{matrix}\right.\) Type 3 (模數重疊) \(Ex.\)(97 高師大) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 13 &amp; ( \mod 16 &amp; )\\ x &amp; \equiv &amp; 73 &amp; ( \mod 81 &amp; )\end{matrix}\right.\) Type 4 (矛盾 - 無解) \(Ex.\)(97 台科大 - 改) \(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 10 &amp; ( \mod 15 &amp; )\end{matrix}\right.\)]]></content>
      <categories>
        <category>Number Theory</category>
      </categories>
      <tags>
        <tag>Modular</tag>
        <tag>Mod</tag>
        <tag>Inverse</tag>
        <tag>Chinese Remainder Theorem</tag>
        <tag>模數</tag>
        <tag>模反元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra - 重點分析 - LU分解]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F07%2FLinear-Algebra-%E9%87%8D%E9%BB%9E%E5%88%86%E6%9E%90-LU%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Linear Algebra - 重點分析 LU分解 LU 分解的外表看似平淡無奇，但它可以用來解線性方程，逆矩陣和計算行列式，堪稱是最具實用價值的矩陣分解式之一。 令 \(A\) 為一個 \(n\cdot n\) 階矩陣。LU 分解是指將 \(A\) 表示為兩個 \(n \cdot n\) 階三角矩陣的乘積 \[ A = L\cdot U \] 其中 \(L\) 是下三角矩陣，\(U\) 是上三角矩陣，如下例， \[ \begin{bmatrix}3 &amp; 1 &amp; 2 \\ 6 &amp; -1 &amp; 5 \\ -9 &amp; 7 &amp; 3\end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 2 &amp; 1 &amp; 0 \\ -3 &amp; 4 &amp; 1 \end{bmatrix} \begin{bmatrix}3 &amp; -1 &amp; 2\\ 0 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 5 \end{bmatrix} \] 高斯消去法可以通過一連串的矩陣乘法來實現。每一個基本列運算等同於左乘一個基本矩陣，而對應列取代的基本矩陣 \(E_{ij}\) 的 \((i, j)\) 元即為 \(-l_{ij}\)。 消去程序可用下列矩陣乘法表示： \[ E{32}E{31}E_{21}A=U \] 因為基本矩陣 \(E_{ij}\) 都是可逆的 \[ A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U=LU \] 存在性 然而，並非任何可逆矩陣都具有 LU 分解形式，例如：\(A=\begin{bmatrix} 0&amp;2\\ 1&amp;3 \end{bmatrix}\)。假若 \(A\) 可以寫為 \[ A=LU=\begin{bmatrix} 1&amp;0\\ l_{21}&amp;1 \end{bmatrix}\begin{bmatrix} u_{11}&amp;u_{12}\\ 0&amp;u_{22} \end{bmatrix} \] 則必有 \(u_{11}=0\)， \(U\) 是不可逆的，這與 為 \(LU=A\) 可逆矩陣的事實相互矛盾。矩陣 之所 \(A\) 以不存在 分解的\(LU\) 原因在於 \(0\) 占據了 \((1,1)\) 元，但軸元必須不為零才能產生乘數。根據這項觀察，即知可逆矩陣 \(A\) 的 LU 分解存在條件是：列運算過程中，\(0\) 不得在軸元位置。萬一碰上零軸元的情況，還是有補救辦法，那就是使用列交換運算設法產生其他非零軸元，不過 LU 分解要修改成 \(PA=LU\)，\(P\) 是排列矩陣。例如， \[ \begin{aligned} PA&amp;=\begin{bmatrix} 0&amp;1\\ 1&amp;0 \end{bmatrix}\begin{bmatrix} 0&amp;2\\ 1&amp;3 \end{bmatrix}=\begin{bmatrix} 1&amp;3\\ 0&amp;2 \end{bmatrix}\\ &amp;=\begin{bmatrix} 1&amp;0\\ 0&amp;1 \end{bmatrix}\begin{bmatrix} 1&amp;3\\ 0&amp;2 \end{bmatrix}=LU.\end{aligned} \] 應用 最後討論 LU 分解的應用。LU 分解不僅僅只是記錄消去過程，它還有一個非常重要的實際用途：LU 分解具備快速求解線性方程 \(A\mathbf{x}=\mathbf{b}​\) 的良好結構。一旦得到了可逆矩陣 \(A​\) 的 LU 分解 \(A=LU​\)，我們大可把 \(A​\) 拋棄，將 \(A\mathbf{x}=\mathbf{b}​\) 改為 \(L(U\mathbf{x})=\mathbf{b}​\)，再令 \(\mathbf{y}=U\mathbf{x}​\)，原線性方程等價於兩組三角形系統： \[ \begin{aligned} L\mathbf{y}&amp;=\mathbf{b}\\ U\mathbf{x}&amp;=\mathbf{y}. \end{aligned} \] 接著使用兩次迭代即可得到解。上例中，先以正向迭代解出 \(\mathbf{y}\)， \[ \left[\!\!\begin{array}{rcc} 1&amp;0&amp;0\\ 2&amp;1&amp;0\\ -3&amp;4&amp;1 \end{array}\!\!\right]\begin{bmatrix} y_1\\ y_2\\ y_3 \end{bmatrix}=\left[\!\!\begin{array}{r} 10\\ 22\\ -7 \end{array}\!\!\right]\Rightarrow\begin{cases} y_1=10&amp;\\ y_2=-2y_1+22=2&amp;\\ y_3=3y_1-4y_2-7=15&amp; \end{cases} \] 再以反向迭代解出 ， \[ \left[\!\!\begin{array}{crc} 3&amp;-1&amp;2\\ 0&amp;1&amp;1\\ 0&amp;0&amp;5 \end{array}\!\!\right]\begin{bmatrix} x_1\\ x_2\\ x_3 \end{bmatrix}=\left[\!\!\begin{array}{r} 10\\ 2\\ 15 \end{array}\!\!\right]\Rightarrow\begin{cases} x_1=(x_2-2x_3+10)/3=1&amp;\\ x_2=-x_3+2=-1&amp;\\ x_3=15/5=3&amp; \end{cases} \] 對於 階矩陣 ，LU 分解耗費的乘法運算量大約是 \(\mathbf{O}(\frac{1}{3}n^3)\)，與高斯消去法相同。這個數字其實不算太糟，因為兩個 \(n\) 階方陣相乘就使用了 \(n^3\) 次運算。另外，正向迭代或反向迭代的運算量都只有\(\mathbf{O}(\frac{1}{2}n^2)\) ，遠比 LU 分解來的少。所以如果只要解出單一線性系統 ，直接用消去法化簡增廣矩陣 \(\begin{bmatrix} A\vert\mathbf{b} \end{bmatrix}\) 和 LU 分解的兩段式解法兩者之間並沒有多大差別，但如果稍後還要解多個係數矩陣相同但常數向量改變的系統 ，LU 分解便能夠派上用場。舉例來說，LU 分解可以用來計算逆矩陣 \(A^{-1}\)。將矩陣方程 看成三個線性方程： \[ A\mathbf{x}_1=\begin{bmatrix} 1\\ 0\\ 0 \end{bmatrix},~ A\mathbf{x}_2=\begin{bmatrix} 0\\ 1\\ 0 \end{bmatrix},~ A\mathbf{x}_3=\begin{bmatrix} 0\\ 0\\ 1 \end{bmatrix} \] 解出的未知向量 \(\mathbf{x}_i\)，\(i=1,2,3\)，就是逆矩陣 \(A^{-1}\) 行向量。LU 分解還可以用來計算 \(n\times n\) 階行列式。根據矩陣乘積的行列式可乘公式 \[ \det A=\det(LU)=(\det L)(\det U) \] 三角矩陣的行列式等於主對角元乘積，因此 \(\mathrm{det}L=1\)，推論 \[ \det A=\det U=\displaystyle\prod_{i=1}^nu_{ii} \] 方陣 \(A\) 的行列式即為消去法所得到的上三角矩陣 \(U\) 主對角元之積 (關於其他行列式計算方法的介紹，請見“Chiò 演算法──另類行列式計算法”)。 參考 LU 分解| 線代啟示錄]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>LU分解</tag>
        <tag>LU Decomposition</tag>
        <tag>重點</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Claim - 專利聲明]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Claim-%E5%B0%88%E5%88%A9%E8%81%B2%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Patent Claim - 聲明專利 專利的「異議」與「舉發」 異議 對於審定公告之專利原則上，任何人得自審定公告之次日起3個月內提起異議。 用於撤銷該專利之審定。 舉發 對於以取得之專利，得對之提起舉發。 用於撤銷「專利權」，使專利自使部存在。 ＜Note＞：有無仿冒？以專利角度看待，抄襲仿冒不是重點，重點是有無落入對方的專利申請範圍內。 專利範圍之記載要件 包含必要的技術特徵。 明確，使相關領域具通常知識者，可以明確瞭解其意義，不生疑義。 所載的發明符合產業利用性、新穎性與進步性。 為發明說明所支持。 結構 ( P + T + B ) 前言 ( Preamble ) 連接詞 ( Transition ) 主體 ( Body ) 獨立項與附屬項 ★★★★★ 獨立項：載明申請專利之標的及其實施之必要技術特徵。 ☆☆☆☆★ 附屬項：包含所依附項目之全部技術內容，並說明依附請求項以外之技術特徵。 ＜Note＞：獨立項遠重要於附屬項。 \(Ex.\) 一種杯子，其包含方形杯體及連接其上之把手。如請求項1之杯子，其中該杯體高度為10公分。如請求項2之杯子，其中該把手是透明的。 請求項 ( Claim ) 一般建議涵蓋不同範圍的請求項 最廣 中等 - 最小：最終銷售產品。 thedifferentsetofclaim 選擇一個「女友」？ 請根據以下條件以請求項( Claim )的方式要求。 覺得她長的漂亮 身高165公分以上，必須比我矮5公分，所以要在175公分以下 瘦瘦的 懂得化妝 最好長髮飄逸 即使是生氣時，也要很溫柔 要當太太不一樣，要會做家事，會煮飯，喜歡小孩 年輕的未婚女性 \(Ex.\) 獨立項( 範圍 ) 一名女性人類( P )，包含( T )下述之特性( B )： 覺得她長的漂亮\(\rightarrow\)五官特徵與松島菜菜子差異0%~20%之間。 身高165公分以上，必須比我矮5公分，所以要在175公分以下\(\rightarrow\)身高165公分至175公分之間。 瘦瘦的\(\rightarrow\)以身高推算後之標準體重再減10%~20%之間。 懂得化妝\(\rightarrow\)修過認證化妝課程20小時以上。 即使是生氣時，也要很溫柔\(\rightarrow\)喜歡不聽話的0歲到16歲人類。 要當太太不一樣，要會做家事，會煮飯，喜歡小孩\(\rightarrow\)喜歡也愛做被分配到的工作，但不要求薪水。 年輕的未婚女性\(\rightarrow\)年齡16歲到20歲的未婚人類。 附屬項( 範圍 ) 如專利範圍第1項所述之女性人類，更包括下述特性： 最好長髮飄逸\(\rightarrow\)長髮過肩30公分以上。 ＜Note＞：申請專利範圍用字要具體。越抽象的形容詞\(\rightarrow\)越難寫長得漂亮\(\rightarrow\)五官特徵與松島菜菜子差異0%20%之間\(&lt;br&gt;\rightarrow\)五官特徵與20歲松島菜菜子，經微軟發行的臉部辨識軟體，辨識之後差異0%20%之間 申請專利範圍所列的條件，『都』必須符合，才算是在專利範圍所主張的範圍之內。 來了1個大美女、但少了一隻耳朵、指甲長且銳利、手常過膝 解決： 加入 Claim 3 一名女性人類( P )，包含( T )下述之特性( B )： 除了剛剛所述另外加入 有兩隻健全耳朵、且可辨識聲波。 四肢健全、雙手自然下垂、長度介於腰繫之間。 每根手指指甲長度在1.2~2公分之間。 來了個日本女生，但是個六指琴魔 修正 Claim： 有兩隻健全耳朵、且可辨識聲波。 四肢健全、雙手自然下垂、長度介於腰繫之間。 每隻手有五根手指頭、每根手指指甲長度在1.2~2公分之間。 thedifferentsetofclaim2 外加一個Claim 4涵蓋Claim 1～3 一名女性人類，包含以下特性。 - 一名女性人類，目前未婚 thedifferentsetofclaim3 申請專利範圍之結構 前言 ( Preamable ) 連接詞 ( Trainsition ) 開放式：包含、包括、其特徵在於。(Comprise, contain, characterized by) 封閉式：由…組成。( Consisting of ) 半開放式：基本上由…組成。( Consisting essentially of ) 主體 ( Body ) 前言 描述所請發明之標的型態： 一種組合物… 一種裝置… 一種方法… 限制條件? 一種用於載裝飲料( 用途限定 )的杯子… 一種具有兩分裝空間( 結構限定 )的杯子… 一種杯子… 連接詞 開放式：包括、包含(comprise, contain) 表示所申請範圍包含主體中未記載之元件、成分、或步驟。 例如：一種組合物，包括成分A及B。 ＜Note＞：專利範圍涵蓋度最廣。 半開放式：基本上由…組成(consisting essentially of) 不排除實質上無影響力之成分。 例如：一種組合物，基本上由成分A及B組成。 ＜Note＞：專利範圍涵蓋度中度。 封閉式：由…組成(consisting of) 僅包含主體中記載之元件、成分、或步驟。 例如：一種組合物X，由成分A及B組成。 ＜Note＞：專利範圍涵蓋度最低。 主體 記載所請發明的主要特徵 標的請求項：物品或物質的結構特徵。 方法請求項：步驟。 \(Ex.\) claimpractice1 Claim A claimpractice2 Claim B claimpractice3 Claim C claimpractice4 Claim D claimpractice5 Claim E claimpractice6 upload successful ＜Note＞：限制條件越多，權力範圍越小。專利說明書的所有部分，都是為『申請專利範圍』而活。 theeffectofthesizeofclaim 範圍可以無限擴大嗎？ 專利範圍當然是越大越好。 『發明之必要條件』與『既有技術』，專利說明書的具體實例也會影響專利範圍的大小。 最後，範圍無限擴大的專利的問題在能否通過。]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Claim</tag>
        <tag>專利聲明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Specification - 專利說明書]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Specification-%E5%B0%88%E5%88%A9%E8%AA%AA%E6%98%8E%E6%9B%B8%2F</url>
    <content type="text"><![CDATA[Patent Specification - 專利說明書 不能只提出要解之問題，要寫出『如何辦到』。專利說明書要說明『如何辦到』。 想法：趁聖誕老公公發禮物時抓住他。 作法：需要具體機制。 狗應該要有專門的馬桶。 作法：如何設計一個狗狗專用的馬桶。 說明書的內容 patentspecificationcontent INID專利書目識別碼 Internationally agreed Numbers for the Identification of bibliographic Data 二位阿拉伯數字組成的數字，作為辨識專利公報之書目資料項目的重要指標 國際專利分類號 1971年由Strasburg國際專利協定所制定，並由世界智慧財產權組織(WIPO)每五年修訂一次並出版，其分類目的在便於專利資料的整理、查索及管理等運用。 目前最新版本為第八版，已於2006.01公佈並使用，並區分為核心版與進階版。 IPC從第一版的47,263個分類增加到第七版的67,634個分類，第八版的分類總數增加至約70,000個分類(進階版)，且分類架構已有大幅度的變動。 第七版以前約每五年更新一次，從第八版起，核心版將縮短為三年一次，進階版則隨時更新。 IPC分類之編排大致以 部(Section) 類(Class) 次類(Subclass) 主目(Group) 次目(Subgroup) 五大階層編排中，每一階層彼此之間具有從屬關係。 Section - 部 theclassficationofIPC_section Class - 類 upload successful Santa Calus Detector Patent 5523741 thesantacalusdetector1 thesantacalusdetector2 thesantacalusdetector3 upload successful 小結論 subsummary1 subsummary2 代號意義 [10] 文件識別 Identification of the patent, SPC, or patent document [11] 文件號碼 Number of the patent , SPC, or patent document [12] 文件種類 Plain language designation of the kind of document [13] 文件種類代碼 Kind-of-document code according to WIPO Standard ST. 16 [15] 專利修正資訊 Patent correction information [19] 文件發行單位 WIPO Standard ST. 3 Code, or other identification, of the office or organization publishing the document Santa Claus Detactor Patent 5523741 santacalusdetector5 [20] 專利申請登記項目 Data concerning the application for a patent or SPC [21] 申請號 Number(s) assigned to the application(s) [22] 申請日 Date(s) of filing the application(s) [23] 其他日期 Other Date(s), including date of filing complete specification following provisional specification and date of exhibition [24] 工業產權生效日 Date from which industrial property rights may have effect [25] 申請案最初提出時使用語文 Language in which the published application was originally filed [26] 最初申請案之語文 Language in which the application is published Santa Claus Detactor Patent 5523741 santacalusdetector6 [30] 國際優先權 Data relating to priority under the Paris Convention [31] 優先權申請號 Number(s) assigned to priority application(s) [32] 優先權申請日 Date(s) of filing of priority application(s) [33] 優先權申請國家 WIPO Standard ST. 3 code identifying the national industrial property office allotting the priority application number or the organization allotting the regional priority application number ; for the international applications filed under the PCT, the code “WO” is to be used [35] 優先權申請日期 For priority filings under regional or international arrangements, the WIPO Standard ST. 3 code identifying at least one country party to the Paris Convention for which the regional orinternational application was made [40] 公開日期 Date(s) of making available of the public [41] 未經審查尚未獲准專利的說明書提供公眾閱覽或複印的日期 [42] 經審查但尚未獲准專利的說明書提供公眾閱覽或複印的日期 [43] 未經審查之出版日期(公開日) Date of making available to the public by printing or similar process of an unexamined patent document, on which no grant has taken place on or before the said date [44] 經審查未獲權之出版日期 [45] 經審查已獲權之公告日(公告日) Date of making available to the public by printing or similar process of an examined patent document on which grant has taken place on or before the said date [46] 僅有申請專利範圍的出版日期 [47] 獲准專利說明書提供公眾用覽或複製的日期 Date of making available to the public by viewing, copying on request, a patent document on which grant has taken place on or before the said date Santa Claus Detactor Patent 5523741 upload successful [50] 技術資料 Technical Information [51] 國際專利分類 International Patent Classification or, in the case of a design patent, as referred to in subparagraph 4(c) of this Recommendation, International Classification for Industrial Designs [52] 本國專利分類 Domestic or national Classification [54] 發明名稱 Title of the invention [56] 先前技術文件明細 List of prior art document, if separate from descriptive text [57] 摘要或申請專利範圍 Abstract or claim [58] 檢索範圍 Field of search Santa Claus Detactor Patent 5523741 santacalusdetector8 [60] 與申請有關之法律文件 References to other legally or procedurally related domestic or previously domestic patent documents including unpublished applications therefore [61] 追加關係 Earlier document to which this is an addition [62] 分割關係 Earlier application form which the present document has been divided out [63] 延續關係 Continuations [64] 再發行關係 Document being reissued [65] 同申請案, 先前公開於其他國家之文件 Previously published document concerning same application [66] 取代關係 Document for which this is a substitute [70] 人事項目 Identification of parties concerned with the patent ot SPC. [71] 專利權人/申請人 Name(s) of applicant(s) [72] 發明人 Name(s) of inventor(s) if known to be such [73] 受讓人 Name(s) of grantee(s), holder(s),assignee(s), or owner(s) [74] 代理人 Name(s) of attorney(s) agent(s) [75] 發明人兼申請人 Name(s) of inventors who is (are) also applicant(s) [76] 發明人兼申請人及受讓人 Name(s) of inventors who is (are) also applicant(s) and grantee(s). Santa Claus Detactor Patent 5523741 santacalusdetector9 [80] 有關國際條約之資料識別 Identification of data related to International Conventions other than the Paris Convention, and to legislation with respect to SPCs. [81] PCT國際申請指定國 [82] PCT選擇國 Elected State(s) according to the PCT [83] 微生物寄存資料 Information concerning the deposit of microorganisms [84] 專利指定國 Designed Contracting States under regional patent conventions [85] 符合PCT第23條第1款或第40條第1款之規定而開始國內程序之日期 [86] PCT申請案相關資料 [87] PCT公開資料(公開號、公開語言、公開日) [88] 檢索報告延遲公佈日期 [89] 發明人證書，或基於CMEA協定對於發明之保護文件號碼及原始國 Santa Claus Detactor Patent 5523741 santacalusdetector10]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Specification</tag>
        <tag>專利說明書</tag>
        <tag>專利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Content of Patent 專利看討]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FContent-of-Patent-%E5%B0%88%E5%88%A9%E7%9C%8B%E8%A8%8E%2F</url>
    <content type="text"><![CDATA[專利看討 不是攻擊對手，而是保護自己(和公司)的權力。 專利制度 中華民國專利法 分為3章共156條 ＜專利法(1)＞：為鼓勵、保護、利用發明、新型及設計之創作，以促進產業發展，特制定本法。 ＜專利法(2)＞：本法所稱專利，分為 發明專利。 (新發明) 新型專利。 (新型) 設計專利。 (新式樣) formoftypeofpatent 什麼可以成為專利？ 若認為能賺錢的發明才是發明，會非常難達成。專利保護的概念，往往比大部分人想的都要廣，就算看起來不像是可受專利保護的概念，換個角度想也常能受專利保護。 thepatentofconcept 「改良」也算是發明 發明電燈泡的只有一個人？ 事實上，愛迪生的電燈泡出現之前70年，已經知道用白金當燈絲，但非真空。 只要有發明的概念 並有具體的作法。 不能成為專利的「概念」 動植物的新品種。 如基因改造過的玉米、新品種的老鼠。 人體或動物疾病之診斷、治療或治療方法。 心臟移植手術的方法。 ＜Note＞： 藥物、製藥方法、醫療器材等這些不包含在此。 科學原理或數學方法本身 \(E = M\cdot C^2\) ＜Note＞： 利用科學原理或是數學方法是可以成為專利的。\(Ex.\) MP3 壓縮技術、加解密技術。 純為人類智力的規則或方法。\(Ex.\)：如何節稅、如何開連鎖店。 屬著作權保護的美術、文學與音樂創作。 負面表列 一般是否屬於專利會保護的概念，只要看當地專立法所列的『負面表列』即可。 ＜專利法(24)＞：下列各款，不予發明專利： 動植物及生產動、植物之主要生物學方法。但微生物學之生產方法 ，不在此限。 人類或動物之診斷、治療或外科手術方法。 妨害公共秩序或善良風俗者。 專利在國際的考慮 各國價值觀不同，所核准的專利範圍也不盡然相同。慎選區域，因為所費不斐，最好以市場大小及競爭對手的區域為基準考量。]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Concept</tag>
        <tag>專利看討</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patent Applying 專利申請]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F05%2FPatent-Applying-%E5%B0%88%E5%88%A9%E7%94%B3%E8%AB%8B%2F</url>
    <content type="text"><![CDATA[申請專利 申請流程 申請→18個月後公開→3年內請求實體審查→實體審查→審定公告3個月→審查確定(無異議或異議不成立)→領證→( 舉發 )。 申請日 決定誰可以獲得勝利！ 申請日之取得 專利法(25)：申請發明專利，由專利申請權人備具申請書、說明書、申請專利範圍、摘要及必要之圖式，向專利 專責機關 申請之。 專利法(25)：申請發明專利，以申請書、說明書、申請專利範圍及必要之圖式齊備之日為『申請日』。 申請文件 需求 申請書 說明書 發明名稱 發明說明應明確且充分揭露發明之內容。 申請專利範圍各請求向以簡潔之方式記載。 圖示 ＜Note＞：若申請有『生物材料專利』，申請人應將該生物材料寄存於指定機構。 專利生效時間線 timelineofpatentapplying 專利權人 發明人 對於這個發明有貢獻的人。 專利申請人 提出專利申請的人，可以是公司、組織( 法人 )或是個人( 自然人 )。 ＜Note＞： 一定要填寫發明人，用來表彰發明人的貢獻，若發明人的填寫有捏造的事實，即便取得專利權也可能被撤銷專利。 誰是專利權人？ 真正擁有該專利權的人是「專利申請人」。 審查 專利提出申請 (繳費) 請求審查 (再繳費) 申請後必須要在 2~5年( 大部分是3年 )提出，否則專利視同撤回。＜用意＞： 考慮專利是否具備價值。’ ＜Note＞：美國的專利申請，一律自動審查，無請求審查制度，所有費用都包含在提出專利申請時的繳費。 始得權力日 專利權有效自申請日起算。 侵權日自專利審查完成後起算。 timelineofpatentapplying2 早期公開制度( Limited Early Publication System ) 『早期公開，請求審查』 為大部分國家所採用。 在申請日後，18個月會在『公開公報』上刊登申請專利的內容。＜目的＞：使同產業提早新技術內容，以及避免重複研發相同技術。 暫准專利權( Provisional right ) 如果在早期公開至專利核准期間，發生侵權行為，日後專利核准之後，專利權人可以要求暫准專利權其間的損失。 公眾審查制度( Public review system ) 有些國家規定，在核准專利過後的3～6個月，會公開讓民眾確認這項專利的合格性，待時間過後繳交「專利領證費」並領證，接著，每年還需繳交「專利維持費」。 歐盟 [x] 公眾審查制 ( 3～6個月 ) 美國 [ ] 公眾審查制 核准後直接領證。 撤銷專利 在領到證書之後，任何人都可以主張撤銷你的專利。 可能的原因 沒有符合「專利要件」。 不同意審查委員的看法。 提出當初審查委員沒有看討的先前技術( 習之技術 )。 先申請主義( Double Patenting ) 誰將獲得台灣專利？ doublepatenting ( 乙君 ) ＜先申請主義＞ 現在沒有所謂的＜先發明主義＞；依我國專利法(31)：相同發明有二以上之專利申請案時，僅得就其最先申請者准予發明專利。 ＜Note＞：先申請先贏。 屬地主義 只有在該國的專利核准過的專利，才能在該國享有專利權，其餘國家的專利權皆無法在該國產生任何作用。 國際、國內優先權 Right of Priority - 國際優先權 誰將獲得台灣專利？ rightofpriority ( 乙君 ) 甲君未聲明＜國際優先權＞！ 專利申請人就相同發明，在他國提出第一次申請案後，於特定期間內向我國提出之專利申請案得以主張「優先權』，換句話說，以國外第一次申請案之申請日為『優先權日』，並據以作為審查是否符合專利之基準日。 ＜專利法(28)＞：申請人就相同發明在與中華民國相互承認優先權之國家或世界貿易組織會員(WTO)第一次依法申請專利，並於第一次申請專利之日後十二個月內，向中華民國申請專利者，得主張優先權。 ＜專利法(29)＞：依前條規定主張優先權者，應於申請專利同時聲明下列事項： 第一次申請之申請日。 受理該申請之國家或世界貿易組織會員。 第一次申請之申請案號數。申請人應於最早之優先權日後十六個月內，檢送經前項國家或世界貿易組織會員證明受理之申請文件。 rightofpriority2 Right of Domestic Priority - 國內優先權 誰將獲得台灣專利？ rightofdomesticpriority ＜專利法(30)＞：申請人基於其在中華民國先申請之發明或新型專利案再提出專利之申請者 ，得就先申請案申請時說明書、申請專利範圍或圖式所載之發明或新型，主張優先權。 ＜Note＞：但有下列情事之一，不得主張之 自先申請案申請日後已逾十二個月者。 upload successful 曝光條款 ＜專利法(22)＞：可供產業上利用之發明，無下列情事之一，得依本法申請取得發明專利。 申請前已見於刊物者。 申請前已公開實施者。 申請前已為公眾所知悉者。 ＜Note＞：發明雖無前項各款所列情事，但為其所屬技術領域中具有通常知識者依申請前之先前技術所能輕易完成時，仍不得取得發明。 ＜專利法(22)＞：申請人有下列情事之一，並於其事實發生後六個月內申請，該事實 非 屬第一項各款或前項不得取得發明專利之情事。 因實驗而公開者。 因於刊物發表者。 因陳列於政府主辦或認可之展覽會者。 非出於其本意而洩漏者。 情境題 甲君獲得專利 situationquestion1 乙君無法獲得專利 upload successful 甲君獲得專利 upload successful 沒有人可獲得專利 ( 超過六個月的申請期 ) upload successful 審查 中華民國由智慧財產局依該申請是否具備專利要件決定。 符合專利要件→授予專利(核准) 不符合專利要件→應予駁回(核駁) 核駁 申請人對於『不給專利之審定』，不服者可以申請再審查。 ＜專利法(48)＞：發明專利申請人對於不予專利之審定有不服者，得於審定書送達後二個月內(60天內)備具理由書，申請再審查。但因申請程序不合法或申請人不適格而不受理或駁回者，得逕依法提起行政救濟。 行政救濟 對於『再審查』不服之一方：應提起訴願。( 向經濟部為之 ) 對於『訴願』不服之一方：應提起行政訴訟。( 向行政院為之 ) 起訴：高等行政法院 上訴：最高行政法院 專利權人 專利權人是誰？ situationquestion5 ＜專利法(7)＞： 受雇人於職務上所完成之發明、新型或設計 其專利申請權及專利權屬於雇用人，雇用人應支付受雇人適當之報酬。 但契約另有約定者( 合約 )，從其約定。 ＜Note＞：發明人具有『姓名表示權』。 ＜專利法(8)＞：受雇人於非職務上所完成之發明、新型或設計，其專利申請權及專利權屬於受雇人。 ＜專利法(7)＞：一方出資聘請他人從事研究開發者，其專利申請權及專利權之歸屬 依雙方契約約定 契約未約定者，屬於發明人、新型創作人或設計人。 ＜Note＞： 出資人得實施其發明、新型或設計之權力。 ＜Note＞： 美國專利的專利申請人一定是發明人，因此當職務上之發明，則在申請的同時，送交一份『讓與書』，以便權力由個人轉到公司。 Contract of Employment 聘用合約書 contractofemplement 補充 專利費用預估參考 - 以新台幣計(工研院資料) feeofpatent 輔大專利申請 patentapplyingofFJU patentofapplyingofFJU2 參考 中華民國專利公報檢所解析 早期公開を英語で・英訳 - 英和辞典・和英辞典 Weblio辞書 雙語詞彙]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>專利</tag>
        <tag>Apply</tag>
        <tag>申請</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Technical Patent Study - 科技專利專題]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F04%2FTechnical-Patent-Study-%E7%A7%91%E6%8A%80%E5%B0%88%E5%88%A9%E5%B0%88%E9%A1%8C%2F</url>
    <content type="text"><![CDATA[科技專利專題 Technical Patent Study - 概觀 首先，要了解專利就必須先思考到底是甚麼東西、有什麼用？ 瞭解專利對於企業發展及生存的重要性。 知道自己或團隊研發成果，哪些可以申請專利。 透過專利檢索快速學習他人技術。 避免侵害他人的專利。 撰寫優質的專利說明書(申請專利的技術文件)。 智慧財產權 Intellectual Property Right 智慧財產權，是一種無體財產權，係指人類精神活動之成果而能產生財產上之價值者，由法律所創設的一種權利，包括： 著作權 商標權 專利權 工業設計 積體電路布局 (IC) 鄰接權 植物種苗 商業秘密 不公平競爭 intalletualpropertyform 創作保護主義 創作保護主義，僅有創作之事實，即取得著作權。但為期權利明確及有完整之著作權記錄，得兼採登記主義，而登記機關改歸中央圖書館。但著作物登記並非著作權之取得要件，僅推定其權利為真實。至於著作權之移轉或處分之限制，以及以著作權為標的之質權的設定、移轉、變更或消滅或處分之限制，則非經登記，不得對抗第三人。 其保護僅及於該著作之表達(Expression)，而不及於其所表達之思想(Idea)、程序、製程、系統、操作方法、概念、原理、發現。 ＜小見解＞：上述的「表達(Experssion)」就是已經動手做出的有形實體(書畫)，或無形創作(音樂、文章、程式碼)。 著作權 著作權法之沿革 前清宣統 2年（ 1910 年）頒布之著作權律，係我國第一部之成文著作權法，其採註冊保護主義，著作物經註冊給照者，受著作權保護（著作權律第 4 條）。民國建立後，著作權律仍然沿用。北洋政府嗣於 1915 年頒布一部著作權法。國民政府亦於 1928年頒布著作權法，期間於 1944年、1949年、1964年、1985年、1990年、1992年、1993年、1998年、2001年、2003年及2004年均有修正。1985年修法前，作者必須申請註冊登記，始取得著作權，1985年修法後，改為著作人於著作完成時，享有著作權，係創作保護主義或稱自然發生主義。註冊或登記均僅具存證之性質，並非取得著作權之要件，倘當事人對於權利有爭執時，應由當事人自行提出證據證明之，並由司法機關依具體個案調查事實認定之，不應以著作權登記簿謄本之核發，作為認定著作權有無之唯一證據。而智慧財產局自1998年1月23日起，已不再受理著作權登記業務，倘原登記或註冊事項如有變更亦無從辦理更新。 著作權侵害 判斷是否受侵害時須考慮的因素有二： 被侵害的標的必須是表達而非思想。 被告須有接觸(Access)或實質相似(Substantial Similarity)的抄襲(Copying)行為。 ＜小見解＞：接觸(Access)就是該被告有可能接處到原創作者的任何途徑，所以有些創作者會在淨室(Clean Room)創作，防止任何的接觸可能性。 如何保護著作權 「舉證之所在、敗訴之所在」，如何舉證該著作是自己的原創是件很重要的事，用白話文來說，就是在創作時要無時無刻保留自己的手稿，來證明創作的靈感。法律是講求證據的，如果研發過程中未留下任何紀錄，則明明是贏的官司也可能會打輸。 有些科技公司會有研發紀錄簿，證明創作的理念。 建立淨室(Clean Room)，意旨個隔離所有可能的接觸。 小結論 『專利保護概念，著作權不保護概念』 舉例 \(Ex1.\) 微積分或力學原理，教師製作磨課師課程可以參考原文教科書，另行自編教材並解說，但在作業或測驗方面，就必須使用原文書的例題及習題內容了，這部分可以自由利用嗎？如果台灣書商無法授權，又該如何？ 原文教科書的例題及習題，仍是受著作權法保護，教師必須自行製作題目，否則就只能取得授權。 台灣書商無法給予課本內容之授權，通常是因為他只有賣書的權利，沒有內容授權的權利，必須與出版社連繫。若出版社無權授權，就要與著作人聯絡。真的找不到，就只能自己創作，才是安全的。 這就說明了，編一本書是很辛苦的，內容及例題和解答，都是智慧成果，所以書才會賣得很貴。磨課師課程的內容製作也很辛苦，若想少辛苦一點，就是付錢取得他人既有成果來使用，這無法單是以標明出處，就可取代授權的。 \(Ex2.\) patentexample1 patentexample2 patentexample3 patentexample4 patentexample5 patentexample6 審查主義 指創作完成後，須向 主管機關 提出申請、並經主管機關審查通過後，始能取得權利者。 中華民國的主管機關為『經濟部智慧財產局』 美國的主管機關為『專利商標局』 日本的主管機關為『特許廳』 大陸的主管機關為『知識產權局』 商標 商標（英語：Trademark）是識別某商品、服務或與其相關具體個人或企業的顯著標誌，可以是圖形或文字，也可以聲音、氣味或立體圖來表示。 標記 在採商標註冊標示國家，如美國，圖形「®」表示某個商標經過註冊，並受法律保護，稱作「主要註冊」（Principal Register）。圖形「™」常用來指某個標誌未經註冊通過而作為商標使用，僅具描述（merely descriptive）性質，可申請「輔助註冊」（supplemental register）避免日後其他類似商標註冊混淆，但標示使用上不限商標是否註冊通過。另外，尚有「℠」的服務商標。 目前兩岸三地商標法規中，中國大陸有明確規範「®」及圈內中文化的「注」，香港和台灣則無。 專利 專利流程 3 階段 upload successful 專利申請 繼續閱讀 參考 五南文化 - 著作法參考書 著作權之侵害與救濟：第六章 著作權侵害之救濟的基本問題 認識智慧財產權 - 國立政治大學 Wiki - 商標]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integration by parts - 分部積分法以及常用的分部積分]]></title>
    <url>%2Fwillywangkaa%2F2018%2F05%2F01%2FIntegration-by-parts-%E5%88%86%E9%83%A8%E7%A9%8D%E5%88%86%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E9%83%A8%E7%A9%8D%E5%88%86%2F</url>
    <content type="text"><![CDATA[分部積分法是種積分的技巧常應用於微積分數學與數值分析之中。它是由微分的乘法定則和微積分基本定理推導而來的。其基本思路是將不易求得結果的積分形式，轉化為等價的但易於求出結果的積分形式。 規則 當 \(u = u(x)\) 、 \(du = u&#39;(x)dx\) 、 \(v = v(x)\) 與 \(dv = v&#39;(x)dx\) ， 那分部積分就可以寫為： \[ \int_a^b u(x)v&#39;(x)dx=[u(x)v(x)]_a^b-\int_a^b u&#39;(x)v(x)dx \] \[ \Leftrightarrow u(b)v(b)-u(a)v(a)-\int_a^b u&#39;(x)v(x)dx \] 或是以更常見的簡寫： \[ \int u \; dv = uv - \int v \; du \] 定理 假設 \(u(x)\) 與 \(v(x)\) 是兩個連續可導函數 (continuously differentiable functions). 由乘法定理 (product rule) 可知(用來布尼茲表示法 Leibniz’s notation)： \(\frac{d}{dx} ( u(x) \cdot v(x) ) = \frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx}\) 對兩側求不定積分： \(uv = \int (\frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx})dx\)\(\Leftrightarrow \int d(u(x))\cdot v(x) + \int u(x)\cdot d(v(x))\)\(\Rightarrow \int u \; dv = uv - \int v \; du\) 常用的分部積分 \(\int \ln(x) dx = x\ln(x) - x + C\) \(\int \ln(x)dx\) 令 \(u = \ln(x)\) 、 \(dv = dx\) ， 則 \(du = \frac{1}{x} dx\) 、 \(v = x\) 帶入： \(\int \ln(x) dx = \ln(x) \cdot x - \int x\cdot \frac{1}{x}dx\) \(\Leftrightarrow \ln(x)\cdot x - \int(1)dx\) \(\Leftrightarrow \ln(x)\cdot x - x + C\) \(\int \log (x) dx = x\cdot \log (x) - \frac{x}{\ln 10} + C\) 令 \(u = \log (x)\) 、 \(dv = dx\) ， 則 \(du= d(\log (x)) \Leftrightarrow d(\frac{\ln x}{\ln 10})\) ＜乘法定理＞： 上微下不微 + 下微上不微 \(\Leftrightarrow d(ln x)\cdot \frac{1}{\ln 10} + \ln x\cdot d(\ln 10)\) \(\Leftrightarrow \frac{1}{x}\cdot \frac{1}{\ln 10} + \ln x \cdot 0\) \(\Leftrightarrow \frac{1}{x\ln 10}\) 接著 \(v = x\) 。 \(\int \log x dx = \log x \cdot x - \int x \cdot \frac{1}{x \ln 10} dx\) \(\Leftrightarrow x\cdot \log x - \int \frac{1}{\ln 10} dx\) \(\Leftrightarrow x\cdot \log x - x\cdot\frac{1}{\ln 10} + C\) 參考 Wiki - 分部積分法 Math2.org Math Tables: Integral ln(x) Derivative of Log X]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Integration</tag>
        <tag>Partial Integration</tag>
        <tag>Integration By Parts</tag>
        <tag>logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Neural Networks 類神經網路學習]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F25%2FArtificial-Neural-Networks-%E9%A1%9E%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E5%AD%B8%E7%BF%92%2F</url>
    <content type="text"><![CDATA[Artificial Neural Networks 類神經網路概論( 未完成 ) 簡介 類神經網絡是一種受生物學啟發而產生的一種模擬人腦的學習系統。 Youtube - 介紹神經元與類神經的關係 neuralgraph ↑ 神經元示意圖( *synapse：比重 ) 對於神經(neuron)我們有一個簡單的抽象：每個神經元是與其他神經元連結在一起的，一個神經元會受到多個其他神經元狀態的衝擊，並由此決定自身是否激發。 神經細胞透過輸入神經樹由其它神經細胞輸入脈波訊號後，經過神經細胞核的處理，其處理大約是： 將收集到的訊號作加總 非線性轉換 產生一個新的脈波信號 如果這個訊號夠強，則新的脈波信號會由神經軸傳送到輸出神經樹，再透過神經節將此訊號傳給其它神經細胞。值得注意的是：當訊號經過神經節後，由於神經節加權值的影響，其訊號大小值會改變。 神經網絡裡的結點相互連結決定了輸入的數據在裡面經過怎樣的計算。我們可以通過大量的輸入，讓神經網絡調整它自身的連接情況從而總是能夠得到我們預期的輸出。 neuralgraph2 ＜比較＞電腦裡的模擬神經網路的架構需具備： 模擬頭腦神經的連結( 包含模擬突觸、細胞本體( 隱藏層 )、軸突 ) 每個神經節點 實數的輸入與輸出 極大量的資訊 遷移學習( Transfer learning ) 基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning 實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning 什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？ 感知器 ( Perceptron ) 設有 \(n\) 維輸入的單個感知機( 從其他類神經元接收到的資訊 )，\(a_1\) 至 \(a_n\) 為 \(n\) 維輸入向量的各個分量，\(w_1\) 至 \(w_n\) 為各個輸入分量連接到感知機的權值( 比重 )，\(w_0\) 為偏置( 常數 )，一個神經元( Cell Body )分成兩個步驟，第一個 \(\sum\) 為彙總資料，後面那個 \(f(.)\) 為傳遞函數( 圖上的函數是“Sign function” )，判斷最後輸出的值， 最後以純量輸出( 1 or -1 )。 \[ Input: x_1, x_2, …,x_n \] \[ Output: 1 or -1 \] perceptrongraph 類神經元示意圖 ＜注意＞\(w_0\)不是伴隨其他的資訊傳進神經元的，而是因為某些演算法的需求，而另外多加的一個閾值( 正負常數值 )。 $ _{i = 0}^n W_i X_i$又稱為淨輸入( Net Input )，可處理線性組合的假說空間( Hypotheses )。 sgn_triggerfunction 上圖為此神經元判斷的觸發函數( 每個神經元的判斷都不盡相同，此為其中一種 )，帶入剛剛所算的淨輸入，計算輸出( -1就是判斷為無反應的狀況 )。 權值(\(w\))：如果當前神經元的某個輸入值權值為零，則當前神經元激發與否與這個輸入值無關；如果某個輸入值的權重為正，它對於當前神經元的激發值產生正影響。反之，如果權重為負，則它對激發值產生負影響。 偏移量(\(w_0\))：它定義了神經元的激發臨界值在空間上，它對決策邊界(decision boundary) 有平移作用，就像常數作用在一次或二次函數上的效果。感知器表示為輸入向量與權向量內積時，偏置被引申為權量，而對應的輸入值為 1。 決策邊界(decision boundary)：設輸入向量與權向量的內積為零，可得出 n+1 維的超平面。平面的法向量為 w，並經過 n+1 維輸入空間的原點。法向量指向的輸入空間，其輸出值為+1，而與法向量反向的輸入空間，其輸出值則為−1。故可知這個超平面定義了決策邊界，並把輸入空間劃分為二。 decisionboundery 激勵函數(activation function)：激勵函數代表神經元在什麼輸入情況下，才觸發動作。 activationfunction 感知器可以「學習」的函數 singlelayertwoinputperceptron Consider a 2-input perceptron ( 感知器 ) : It outputs 1 iff \[ o( x_1, x_2 ) = ( w_0+w_1 \cdot x_1+w2 \cdot x2 &gt; 0 )? \] equivalent to \[ o( x_1, x_2 ) = sgn( w_0+w_1 \cdot x_1+w2 \cdot x2 ) \] What weights represent \(AND (x1, x2)\)? \(w_0 = -0.8, w_1 = w_2 = 0.5\)\(o( x_1, x_2 ) \Rightarrow sgn(-0.8 + 0.5 \cdot x_1 + 0.5 \cdot x_2 )\) weighttorepresentAND What weights represent \(OR (x1, x2)\)? \(w_0 = 0.3, w_1 = w_2 = 0.5\)\(o( x_1, x_2 ) = sgn(0.3 + 0.5 \cdot x1 + 0.5 \cdot x2 )\) weighttorepresentOR What weights represent \(NOT (x1, x2)\)? \(w_0 =0.0, w_1 = -1.0, w_2 = 0\)\(o(x_1) = sgn( 0.0 –1.0x_1)\) weighttorepresentNOT What weights represent \(XOR (x1, x2)\)? Not possible. possibletorepresentXOR ＜NOTE＞Not linearly separable \(\rightarrow\) Can not be represented by a single percepton. Solution: use multilayer networks. multilayertorepresentXOR How to Determine a Weight Vector? 如何決定權重向量？ 在類神經網路學習的過程中，最重要的就是權重向量( Weight Vector )，因為這就是決定到時候感知器( Perceptrons )能不能做出正確預測( correct \(\pm 1\) output )的關鍵依據。 通常來說，都會給定一組訓練範例( Trainning example )，而且，每個元素裡必定會含有輸入( Input )與輸出( Output )。 \(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\) 是訓練範例中會給的資訊。 \(+1 \; or \; -1\) 為 \(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\) 的已知輸出( Target value )。 而我們的目標就是將 \(( w_1, w_2, w_3, \ldots , w_{n-1}, w_n )\) 訓練出來。 解決的演算法有很多，在這邊只討論其中兩個： The perception trainnin rule Gradient decent ( or call the delta rule ) Perceptron Training Rule \(t = c(x_1, x_2, x_3, ..., x_n )\) 是我們已知道的結果( 1 or -1 )。 \(o：\)對於訓練資料$ (x_1, x_2, x_3, …, x_n ) $以感知器( Perceptron )測試後出來的結果( 1 or -1 )。 ＜Note＞：Here o is the output of Perceptron, not the target value. 所以 $ ( t - o ) $ 為此時感知器( Perceptron )的誤差，然後藉由我們設定的 \(\eta\) 函式判斷要對目前的 \(w\) 修正多少值。 演算法 Initialize weights (w0, w1, w2, x3, …,wn ) to random values Loop through training examples： \(w_i \leftarrow w_i + \Delta w_i\) Where \(\Delta w_i = \eta (t-o) \cdot x_i\) and \(\eta\) is a learning rate (small positive value, e.g., 0.1) Given training data set \[ D = \{ ( \vec{x}, t ) \} \] 123456789//Initialize all weights w_i to random valuesw[] &lt;- random valuesWHILE not all examples correctly predicted DO FOR each training example x = (x_1, x_2, x_3, ..., x_n ) in D Compute current output o ( x_1, x_2, x_3, ..., x_n ) FOR i = 0 to n // always let x_0=1 w_i w_i + eta(t - o) * x_i ＜Note＞ If (t-o) = 0, no change in weight. 輪過一遍所有訓練資料，稱之為一個時代( Epoch )，若一個時代過後還有 \(w_i\) 是錯誤的就繼續修改 \(w_i\) ，直到某個時代所有的 $ w_i $ 可以讓 $ x_i $ 輸出正確。 ＜注意＞：如果訓練資料是線性可分離( XOR就不可線性分離 )，且\(\eta\)是小於1的很小的值，那麼一定最後可以在有限的世代找到最後的感知器( Perceptron )。 倘若今天的資料是無法被線性分離的改如何處理？ - Approach 1: 建立一個演算法可以努力找到逼近值。 E.g. gradient descent method ( 梯度下降法 ) - Approach 2: 建立不同架構或多層( Multilayer networks )結構的神經網路以突破限制。 Gradient Descent Youtube - Gradient Decent 介紹 我們需要在 \((n+1)\) 維的假說向量空間( Hypotheses Space )中搜索最合適( Best fit )的權值向量，我們需要有一定的規則指導我們的搜索，採用沿著梯度反方向往下走的方法，就稱為「梯度下降法」(Gradient Descent)。這種方法可以說是一種「貪婪演算法」(Greedy Algorithm)，因為它每次都朝著最陡的方向走去，企圖得到最大的下降幅度。即使訓練資料是不可線性分離的( Not lineary separable )，最後這個演算法還是會收斂在極趨近於目標想法的銓重向量停止。 ＜注意＞： Least square為最常用來檢測誤差的方法。 為了要計算梯度，我們不能採用不可微分的 sign() 步階函數，因為這樣就不能用微積分的方式計算出梯度了，而必須改用可以微分的連續函數 sigmoid()，這樣才能夠透過微分計算出梯度。 \[ E(w) = \frac{1}{2} \sum_{d \in D} ( t_d - o_d ) \] 上面公式中\(D\)代表了所有的輸入案例( 或者說是樣本 )，\(d\)代表了一個樣本實例，\(o_d\)表示感知器的輸出，\(t_d\)代表我們預想的輸出。 首先，我們先看看權重( Weight vector )向量 \(w\) 的梯度( Gradient )為何： \[ \bigtriangledown E( w ) = \frac{\partial E}{\partial w} = ( \frac{\partial E}{\partial w_0}, \frac{\partial E}{\partial w_1}, \ldots, \frac{\partial E}{\partial w_n} ) \] ＜注意＞： 梯度 是一個裡面所有元素為對 \(E\) 以對每個 \(w_i\) 偏微分的向量。且這個向量指向的地方為最上坡之處。( 如下圖紅色處顯示，而下方黑色箭頭則表示該梯度投影下來所對應的方向 ) gradient 所以 Gradient Descent 就是該點梯度的 反方向 ，也就是最下坡的方向，\(i.e. \; -\bigtriangledown E(w)\)。 這樣目標就明確了，欲在假說空間找到一組權值 \(w\) 讓這個誤差的值最小，顯然我們用誤差對權值求導將是一個很好的選擇，導數的意義是提供了一個方向，沿著這個方向改變權值，將會讓總的誤差變大，更形象的叫它為梯度。 既然梯度確定了E最陡峭的上升的方向，那麼梯度下降的訓練法則是： \[ \vec{w_i} \leftarrow \vec{w_i} + \Delta \vec{w_i}, \quad where \; \Delta \vec{w_i} = \eta \frac{\partial E}{\partial w_i} \] gradientgraph \(E.x.\) Example: two weights: \(w = (w_0, w_1)\) Error surface \(E\) is parabolic (by definition) Single global minimum Arrow: negated gradient at one point Steepest descent along the surface examplegradient For the least square error function, gradient is easy to calculate: \[ \bigtriangledown E( w ) = \frac{\partial E}{\partial w} = \frac{1}{2} \cdot \frac{\partial \sum_{d \in D} (t_d - o_d)^2}{\partial w_i} = \frac{1}{2} \sum_{d \in D}\frac{\partial (t_d - o_d)^2}{\partial w_i} \] \[ \Rightarrow \frac{1}{2} \cdot \sum_{d \in D} (2 \cdot (t_d - o_d)\frac{\partial( t_d - o_d )}{\partial w_i}) = \sum_{d\in D}((t_d - o_d)\frac{\partial(t_d - w\cdot x_d)}{\partial w_i}) \] \[ \Rightarrow \sum_{d\in D} ((t_d - o_d)(-x_{id})) \] 依上述，公式就可以簡化成： \[ \Delta w_i = -\eta \frac{\partial E}{\partial w_i} \] \[ and \] \[ \frac{\partial E}{\partial w_i} = \sum_{d \in D}((t_d - o_d)(-x_{id})) \] 最後公式變成： gradientdecentfinalformula 參考 Mr’ opengate - AI - Ch16 機器學習(4), 類神經網路 Neural network Wikipedia - 人工神經網路 基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning 實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning 什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Artificial Neural Networks</tag>
        <tag>Gradient Decent</tag>
        <tag>Perceptron trainning rule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervised learning 監督式學習 - Concept Learning 概念學習]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F20%2FSupervised-learning-%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92-br-Concept-Learning-%E6%A6%82%E5%BF%B5%E5%AD%B8%E7%BF%92%2F</url>
    <content type="text"><![CDATA[Supervised learning 監督式學習 - Concept Learning 概念學習 machinelearningconcept 機器學習簡介( 節錄自 Mr’ OpenGate ) 機器學習是近20多年興起的一門多領域交叉學科，涉及機率論、統計學、逼近論、凸分析、計算複雜性理論等多門學科。機器學習理論主要是設計和分析一些讓計算機可以自動「學習」的演算法。機器學習算法是一類從資料中自動分析獲得規律，並利用規律對未知資料進行預測的算法。 機器學習已廣泛應用於數據挖掘、計算機視覺、自然語言處理、生物特徵識別、搜尋引擎、醫學診斷、檢測信用卡欺詐、證券市場分析、DNA序列測序、語音和手寫識別、戰略遊戲和機器人等領域。 ＜定義＞ 機器學習定義如下 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. \(Ex.\) T(任務)：將郵件分類為垃圾或非垃圾。 E(經驗)：觀察目前信箱的信是把哪些種類的郵件標記為垃圾，而哪些是非垃圾。 P(效能)：被正確分類成垃圾或非垃圾的郵件的數量。 supervisedlearningworkflow 一種歸納的方式 從已知的現象訓練機器判斷常態的結果，而已知的現象只有是非之結論。(所以用這個方法訓練出來的智能只能判斷對錯) 所以以這種方法訓練的智能我們可以看待它是一個布林函數(Boolean-valued Funciotn)。 輸入 - 欲判斷的狀態 (Attributes)。 輸出 - 對(TURE)、錯(FALSE)。 learningfunction 環境狀態( Attribute )、學習目標( Target Concept ) Example from book：Enjoy sport conceptlearningenjoysportdata 六個會影響的環境狀態 ( Attribute ) 四個案例 ( Instance ) 學習目標：判斷當時是否很享受運動。\(EnjoySport = \{Yes, No\}\) 環境狀態( Attribute ) 每個事件(instance)發生時會引響結果的基本元素。 倘若現在有一事件會被影響的環境狀態為 \(N\) 個。 每個環境狀態可能出現的狀態個數為 \(n_i\) 。(第 \(i\) 個環境狀態) (Nominal values; symbolic values; Discretized values)(? 待了解) 案例( Instance ) - 已知結果的一群環境狀態 令 \(x\) 為已知結果的一群環境狀態。 那我們稱所有可能產生的案例為一個空間(Space)並稱它 \(X\)。 若 \(M\) 等於此空間 \(X\) 的大小，則 $ M = n_1 n_2 n_{N-1} n_N$。 我們其實可以將 \(M\) 視為此環境狀態所有組合的方法數。 學習目標( Target Concept ) 要學到的想法(在這裡我們給機器訓練的想法也可視為一個函式)。 \(c(x)=1 \qquad if \; EnjoySport=Yes\) \(c(x)=0 \qquad if \; EnjoySport=No\) \(c\) 是一個定義再案例空間(Instance Space)的布林函數。 \(c:X \rightarrow \left\{ 0, 1 \right\}\) 訓練集合 “\(D\)” 所有已知想法的案例集合 \(Ex.\) \[ &lt;x_1, c(x_1)&gt;, &lt;x_2, c(x_2)&gt; \ldots &lt;x_m, c(x_m)&gt; \] 假說( Hypotheses ) - 在這裡我們標記為 \(H\) 定義：所有環境狀態( Attributes )之限制( Constraints ) 的交集( Conjunction )。 限制( Constraints )的種類 Specific value ( 針對值 ) \(\qquad e.g. \; ( sky = sunny )\) Don’t care value ( 不在意值 ) \(\qquad e.g. \; ( sky = &quot;？&quot; )\) No value allow ( 無值 ) \(\qquad e.g. \; ( sky = &quot;\phi&quot; )\) 若今天有一案例( Instance )符合了我們的假說，也就是說它每個環境狀態( Attributes )全部都不逾越我們假說中的所有限制( Constraints )。 \(Ex.\) \[ h \leftarrow &lt; Sunny, Warm, ?, Strong, ?, ? &gt; \] 假說空間( Hypotheses Space )的大小 語意上來說( Syntactically distinct number ) \[ M_H = ( n_1 + 2 ) \cdot ( n_2 + 2 ) \cdot \ldots \cdot ( n_{N-1} + 2 ) \cdot ( n_{N} + 2 ) \] \[ ( Two \; more \; &quot;values&quot; \; have \; been \; added, &quot;?&quot; and &quot;\phi&quot; ) \] 實際上來說( Semantically distinct number ) \[ M_H = 1+ ( n_1 + 1 ) \cdot ( n_2 + 1 ) \cdot \ldots \cdot ( n_{N-1} + 1 ) \cdot ( n_{N} + 1 ) \] 因為如果該假說的限制交集裡，有一個以上的“”存在於集合中，代表所有的案例( Instances )絕對都不可能不逾越我們的假說，全部的案例都會判定為錯誤(False)。 小節論 \(c:EnjoySport : X \rightarrow \{ 0, 1 \}\) 是我們的學習目標( Target Concept )。 六個環境狀態( Attributes )： Sky ( 可能的變數有三種 ) \[\{ Sunny, Cloudy, Rainy \}\] Airtamp ( 可能的變數有兩種 ) \[\{ Warm, Cold \}\] Humidity ( 可能的變數有兩種 ) \[\{ Normal, High \}\] Wind ( 可能的變數有兩種 ) \[\{ Strong, Light \}\] Water ( 可能的變數有兩種 ) \[\{ Cold, Warm \}\] Forecast ( 可能的變數有兩種 ) \[\{ Same, Change\}\] 案例空間的大小 \(= 3 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 = 96\) 假說空間的大小 \(= 1 + ( 4 \cdot 3 \cdot 3 \cdot 3 \cdot 3 \cdot 3 ) = 973\) ( 實際上 ) 現在知道目前的假說空間大小後，就要開始找到符合我們期望( Target )的假說( Hypotheses )，那要從何先下手呢？首先，我們可以先從現有的訓練資料使用，其中，我們還可以了解一個概念－－－Inductive learning hypothesis，意思是說，我們今天使用訓練的資訊來找到一個最靠近的假說時，我們也可以找到一些潛在的的規則包含在我們找到的假說之中，其中會有我們從為訓練過的案例( Instance )在內。 ＜注意＞：在實務上來說，有可能訓練的難度會急遽上升，有可能我們的假說空間會超級大，甚至於無限大也有可能，所以要一個個要從所有的假說找到我們需要的是不太可能的，那怎麼辦呢？我們可以利用假說空間的一個特性－－－Partial Ordering，也就是說，這個空間裡的元素，是可以依照一個順序大小排列的。 假說空間的廣至收斂General-to-Specific Ordering over Hypotheses 首先定義幾個名詞，我們有： - 案例( Instance )：\(x\) - 假說( Hypothesis )：\(h\) - 若今天 \(h(x) = 1\) ，稱之 Positive ( True ) Outcome。 由廣至收斂，定義若 \(H_1 \geq_g H_2\)，則可以說 \(H_1\) 比 \(H_2\)還要更廣( General )，舉例： \[ \{ Sunny, ?, ?, ?, ?, ? \} \geq_g \{ Sunny, ?, ?, Strong, ?, ? \} \] GtoSprap Find S Algorithm 將假說 \(h\) 初始化為假說空間 \(H\) 中的最特殊假說 ${ , , , , , } $ 對每個正例 \(x\) ( ＜注意＞我們只使用正例( Positive Outcome )，不用反例！ ) 對 \(h\) 的每個環境狀態( Attribute )進行約束 如果 \(x\) 的該環境狀態滿足 \(h\) 對應的環境狀態，那麼不做任何處理。 否則將 \(h\) 中該環境狀態一般化( Generalize ) 以滿足 \(x\) 的環境狀態。 重複直到所有正例都被尋遍。 輸出最後唯一的假說 \(h\) ，而這個假說正是我們使用訓練資料中的正例所能訓練出最收斂的假說。 findsalgorithm Version Space Definition: Consistent Hypotheses( 認同假說 ) 若有假說 \(h\) 以訓練集合所有的案例進行測試，輸出結果和我們的想法一致，就可以聲明假說 \(h\) 為認同假說( Consistent Hypotheses )。( 下方為原始定義 ) A hypothesis \(h\) is consistent with a set of training examples \(D\) of target concept \(c\) if and only if \(h(x) = c(x)\) for each training example \(&lt;x, c(x)&gt;\) in \(D\). \[ Consistent (h, D) \equiv ( \; \forall &lt;x, c(x ) \in D \;) h(x) = c(x)) \] Definition: Version Space ( 候選空間 ) 候選空間就是對於該測試的資料集，所有的認同假說所組合的空間，因為每個假說都可以符合目前的訓練資料的期望，所以每個假說都等待我們再進一步驗證。( 下方為原始定義 ) The version space \(VS_{H,D}\) , with respect to hypothesis space \(H\) and training examples \(D\), is the subset of hypotheses from \(H\) consistent with all training examples in \(D\). \[ VS_{H,D} \equiv \{ h \in H \; | \; Consistent (h, D) \} \] versionspacegraph Version space for a “rectangle” hypothesis language in two dimensions. Green pluses are positive examples, and red circles are negative examples. GB is the maximally general positive hypothesis boundary, and SB is the maximally specific positive hypothesis boundary. The intermediate (thin) rectangles represent the hypotheses in the version space. Definition: General Boundary General boundary \(G\) of version space \(VS_{H,D}\) : set of most general members Definition: Specific Boundary Specific boundary \(S\) of version space \(VS_{H,D}\) : set of most specific members Version Space Every member of the version space lies between \(S\) and \(G\) \[ VS_{H,D} \equiv \{ h \in H \; | \; (\exists s \in S ) (\exists g \in G ) (g \geq_g h \; \geq_g s) \} \] \[ where \geq_g \equiv more \; general \; than \; or \; equal \; to \] The List-Then-Elimination Algorithm列表消除演算法 起始化： 候選空間( Version Space ) \(\leftarrow(assign)\) 所有在假說空間的假說。 對每個訓練案例\(&lt;x, c(x)&gt;\) 從候選空間消除所有 \(h(x) \neq c(x)\) 的假說 \(h\)。 對所有的訓練案例檢驗過，最後輸出候選空見剩下的假說列表。 優點 保證最後的假說列表裡的所有假說必定和訓練案例的期望相符( Consistent )。 缺點 若今天假說空間是無窮大，那這個方法就不能使用。 要將該假說空間的所有假說窮舉於列表之中。 Candidate-Elimination Algorithm候選消除演算法 ＜前情提要＞：候選空間( Version Space )可以由 Most specific boundaries 與 Most general boundaries 界定出來。 - 正例可以將 Specific boundary 變的更一般化( General )。 Positive examples force specific boundary to become more general. - 反例可以將 General boundary 變的更收斂( Specific )。 Negative examples force general boundary to become more specific. 最後，這個界定出來的假說集合可以符合所有的訓練資料。 In the end, all hypotheses which satisfy training data remain. 起始化 G \(\leftarrow\) 一組在假說空間 \(H\) 最一般化的環境因素。標記為：\(&lt;?, \ldots, ?&gt;\) S \(\leftarrow\) 一組在假說空間 \(H\) 最嚴苛的環境因素。標記為：\(&lt;\phi, \ldots, \phi&gt;\) 對於每個訓練案例 \(d\)，進行以下操作： 若 \(d\) 為一正例： 從 \(G\) 中移除所有與 \(d\) 不一致的假說。 對 \(S\) 中每個對 \(s\) 不一致的假說\(s\)： 將 \(s\) 從 \(S\) 之中移去。 把 \(s\) 的所有的極小泛化假說 \(h\) 加入到S中，其中 \(h\) 滿足 \(h\)與\(d\)一致，且\(G\)的其中一個元素必比起 \(h\) 更泛化。 從\(S\)中移去所有符合這樣的假說：它比S中另一假設更泛化。 若 \(d\) 為一反例： 從 \(S\) 中移去所有 \(d\) 不一致的假說。 對 \(G\) 中每個與 \(d\) 不一致的假設 \(g\)： 從 \(G\) 中移去 \(g\) 。 把 \(g\) 的所有的極小特化式 \(h\) 加入到 \(G\) 中，其中 \(h\) 滿足 \(h\) 與 \(d\) 一致，而且 \(S\) 的某個成員比 \(h\) 更收斂。 從 \(G\) 中移去所有符合這樣的假說：它比 \(G\) 中另一假說更特殊。 範例 - \(EnjoySport\) 起始化 Specific boundary to: \(S_0 = \{(Ø,Ø,Ø,Ø,Ø,Ø)\}\) General boundary to: \(G_0 = \{(?,?,?,?,?,?)\}\) 1’st instance: (Sunny,Warm,Normal,Strong,Warm,Same) = Yes Positive example generalizes Specific boundary \(S_1 = \{ (Sunny,Warm,Normal,Strong,Warm,Same)\}\) \(G_1 = \{ (?,?,?,?,?,?)\}\) 2’nd instance: (Sunny,Warm,High,Strong,Warm,Same) = Yes Positive example generalizes Specific boundary \(S_2 = \{(Sunny,Warm,?,Strong,Warm,Same)\}\) \(G_2 = \{ (?,?,?,?,?,?)\}\) 3’rd instance: (Rainy,Cold,High,Strong,Warm,Change) = No Negative example specializes General boundary \(S_3 = \{ (Sunny,Warm,?,Strong,Warm,Same) \}\) \(G_3 = \{(Sunny,?,?,?,?,?), \quad O.K.\) \((Cloudy,?,?,?,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,Warm,?,?,?,?), \quad O.K.\) \((?,?,Normal,?,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,Light,?,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,?,Cool,?), \quad Not \; more \; general \; than \; S_3\) \((?,?,?,?,?,Same)\} \quad O.K.\) \(\Rightarrow G_3 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?), (?,?,?,?,?,Same)\}\) 4’th instance: (Sunny,Warm,High,Strong,Cool,Change) = Yes Positive example generalizes Specific boundary \(S_4 = \{ (Sunny,Warm,?,Strong,?,?) \}\) \(G_4 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?) \}\) Final version space is all hypotheses, h such that: \[ g \geq_ g h \; \geq_g s \] candidate-eliminationalgorithm candidate-eliminationalgorithm2 What query should the learner make next? How should these be classified? \[ &lt;Sunny, Warm, Normal, Strong, Cool, Change&gt; \] \[ &lt;Rainy, Cold, Normal, Light, Warm, Same&gt; \] \[ &lt;Sunny, Warm, Normal, Light, Warm, Same&gt; \] Inductive Bias 歸納偏置 ( 未完待補 ) 需要某些的預先設定( 偏見 )。 參考 Mr’ OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning 《机器学习》第2章中find-s算法的python实现 WEKIPEDIA - Version space learning robert_ai - ML一（概念学习和一般到特殊序）]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Concept Learning</tag>
        <tag>Supervised Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[機器學習地圖]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F20%2F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%9C%B0%E5%9C%96%2F</url>
    <content type="text"><![CDATA[機器學習地圖 類別 監督學習 (Supervised learning)：從給定的訓練數據集中學習出一個模式（函數 / learning model），當新的數據到來時，可以根據這個模式預測結果。監督學習的訓練集要求是包括輸入和輸出，也可以說是特徵和目標。訓練集中的目標是由「人」標註的。常見的監督學習算法包括回歸分析和統計分類( Classify )。 無監督學習 (unsupervised learning)：與監督學習相比，訓練集沒有人為標註的結果。常見的無監督學習算法有聚類( Cluster )。 半監督學習 (Semi-supervised learning)：介於監督學習與無監督學習之間。 增強學習 (reinforcement learning)：通過觀察來學習做成如何的動作。每個動作都會對環境有所影響，學習對象根據觀察到的周圍環境的反饋( 獎勵 )來做出判斷。 機器學習演算法種類 構造條件機率：回歸分析和統計分類 人工神經網絡 決策樹 高斯過程回歸 線性判別分析 最近鄰居法 感知器 徑向基函數核 支持向量機 通過再生模型構造機率密度函數： 最大期望算法 graphical model：包括貝葉斯網和Markov隨機場 Generative Topographic Mapping 近似推斷技術： 馬爾可夫鏈 蒙特卡羅方法 變分法 最優化：大多數以上方法，直接或者間接使用最優化算法。 machinelearningmap kindofmachinelearning 參考 Mr’ OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decision Tree Learning]]></title>
    <url>%2Fwillywangkaa%2F2018%2F04%2F18%2FDecision-Tree-Learning%2F</url>
    <content type="text"><![CDATA[Decision Tree Learning 決策樹學習 簡介 最受歡迎的歸納推理演算法( inductive inference algorithm )。 廣泛且實務的方法。 對於干擾值( Noise )相當敏感。 可用來學習如何以聯集( Disjunctive )表示限制集( Constraints )。 ( Concept Learning 以交集( Conjunctive )表示 ) 呈現的方式相當簡單。 樹狀結構( Tree Structure )、若則表示式( If-Then rules ) \(Ex.\) Play Tennis 範例訓練資料( Training Example ) decisiontreelearning_training example 決策樹( Decision Tree ) decisiontreelearning_exampletree 決策樹( Decision Tree )的介紹 決策樹表示法( Decision Tree Representation ) 每個內節點 Internal node ( 包括根結點 Root node )代表對一個環境狀態( Attribute )檢驗。 而分支( Branch )出來的意義我們可以視為是該環境狀態( Attribute )的一種可能值( Attribute value )。 每個葉節點 Leaf node 給予一個適當的分類結果( Classification )。 我們將每個案例( Instances )分類到一個離散的類別( Categories )之中。 藉由決策樹由根結點至葉節點找到該類別。 決策樹引導的假說( Hypotheses ) 先 AND 再 OR ( 原文：Disjunctions (OR’s) of conjunctions (AND’s) )。 經由根結點往葉節點走可視為是一種對於該環境狀態限制的交集( Conjunction of constraints on attributes )。 而連上兄弟節點( Sibling )的兩個邊( Edges )可視為是一種對於該環境狀態限制的聯集( Separate branches are disjunctions )。 \(Ex \; ( Cont. )\) (Outlook=Sunny and Humidity=Normal) or (Outlook=Overcast) or (Outlook=Rain and Wind=Weak) 注意！ 每個用來訓練的案例 ( Instances )都必須要以「因素-結果」( Attribute - value pairs )的方式給予訓練。 目標訓練函式 ( Target function )的值域是離散的值 ( Discrete value )。 這種方法最後呈現的假說 ( Hypotheses )有可能是一些環境狀態限制( Constraints on attributes )的聯集( Disjunctive )。 極有可能會被不乾淨的資料( Noise )擾亂了學習。 應用於： 醫療或是設備的診斷。 信用額度分析( 銀行 )。 決策樹的種類 世界上有許多有特殊的決策樹演算法( decision-tree algorithms )，比較著名的有： - ID3 (Iterative Dichotomiser 3) - C4.5, C5.0 (successor of ID3) - CART (Classification And Regression Tree) - CHAID (CHi-squared Automatic Interaction Detector). - MARS: extends decision trees to handle numerical data better. 注意 ID3 is the algorithm discussed in textbook.( 在書本中有更詳細的介紹 ) Simple, but representative. ( 簡單但representative? ) Source code publicly available. ( 程式碼是開放的 ) ID3演算法 概述：Top-down, greedy search through space of possible decision trees. ( 在所有可以出現的決策樹中用貪心法由上而下找到較佳的那棵樹。 ) ID3在建構決策樹過程中，以資訊獲利(Information Gain)為準則，並選擇最大的資訊獲利值作為分類屬性。這個算法是建立在奧卡姆剃刀的基礎上：越是小型的決策樹越優於大的決策樹。儘管如此，該算法也不是總是生成最小的樹形結構，而是一個啟發式算法。另外，C4.5算法是ID3的升級版。 Decision trees represent hypotheses, so this is a search through hypothesis space. ( 決策樹亦也代表是一種假說，所以這個演算法也可以說是在所有的假說中找到一個較佳的假說。 ) 那個演算法該如何起手呢？ 決定甚麼環境因素( Attribute )應該放在根結點( Root node )？ 接著由上而下( Top-down )的建構決策樹，對每個後繼的節點( Successive node )使出一樣的決策手段選出該節點應該置入何種環境因素( Attribute )。 注意！千萬不要由下往上參考之前選過的值，因為我們以貪心法則，所以目前的最佳解決不可能出現在之前選過的環境因素( Attribute )之中，或是受其干擾。 ( Never backtracks to reconsider earlier choices. ) 同上述，在每次的選擇之中，由於我們認知這種情況適用貪心法( Greedy Method )，所以我們每次環境因素( Attribute )的選擇都朝向我們最後最佳的假說靠近。 虛擬碼( Pseudo Code ) 12341. 使用屬性計算與之相關的樣本熵值2. 選取其中熵值最小的屬性(資訊獲利最大)3. 生成包含該屬性的節點4. 遞迴直到終止 decisiontreelearning_builddecisiontree_algorithm decisiontreelearning_howtochoosenode ＜討論＞ ID3演算法的終極目標，就是要將決策樹中每個節點都擺上最優的環境因素( Attributes )。 \(Question.\) 到底以甚麼條件決定甚麼因素要擺放於哪個節點？ \(Answer.\) 資訊獎賞 or 資訊獲利( Information gain )。 - 資訊獲利( Information gain ) 統計該價值以檢視該環境因素置於何處來分類我們的資料，我們使用熵( entropy 又稱“亂度” )來定義這邊的資訊獲利( Information gain )。( 原文：Statistical quantity measuring how well an attribute classifies the data. Use entropy to define information gain. ) ID3 和 C4.5 - Information gain ( 資訊獲利 ) 與 Gain ratio 定義 關心其中一個環境因素( Attribute )\(A\) 的資訊獲利( Information gain )我們標記為 \(Gain( S, A )\)，且我們關心的目標樣本群體為 \(S\)，其中： \[Gain( S, A ) = Entropy( S ) - \sum_{ v \in Values(A) } ( \frac{S_v}{S}Entropy(S_v) )\] - \(v\) ranges over values of \(A\) - \(S_v\): members of \(S\) with \(A = v\) - \(1^{st}\) term: the entropy of \(S\) - \(2^{nd}\) term: expected value of entropy after partitioning with \(A\) Example： PlayTennies 四個環境變因 Outlook = {Sunny, Overcast, Rain} Temperature = {Hot, Mild, Cool} Humidity = {High, Normal} Wind = {Weak, Strong} 欲看討的結果 - 開心或是不開心( Target Attributes - Binary ) PlayTennis = {Yes, No} 今天有14組訓練資料 9筆的結果是開心的 ( Positive ) 5筆的結果是不開心的( Negative ) 訓練資料表 decisiontreelearning_trainningdataform Step 1. 計算整體的亂度( Entropy ) \(N_\oplus = 9, N_\ominus = 5, N_{Total} = 14\) \(Entropy( S ) = -\frac{9}{14} \cdot \lg (\frac{9}{14}) - \frac{5}{14} \cdot \lg ( \frac{5}{14} ) = 0.940\) Step2. 不斷計算資訊獲利( 找亂度比較低attribute的 )，選擇最大值當作根結點 Outlook Outlook = Sunny \[N_\oplus = 2, N_\ominus = 3, N_{Sunny} = 5\] \[Entropy(S_{Sunny}) = -(\frac{2}{5})\cdot \log_2(\frac{2}{5}) - (\frac{3}{5}) \cdot \log_2(\frac{3}{5}) = 0.971\] Outlook = Overcast \[N_\oplus = 4, N_\ominus = 0, N_{Overcast} = 4\] \[Entropy(S_{Overcast}) = -(\frac{4}{4})\cdot \log_2(\frac{4}{4}) - (\frac{0}{4}) \cdot \log_2(\frac{0}{4}) = 0.0\] Outlook = Rain \[N_\oplus = 3, N_\ominus = 2, N_{Rain} = 5\] \[Entropy(S_{Rain}) = -(\frac{3}{5})\cdot \log_2(\frac{3}{5}) - (\frac{2}{5}) \cdot \log_2(\frac{2}{5}) = 0.971\] 計算環境因素的 Outlook 之資訊獲利 \[Gain(S, Outlook) = Entropy(S) - (N_{Sunny} / N_{total}) * Entropy(S_{Sunny})\] \[ - (N_{Overcast} / N_{total}) * Entropy(S_{Overcast})\] \[ - (N_{Rain} / N_{total} ) * Entropy(S_{Rain})\] \[\Rightarrow 0.940 - (5/14) \cdot 0.971 - (4/14) \cdot 0.00 - (5/14) \cdot 0.971 = 0.246\] Temperature Repeat process over { Hot, Mild, Cool } \[ Gain( S, Temperature ) = 0.029 \] Humidity Repeat process over { High, Normal } \[ Gain( S, Humidity ) = 0.151 \] Wind Repeat process over { Weak, Strong } \[ Gain( S, Wind ) = 0.048 \] 再來，我們要找到最佳的資訊獲利( Information gain )，其中： \[Gain(S, Outlook) = 0.246\] \[ Gain( S, Temperature ) = 0.029 \] \[ Gain( S, Humidity ) = 0.151 \] \[ Gain( S, Wind ) = 0.048 \] 從亂度的點看來，似乎Outlook的亂度最低( 與宇亂度相減後剩餘比較多資訊獲利 )，所以我們選擇Outlook作為我們根結點( root node )，如下圖： decisiontreelearning_choosenode 選擇了Outlook做為決策樹的根結點後，緊接著，我們可以將三種不同的Outlook作為分支，其中特別的是，Overcast狀態之中( 上圖中間綠色部分 )，全部皆為開心狀態( Positive outcome )，所以可以直接決定Overcast輸出為開心( Positive )。 Step 2. Conti. - 選擇下一個節點( 子樹的根結點 ) ( 從何子節點開始建子樹？ I don’t know yet. ) Same steps as earlier but only examples sorted to the node are used in Gain computations.( 無法理解 ) 選一個點( 隨機？ )繼續建子樹 Outlook = Sunny \[Gain(S_{Sunny}, Humidity) = 0.97 - (3/5) \cdot 0 - (2/5) \cdot 0 = 0.97 bits\] \[Gain(S_{Sunny}, Temperature) = 0.97 - (2/5) \cdot 0 - (2/5) \cdot 1 - (1/5) \cdot 0 = 0.57 bits\] \[Gain(S_{Sunny}, Wind) = 0.97 - (2/5) \cdot 1 - (3/5) \cdot 0.918 = 0.019 bits\] 由上式可以看出來Humidity的亂度最小，所以選擇之為此子樹的根。 Final Decision Tree decisiontreelearning_finaldecisiontree 熵、亂度 (Entropy) 介紹 在資訊理論中，熵被用來衡量一個隨機變數出現的期望值(機率與統計)。它代表了在被接收之前，訊號傳輸過程中損失的資訊量，又被稱為資訊熵。熵是對不確定性的測量。在資訊界，熵越高則能傳輸越多的資訊( 資訊越多意味著有更多的可能性 )，熵越低則意味著傳輸的資訊越少( 資訊越少意味著有更少的可能性 )。 如果有一枚理想的硬幣，其出現正面和反面的機會相等，則拋硬幣事件的熵等於其能夠達到的最大值。我們無法知道下一個硬幣拋擲的結果是什麼，因此每一次拋硬幣都是不可預測的。( 越是不可預測的結果 \(\rightarrow\) 亂度越大，而這種結果，正是造成人類選擇障礙的原因，所以我們希望熵越低越好，我們可以立即做出判斷 ) \(Ex1.\) 使用一枚正常硬幣進行拋擲，這個事件的熵是一位元，若進行n次獨立實驗，則熵為\(n\)，因為可以用長度為 \(n\) 的位元流表示。但是如果一枚硬幣的兩面完全相同，那個這個系列拋硬幣事件的熵等於零，因為結果能被準確預測。 \(Ex2.\) \(Let \; y \; be \; a \; Boolean \; function, and \; let \; P \; denote \; Probability.\) What is the most pure (亂度低) probability distribution? \[P(y = 0) = 1, P(y = 1) = 0\] \[P(y = 0) = 0, P(y = 1) = 1\] What is the most impure (亂度高) probability distribution? \[P(y = 0) = 0.5, P(y = 1) = 0.5\] 意同於最大的亂度。 定義 首先，我們可以先從簡單的看討當目前的結果最多只有兩種情況，如拋硬幣，最多只有正面或是反面，下圖\(x\)軸\(P_\oplus\)代表擲出正面的機率函數，而\(y\)軸則是對應的熵值，而\(P_\ominus\)的機率軸則是會隨著\(P_\oplus\)下降而上升( 兩者互補 )，但是對應到的熵值會一樣大。 decisiontreelearning_entropygraph \(S\) is a sample of training examples( 隨機變量 ). 當今天的結果只有正與反 ( 與硬幣一樣 )時，觀察目前的隨機變量 - 我們令： - \(P_\oplus\) ( 就目前隨機變數產生的機率 ) is the portion of the positive examples ( 正面 ) in \(S\). - \(P_\ominus\) ( 就目前隨機變數產生的機率 ) is the portion of the negative examples ( 反面 ) in \(S\). Entropy ( 熵 ) measures the impurity ( 亂度 ) of \(S\). 我們先定義熵值 ( Entropy ) 如下： \[ Entropy( S ) = E( I( S ) ) = E(- \ln ( P ( S ) ) ) \] 其中，\(E\)為期望函數，\(I( S )\)是 \(S\) 的資訊量（又稱為資訊本體），\(I( S )\)也是一個隨機變數。 所以在取硬幣的樣本( \(S\) )完後，我們可以將熵值寫成： \[ Entropy( S ) = \sum_{i = 1}^{2} P(S_i)I(S_i)\] \[ \Rightarrow -\sum_{i = 1}^{2} P(S_i)\log_{2} P(S_i) \] \[ \Rightarrow -P_{\oplus}\log_2 P_{\oplus} - P_{\ominus}\log_2 P_{\ominus}\] ＜Note＞ \[\sum_{i = 1}^N P_i = 1 \; and \; 0 \leq P_i \leq 1 \] 推廣至一般式 decisiontreelearning_generalentropygraph 當取自有限的樣本時，熵的公式可以表示為： \[H(X) = \sum _{i} P(x_i) \, I(x_i)=-\sum_i P(x_i)\log _b P(x_i)\] 在這裏 \(b\) 通常是\(2\),自然常數 \(e\)，或是\(10\)。當\(b = 2\)，熵的單位是\(bit\)；當\(b = e\)，熵的單位是\(nat\)；而當\(b = 10\),熵的單位是\(Hart\)。 ＜Note＞ 定義當\(P_i = 0\)時，對於一些 \(i\) 值，對應的被加數 \(0 \log_b 0\) 的值將會是 \(0\)，這與極限一致。 \[ \Rightarrow \lim_{p\to0+} ( p\log p ) = 0 \] CART (Classification and Regression Tree) 見 Mr’ opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree 決策樹學習的常見問題 避免過度適配資料( Prevent Overfitting ) 首先，相較於很冗長的樹，在機器學習中其實比較偏向於比較矮的樹，然而，為何？我們可以由Occam’s Razor ( 奧坎剃刀 )得知，若有兩個假說同時都能解釋該現象，我們偏向於比較沒那麼嚴個的假說( 可以表達比較廣的概念 )。過度配適是指模型對於範例的過度訓練，導致模型記住的不是訓練資料的一般特性，反而是訓練資料的局部特性。對測試樣本的分類將會變得很不精確。 ＜注意＞通常過度適配發生在訓練範例含有雜訊和離異值時，但當訓練數據沒有雜訊時，過度適配也有可能發生，特別是當訓練範例的數量太少，使得某一些屬性「恰巧」可以很好地分割目前的訓練範例，但卻與實際的狀況並無太多關係。 decisiontreelearning_overfitting1 decisiontreelearning_overfitting2 解決方案：修剪決策樹移除不可信賴的分支 事前修剪 (Prepruning) : 透過決策樹不再增長的方式來達到修剪的目的。選擇一個合適的臨界值往往很困難。 事後修剪 (Postpruning) : 子樹置換 (Subtree Replacement)：選擇某個子樹，並用單個樹葉來置換它。 子樹提升 (Subtree Raising)： decisiontreelearning_subtreeraising 合併連續值屬性 透過動態地定義新的離散值屬性來實現，即先把連續值屬性的值域分割為離散的區間集合，或設定門檻值以進行二分法。 屬性選擇指標的其他度量標準 訊息獲利 : 趨向於包含多個值的屬性 獲利比率 : 會產生不平均的分割，也就是分割的一邊會非常小於另一邊 吉尼係數 : 傾向於包含多個值的屬性，當類別個數很多時會有困難，傾向那些會導致平衡切割並且兩邊均為純粹的測試 ＜尚有其他的度量標準，也都各有利弊＞ 例題 A data set has 4 Boolean variables. What is the maximum number of leaves in a decision tree? \(2^4\) To each leaf in the decision, the number of corresponding rule is 1 If a decision tree achieves 100% accuracy on the training set, then it will also get 100% accuracy on the test set? No Using information gain to pick attributes, decision tree learning can be considered A* search algorithm. No A decision tree can describe any Boolean function? Yes 補充 C4.5 演算法 C4.5演算法利用屬性的獲利比率(Gain Ratio)克服問題，獲利比率是資訊獲利正規化後的結果。求算某屬性A的獲利比率時除資訊獲 利外，尚需計算該屬性的分割資訊值(Split Information) : SplitInfoA(S)=∑t∈T|Sj||S|×log2|Sj||S| C4.5的改善：對連續屬性的處理 改善ID3傾向選擇擁有許多不同數值但不具意義的屬性：之所以使用獲利比率(Gain Ratio)，是因為ID3演算法所使用的資訊獲利會傾向選擇擁有許多不同數值的屬性，例如：若依學生學號(獨一無二的屬性)進行分割，會產生出許多分支，且每一個分支都是很單一的結果，其資訊獲利會最大。但這個屬性對於建立決策樹是沒有意義的。 C5.0 演算法 C5.0 是 C4.5的商業改進版，可應用於海量資料集合上之分類。主要在執行準確度和記憶體耗用方面做了改進。因其採用Boosting方式來提高模型準確率，且佔用系統資源與記憶體較少，所以計算速度較快。其所使用的演算法沒有被公開。 C5.0 的優點： C5.0模型在面對遺漏值時非常穩定。 C5.0模型不需要很長的訓練次數。 C5.0模型比較其他類型的模型易於理解。 C5.0的增強技術提高分類的精度。 參考 Mr’ opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree Wiki - 熵 - 資訊理論 奧坎剃刀]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Decision Tree Lrearning</tag>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有關字串的名詞解釋]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F21%2F%E6%9C%89%E9%97%9C%E5%AD%97%E4%B8%B2%E7%9A%84%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B%2F</url>
    <content type="text"><![CDATA[字元 (character)： 孤單的一個符號。’7’,’1’, ’ 阿’, ’2’, ’ a’, ’ X’ 2. 字元集 (Alphabet)： 由字元組成的集合，通常會用\(\sum\)表示。 3. 字串 (String)： 由字元集中的字元構成的序列。”7122” 4. 子字串 (Substring)： 字串中的一段連續字元。”71” in ”7122” 5. 子序列 (Subsequence)： 字串中不需連續的一斷字元。”72” in ”7122” 6. 前綴 (Prefix)： 一個子字串包含第一個字元。”7”, ”71”, ”712”, ”7122” in ”7122”，在這裡所有文章我會命名為前總和，方便閱讀。 7. 後綴 (Suffix)： 一個子字串包含最後一個字元。”2”, ”22”, ”122”, ”7122” in ”7122”，，在這裡所有文章我會命名為後總和，方便閱讀。 8. 字典序 (Alphabetical Order)： 定義字串間的大小。先定義字元間的大小：\[’\,’ &lt; ’a’ &lt; ’b’ &lt; ’c’ &lt; ’d’ &lt; …&lt; ’z’\]通常就是照著 ASCII 碼的編排順序，要注意的是 空字元 比其他字元都小 接下來從第一個位置一位一位比對，由左而右比對方小的就是比較小的字串。 9. 後綴數組 (Suffix Array)： 將一個字串的所有後綴(後總和) ，照字典序排序後，所得的名次陣列。\[Sa[i]: 第i個後綴\] 10. 排名數組 (Rank Array)： 為後綴數組的逆數組。\[Ra[i]: 第 i 個後綴是*第幾名*\] 11. 最長共同前綴 (Longest Common Prefix)： 兩個字串，從第一位一位一位比對，直到不一樣就停止 \(ex:\) ’712221212’ 和’712222222’ 的LCP(最長共同前綴)：’71222’。 12. lcp(I, J)： 對於一個字串，他的第 I 個後綴和第 J 個後綴的 LCP 有多長 13. LCP(I, J)： 對於一個字串，他的第 I 名後綴與第 J 名後綴的 LCP 有多長 14. height[i]： 對於一個字串，LCP(i − 1, i) 15. h[i]： 對於一個字串，LCP(Ra[i] − 1, Ra[i]) # 參考 建國中學 2012 年資訊能力競賽培訓講義 - 08]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z - algorithm]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F19%2FZ-algorithm%2F</url>
    <content type="text"><![CDATA[這個演算法可以線性時間在一段文本(text) 裡面找到所有我們欲求的段落(pattern)。 今天，當我們的文本(text)的長度為 \(n\) 且欲求的段落(pattern)為 \(m\)時 ，搜尋只需要線性長度的時間 \(O(m+n)\) 即可，雖然這個演算法需要的空間(space complexity)與時間複雜度(time complexity)都與KMP algorithm一致，但是這個演算法比起KMP algoritjm還要容易了解。 KMP algorithm：每個前綴與其後綴的次長共同前綴（最長的後綴） Z algorithm：每個後綴與母字串的最長共同前綴（單純的長度） 首先，我們需要一個 \(Z\)陣列(\(Z\) array) \(Z\)陣列 當我們將欲檢索的文本存為一個字串 $ str[0 \ldots n-1] $ 時，同時也建立一個與字串一樣長的\(Z\)陣列。 在\(Z\)陣列中，第 \(i\) 元素紀錄「最長共同前總和 (Longest Common Prefix)的長度」，而 LCP 的長度 是由「從 \(i\) 開始的後總和 (Postfix)」與「該文本」共同決定。 ( 注意： \(Z[0]\) 毫無意義可言，因為從第0個開始的後總和(Postfix) 必與原本的文本字串相同。 ) 大致上我們可以看成如下的函式： Z演算法的表示法 \(Ex.\) 123Index 0 1 2 3 4 5 6 7 8 9 10 11 Text a a b c a a b x a a a zZ values 1 0 0 3 1 0 0 2 2 1 0 \(More\) \(ex.\) 12345678str = &quot;aaaaaa&quot;Z[] = &#123;x, 5, 4, 3, 2, 1&#125;str = &quot;aabaacd&quot;Z[] = &#123;x, 1, 0, 2, 1, 0, 0&#125;str = &quot;abababab&quot;Z[] = &#123;x, 0, 6, 0, 4, 0, 2, 0&#125; \(Z\) 陣列如何幫助演算法加速? 這個演算法的想法是將段落(pattern)與文本字串(text string)連接起來，若視段落(pattern)為「P」，視文本字串(text string)為「T」，並加上一個從未在段落與文本中出現過的字元「\$」再產生出如「P$T」的字串。 最後，我們再產生一個屬於「P$T」的 Z陣列，在 Z陣列之中，若該 Z值等於段落(pattern)的長度，段落出現在該處。 12345678910Example:Pattern P = &quot;aab&quot;, Text T = &quot;baabaa&quot;The concatenated string is&quot;a, a, b, $, b, a, a ,b ,a, a&quot;.Z array for above concatenated string is &#123;x, 1, 0, 0, 0, 3, 1, 0, 2, 1&#125;. ^Since length of pattern is 3, the value 3 in Z array indicates presence of pattern. 如何建立 \(Z\)陣列 最簡單的就是使用兩個迴圈，外層迴圈將整個「P$T」跑過一遍，內層迴圈則是看看到底 i 位置的後總和與「P$T」的LCP長度為何。 \(Time\) \(complexity:\) \[O(n^2)\] 我們當然可以使用另一種方法讓建立陣列的時間複雜度降低。 此演算法的關鍵在於要維護一個區間\([L \ldots R]\)，\(R\) 的位置代表由 \(L\) 處之後可以和整個字串最長的前總和重疊到的最後一個位置( 換句話說：\([L \ldots R]\)是整個字串的前綴子字串 )，若完全不重疊，則 \(L\) 與 \(R\)相等。 步驟 (\(i\) 為當前位置) 若 \(i &gt; R\) ，就代表當前 \(i\) 沒有經過任何「P$S」的前綴子字串，所以重置 \(L\) 與 \(R\) 的位置(\(L = i, R = i\))，經由比對「P$S」的前綴與 \(i\) 之後的前綴，並找出最長的子字串(\(R\) 的位置)，計算新的 \(L\) 與 \(R\) 的位置，也一併將 \(Z[i]\)值算出來(\(= R - L + 1\))。 若 \(i \leq R\) ，令 \(K = i - L\) ，再來我們知道 \(Z[i] \geq min(Z[K], R-i+1)\) 因為\(String[i \ldots]\)與\(String[K\ldots]\)共同前\(R-i+1\)個字元必然為[P$T]的前綴子字串。現在有兩種情形會發生： case1： 若\(Z[K] &lt; R-i+1\) ，代表沒有任何「P$S」的前綴子字串 從 \(i\) 位置開始(否則 \(Z[K]\) 的值會更大)，所以也意味著\(Z[i] = Z[K]\)，還有區間\([L\ldots R]\)不變。 case2： 若\(Z[K] \geq R-i+1\)，代表\(String[i \ldots]\)可以和\(String[0\ldots]\) 繼續比對相同的字元，也就意味有可能拓展\([L \ldots R]\) 區間，因此，我們會設 \(L = i\) ，接著從 \(R\) 之後開始繼續比對「P$S」的前綴子字串，最後我們會得到新的\(R\)，並更新\([L \ldots R]\) 區間與計算 \(Z[i]\) \(( = R - L + 1)\)。 想要了解上述的演算法可以經由這個連結觀看動畫。 小視窗 Z演算法的子問題 如果一個位置 \(i\) 位於之前比過的那段 \([L, R]\) 當中，他是否跟 \(Z[i − L]\) 相同呢？我們可以分成三種情形： 1. 要比的後綴根本不在以前比過的範圍\([L, R]\)內 → 就去比吧！ 2. 要比的後綴在以前比過的範圍\([L, R]\)但長度未知 → 還是去比吧！ 3. 要比的後綴在以前比過的範圍\([L, R]\)但長度已知 → 直接記錄囉！ 程式碼實作 台大資工PPT by nkng 12345678910void z_build(const char *S, int *Z) &#123; Z[0] = 0; int bst = 0; for(int i = 1; S[i]; i++) &#123; if(Z[bst] + bst &lt; i) Z[i] = 0; else Z[i] = min(Z[bst]+bst-i, Z[i-bst]); while(S[Z[i]] == S[i+Z[i]]) Z[i]++; if(Z[i] + i &gt; Z[bst] + bst) bst = i; &#125;&#125; Z algorithm - GeeksforGeeks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// A C++ program that implements Z algorithm for pattern searching#include&lt;iostream&gt;using namespace std; void getZarr(string str, int Z[]); // prints all occurrences of pattern in text using Z algovoid search(string text, string pattern)&#123; // Create concatenated string "P$T" string concat = pattern + "$" + text; int l = concat.length(); // Construct Z array int Z[l]; getZarr(concat, Z); // now looping through Z array for matching condition for (int i = 0; i &lt; l; ++i) &#123; // if Z[i] (matched region) is equal to pattern // length we got the pattern if (Z[i] == pattern.length()) cout &lt;&lt; "Pattern found at index " &lt;&lt; i - pattern.length() -1 &lt;&lt; endl; &#125;&#125; // Fills Z array for given string str[]void getZarr(string str, int Z[])&#123; int n = str.length(); int L, R, k; // [L,R] make a window which matches with prefix of s L = R = 0; for (int i = 1; i &lt; n; ++i) &#123; // if i&gt;R nothing matches so we will calculate. // Z[i] using naive way. if (i &gt; R) &#123; L = R = i; // R-L = 0 in starting, so it will start // checking from 0'th index. For example, // for "ababab" and i = 1, the value of R // remains 0 and Z[i] becomes 0. For string // "aaaaaa" and i = 1, Z[i] and R become 5 while (R&lt;n &amp;&amp; str[R-L] == str[R]) R++; Z[i] = R-L; R--; &#125; else &#123; // k = i-L so k corresponds to number which // matches in [L,R] interval. k = i-L; // if Z[k] is less than remaining interval // then Z[i] will be equal to Z[k]. // For example, str = "ababab", i = 3, R = 5 // and L = 2 if (Z[k] &lt; R-i+1) Z[i] = Z[k]; // For example str = "aaaaaa" and i = 2, R is 5, // L is 0 else &#123; // else start from R and check manually L = i; while (R&lt;n &amp;&amp; str[R-L] == str[R]) R++; Z[i] = R-L; R--; &#125; &#125; &#125;&#125; // Driver programint main()&#123; string text = "GEEKS FOR GEEKS"; string pattern = "GEEK"; search(text, pattern); return 0;&#125; 建國中學 2012 年資訊能力競賽培訓講義 - 08 123456789101112void Z_maker( int z[], char s[], int n )&#123; z[0] = n; int L = 0, R = 0, i, x; for( i = 1 ; i &lt; n ; i++ )&#123; if( R &lt; i || z[i-L] &gt;= R-i+1 )&#123; R &lt; i ? x = i : x = R+1; while( x &lt; n &amp;&amp; s[x] == s[x-i] ) x++; z[i] = x-i; if( i &lt; x )&#123; L = i; R = x-1; &#125; &#125; else z[i] = z[i-L]; &#125;&#125; Z algorithm - codeforces 12345678910111213141516int L = 0, R = 0;for (int i = 1; i &lt; n; i++) &#123; if (i &gt; R) &#123; L = R = i; while (R &lt; n &amp;&amp; s[R-L] == s[R]) R++; z[i] = R-L; R--; &#125; else &#123; int k = i-L; if (z[k] &lt; R-i+1) z[i] = z[k]; else &#123; L = i; while (R &lt; n &amp;&amp; s[R-L] == s[R]) R++; z[i] = R-L; R--; &#125; &#125;&#125; Z algorithm1 - 日月卦長的模板庫 123456789inline void z_alg1(char *s,int len,int *z)&#123; int l=0,r=0; z[0]=len; for(int i=1;i&lt;len;++i)&#123; z[i]=r&gt;i?min(r-i+1,z[z[l]-(r-i+1)]):0; while(i+z[i]&lt;len&amp;&amp;s[z[i]]==s[i+z[i]])++z[i]; if(i+z[i]-1&gt;r)r=i+z[i]-1,l=i; &#125;&#125; Z algorithm2 - 日月卦長的模板庫 123456789inline void z_alg2(char *s,int len,int *z)&#123; int l=0,r=0; z[0]=len; for(int i=1;i&lt;len;++i)&#123; z[i]=i&gt;r?0:(i-l+z[i-l]&lt;z[l]?z[i-l]:r-i+1); while(i+z[i]&lt;len&amp;&amp;s[i+z[i]]==s[z[i]])++z[i]; if(i+z[i]-1&gt;r)r=i+z[i]-1,l=i; &#125;&#125; 培訓-4 字串- tioj 12345678910void z_build(const char* S,int *z)&#123; z[0]=0; int bst=0; for(int i=1;S[i];i++)&#123; if(z[bst]+bst&lt;i) z[i]=0; else z[i]=std::min(z[bst]+bst−i,z[i−bst]); while(S[z[i]]==S[i+z[i]]) z[i]++; if(z[i]+i&gt;z[bst]+bst) bst=i; &#125;&#125; 例題 TIOJ 1725_Z algorithm_Massacre at Camp Happy 參考 Z algorithm - GeeksforGeeks 建國中學 2012 年資訊能力競賽培訓講義 - 08 培訓-4 字串- tioj 台大資工講義 by nkng Z algorithm - codeforces Gusfield algorithm - momo funny codes Z algorithm - 日月卦長的模板庫 待補充 KMP 字串比對演算法 http://mropengate.blogspot.tw/2016/01/leetcode-kmpimplement-strstr.html]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Substring</tag>
        <tag>Z Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰勒級數]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F16%2F%E6%B3%B0%E5%8B%92%E7%B4%9A%E6%95%B8%2F</url>
    <content type="text"><![CDATA[在數學中，泰勒級數（英語：Taylor series）用無限項連加式——級數來表示一個函數，這些相加的項由函數在某一點的導數求得。泰勒級數是以於1715年發表了泰勒公式的英國數學家布魯克·泰勒（Sir Brook Taylor）來命名的。通過函數在自變量零點的導數求得的泰勒級數又叫做麥克勞林級數，以蘇格蘭數學家科林·麥克勞林的名字命名。 拉格朗日在1797年之前，最先提出帶有餘項的現在形式的泰勒定理。實際應用中，泰勒級數需要截斷，只取有限項，可以用泰勒定理估算這種近似的誤差。一個函數的有限項的泰勒級數叫做泰勒多項式。一個函數的泰勒級數是其泰勒多項式的極限（如果存在極限）。即使泰勒級數在每點都收斂，函數與其泰勒級數也可能不相等。開區間（或複平面開片）上，與自身泰勒級數相等的函數稱為解析函數。 定義 在數學上，一個在實數或複數 \(a\) 在 鄰域上的無窮可微實變函數或複變函數 \(f(x)\) 的泰勒級數是如下的冪級數 (若與原函式相等時為解析函數)： \[ f(x) \simeq \sum_{n=0}^{\infty }{\frac {f^{(n)}(a)}{n!}}(x-a)^{n} \] 而 \(f^{(n)}(a)\)表示函數 \(f\) 在點 $ a$ 處的 $ n$ 階導數。如果 \(a=0\) ，那麼這個級數也可以被稱為麥克勞林級數。 而多項式函數 \(f(x)\) 在 \(x = a\) 時，\(n\) 階的泰勒展開式 \(P_{n}(x)\) 是： \[ P_{n}(x) = \sum_{i = 0}^{n} \frac{ f^{(i)}(a) }{ i! }\cdot \left(x-a \right)^{i} \] 解析函數 Read more-1 (wiki)，Read more-2 (wiki) 如果泰勒級數對於區間 \((a-r,a+r)\)中的所有 \(x\) 都收斂並且級數的和等於 \(f(x)\) ，那麼我們就稱函數 \(f(x)\) 為解析的（analytic）。若且唯若一個函數可以表示成為冪級數的形式時，它才是解析的。為了檢查級數是否收斂於 \(f(x)\)，通常採用泰勒定理估計級數的餘項 (數值方法)。上面給出的冪級數展開式中的係數正好是泰勒級數中的係數。 泰勒級數的重要性體現在以下三個方面： 冪級數的求導和積分可以逐項進行，因此求和函數相對比較容易。 一個解析函數可被延伸為一個定義在複平面上的一個開片上的解析函數，並使得複分析這種手法可行。 泰勒級數可以用來近似計算函數的值。 對定值 x 而言，函數的精準度會隨著多項式的次數 n 的增加而增加。 對一個固定次數的多項式而言， 確度隨著 x 離開 x=0 處而遞減。 泰勒級數列表(常用) 注意：核函數 $ x$ 為 複數 時它們依然成立！ 幾何級數(等比數列) \[ \frac {1}{1-x} = \sum_{n=0}^{\infty }x^{n}\quad \forall x:\left|x\right|&lt;1 \] 二項式定理 \[ (1+x)^{\alpha }=\sum_{n=0}^{\infty }C^\alpha_n \cdot x^{n}\quad \forall x:\left|x\right|&lt;1,\forall \alpha \in \mathbb{C} \] 指數函數 \[ e^{x}=\sum_{n=0}^{\infty }{\frac {x^{n}}{n!}}\quad \forall x \] \(f(x) = e^x\) 在 \(x = 0\) 的泰勒展開式。 當\(n = 1\)時，\(P_{1}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1\) 當\(n = 2\)時，\(P_{2}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2\) 當\(n = 3\)時，\(P_{3}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2 + \frac{\left( e^0\right)^{(3)}}{3!}\cdot\left( x - 0 \right)^3\) \(...\) 自然對數 \[ \ln(1+x)=\sum_{n=1}^{\infty }{\frac {(-1)^{n+1}}{n}}x^{n}\quad \forall x\in (-1,1] \] 牛頓插值公式的淵源 Read more-1(wiki)，Read more-2(wiki) 牛頓插值公式也叫做牛頓級數，由「牛頓 前向 差分方程」的項組成，得名於伊薩克·牛頓爵士。一般稱其為連續「泰勒展開」的離散對應。 差分 差分，又名差分函數或差分運算，是數學中的一個概念。它將原函數 \(f(x)\) 映射到 \(f(x+a)-f(x+b)\) 。差分運算，相應於微分運算，是微積分中重要的一個概念。 定義 前向差分的定義為： \[ \Delta_{h}^{1}[f](x) = f(x + h) - f(x) \] \[ \Delta_{h}^{n}[f](x) = \Delta_{h}^{n-1}[f](x + h) - \Delta_{h}^{n-1}[f](x) \] $, where $ $ h =$ $ “x”$ \(一步的間距，若無下標h，那間距h = 1。\) 前向差分 函數的前向差分通常簡稱為函數的差分。對於函數 \(f(x)\) ，如果在等距節點： \[ x_{k}=x_{0}+kh,(k=0,1,...,n) \] \[ \Delta f(x_{k})=f(x_{k+1})-f(x_{k}) \] 則稱 \(\Delta f(x)\)，函數在每個小區間上的增量 \(y_{k+1}-y_{k}\) 為 \(f(x)\) 一階差分。 後向差分 對於函數 \(f(x_{k})\)，如果： \[ \nabla f(x_{k})=f(x_{k})-f(x_{k-1}) \] 則稱 \(\nabla f(x_{k})\) 為 \(f(x)\) 的一階逆向差分。]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Taylor Series</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指對數]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F15%2F%E6%8C%87%E5%B0%8D%E6%95%B8%2F</url>
    <content type="text"><![CDATA[“\(e^{x}\)” 緣起 首先，要先從複利的公式開始說明： \[ 一年後的本利和 = \left(1+\frac{年利率}{期數} \right)^{期數} \] 其中期數就是看多久複利一次。一個月複利一次的話期數就是12。 依上述所說，設 1 份借貸有 x 年利率，逐月複利話，則每月增加當前值的 \(\frac{x}{12}\) 倍，每月總值都要乘以 \(1 + \frac{x}{12}\)，一年的總值為 \(\left(1 + \frac{x}{12} \right)^{12}\)，逐日複利的話，就是 \(\left (1+ \frac{x}{365} \right)^{365}\)。設年中時段數可為無限，則有如下最初由歐拉提出的指數函數定義： \[ \\lim_{n \to \infty}\left ( 1 + \frac{x}{n} \right )^{n} \] 然後才真正的導出e這個數字，一開始存1元，如果年利率是100%，如果每分每秒都算利息，那麼一年後會得到的利息大約是2.71828，如果把算利息的區間縮到無限小，也就是期數變成無限大的話，就會得到 \[ \lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n} = e \] 由上式我們則可以得到, \[ \lim_{n \to \infty}\left ( 1 + \frac{x}{n} \right )^{n} = \lim_{n \to \infty} \left ( \left ( 1 + \frac{1}{\frac{n}{x}} \right )^{\frac{n}{x}} \right )^{x} \approx e^{x} \] 其中， \[ \lim_{n \to \infty} \left ( 1 + \frac{1}{\frac{n}{x}} \right )^{\frac{n}{x}} \approx e^{1} = e \] 而這是它寫為 \(e^{x}\) 的原因。 wiki-exponential 所以指數函數有基本的恆等式： \[ e^{x+y} = e^{x} \cdot e^{y} \] \[ \parallel \] \[ \exp\left ( x + y \right ) = \exp\left ( x \right ) \cdot \exp\left ( y \right ) \] 性質 所以，正常指數該有的性質 \(e\) 也都有具備，令 \(\forall x, y\in \mathrm{R}\) ，則： \(e^{0}=1\) \(e^{1}=e\) \(e^{x+y}=e^{x}e^{y}\) \(e^{x \cdot y}=\left(e^{x}\right)^{y}\) \(e^{-x}={1 \over e^{x}}\) 微分 微分的時候需要下面這個式子： \[ \lim_{n \to \infty} \left(1 + \frac{1}{n}\right) =\lim_{n \to \infty}\left(\left(1 + \frac{1}{\frac{n}{1}}\right)^{\frac{n}{1}}\right)^{\frac{1}{n}} \approx \lim_{n \to \infty} e^{\frac{1}{n}} \Rightarrow e^{\Delta x} \approx (1 + \Delta x) \] 其中， \(\lim_{n \to \infty} \left ( 1 + \frac{1}{\frac{n}{1}} \right )^{\frac{n}{1}} \approx e^{1} = e\) 當\(n \to \infty\)時 \(\frac{1}{n}\) 可視為一個很小的量 \(\Delta x\) ，也就是： \[ \lim_{m \to 0} (1 + m ) \approx \lim_{m \to 0} e^{m} \] \[ (1 + 很小 ) \approx e^{很小} \] \[ (1 + \Delta x ) \approx e^{\Delta x} \] 微分推導 \[ \Delta y = e^{x+\Delta x} - e^{x} = e^{\Delta x}\cdot e^{x} - 1\cdot e^{x} = (e^{\Delta x} - 1) e^{x} \] 又因： \[ e^{\Delta x} \approx (1 + \Delta x) \] 所以： \[ \Delta y \approx e^{x}\Delta x \rightarrow dy = e^{x}\cdot dx \] 小結： \[ de^{□} = e^{□}d□ \] \(ex.\) \[ de^{-x^2} = e^{-x^2}\cdot d(-x^2) = (-2x)\cdot e^{-x^2}\cdot dx \] 一般化： $y = a^x \(&lt;br&gt;\)y = e^{} = e^{x} $ (對 \(y\) 作微分)\(\Rightarrow dy= e^{x\cdot\ln{a}} \cdot \left ( x\cdot\ln{a} \right )\)\(\Rightarrow dy=a^x\cdot \ln a \cdot dx\) “\(e^{x}\)” 的反函數 對數函數，就是 \(e^{x}\) 的反函數，也就是 \[ y = \log_{e}{x} = \ln{x} \quad x = e^{y} \] img 定義 尤拉定義自然對數為序列的極限： \[ \ln (x) = \lim_{x\rightarrow \infty} n(x^{\frac{1}{n}}- 1) \] 正式的定義為積分\(\ln (a)\)： \[ \ln (a) = \int_1^a \frac{1}{x} dx \] 對 “\(\ln{x}\)” 做微分 簡單地，我們可以推得： $y = x $ $x = e^y $ $dx = e^y dy \(&lt;br&gt;\)dy = dx = dx $ (移&quot; \(e^{y}\) &quot;項) img Proof \(\ln x = \int_1^x \frac{1}{x} dx\) \(\frac{d}{dx}\ln x = \lim_{h \rightarrow 0} (\frac{\ln(x+h) - \ln x}{h})\) \(\Leftrightarrow \lim_{h \rightarrow 0} (\frac{1}{h}\cdot \ln(\frac{x+h}{x}))\) \(\Leftrightarrow \lim_{h \rightarrow 0} (\ln (1+\frac{h}{x})^{\frac{1}{h}})\) ＜Note＞：\(Let \; u = \frac{h}{x} , h = u\cdot x \rightarrow h \; gose \; to \; 0 \; then \; u \; gose \; to \; 0\) \(\Rightarrow \lim_{u \to 0} (\ln (1+u)^{\frac{1}{u\cdot x}} ) \Rightarrow \lim_{u \to 0} (\ln(1+u)^{\frac{1}{u}^\frac{1}{x}})\) \(\Leftrightarrow \lim_{u \to 0} (\frac{1}{x} \cdot ln (1 + u)^{\frac{1}{u}})\) \(\Leftrightarrow \frac{1}{x} \lim_{u \to 0} (\ln(1+u)^{\frac{1}{u}})\) ＜Note＞：$Let ; n = u ; gose ; to ; 0 ; then ; n ; gose ; to ; $ \(\Rightarrow \frac{1}{x} lim_{n \to \infty} (\ln (1 + \frac{1}{n})^n)\) \(\Leftrightarrow \frac{1}{x} \ln( \lim_{n \to \infty} (1 + \frac{1}{n})^n )\) \(\Leftrightarrow \frac{1}{x} \ln e \Leftrightarrow \frac{1}{x}\) $ _1^x dt $（微積分第一基本定理） \[ \frac{d}{dx} \ln x = \frac{d}{dx} \int_1^x \frac{1}{t} dt \Leftrightarrow \ln x = \int_1^x \frac{1}{t} dt \] 一般化： $y=_a x $ \(\Rightarrow y = \frac{\ln{x}}{\ln{a}}\) \(\Rightarrow dy=\frac{1}{x}\cdot \frac{1}{\ln a} \cdot dx\) &quot; \(f \left( x\right) = x^x\) &quot;的微分 兩側取 “\(\ln\)” \[ \ln \left( f \left( x\right) \right) = x \cdot \ln{x} \] 對兩側微分 \[ \frac{f&#39;(x)}{f(x)} = \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right) \] 對兩側乘上 “\(f(x)\)” \[ f&#39;(x) = \left( \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right) \right) \cdot f(x) \] \[ \Rightarrow f&#39;(x) = \left( \ln{x} + 1 \right) \cdot \left( x^x \right) \] 參考 成大微積分指對數函數的微分(第四週共筆) 維基百科 - e (數學常數) 維基百科 - 指數函數 中華科大 - PART 10：指數與對數微分公式彙整]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Exponent</tag>
        <tag>Logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 文法測試]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F06%2FMathJax-test%2F</url>
    <content type="text"><![CDATA[Admin + MathJax + Pandoc 測試 \[ \lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n} \] \[ \left\{\begin{matrix}a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right. \]]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇測試發文]]></title>
    <url>%2Fwillywangkaa%2F2018%2F03%2F06%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B8%AC%E8%A9%A6%E7%99%BC%E6%96%87%2F</url>
    <content type="text"><![CDATA[H1 H2 H3 H4 H5 H6]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Mark Down</tag>
      </tags>
  </entry>
</search>
